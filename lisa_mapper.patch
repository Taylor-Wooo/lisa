diff -Nur cgra_me/arch/simple/archfiles/archfile.xml lisa/cgra_me/arch/simple/archfiles/archfile.xml
--- cgra_me/arch/simple/archfiles/archfile.xml	2018-05-09 09:34:57.000000000 +0800
+++ lisa/cgra_me/arch/simple/archfiles/archfile.xml	2022-02-28 16:37:25.868775474 +0800
@@ -1,26 +1,26 @@
 <architecture row="4" col="4">
     <pattern col-range="1 2" row-range="0 0">
-        <block module="block1"/>
-        <connection from="(rel 0 0).out" to="(rel 1 0).in2"/>
-        <connection from="(rel 1 0).out" to="(rel 0 0).in2"/>
+        <block module="meshblock1"/>
+        <connection from="(rel 0 0).out0" to="(rel 1 0).in2"/>
+        <connection from="(rel 1 0).out0" to="(rel 0 0).in2"/>
     </pattern>
 
     <pattern col-range="1 2" row-range="3 3">
-        <block module="block2"/>
-        <connection from="(rel 0 0).out" to="(rel -1 0).in2"/>
+        <block module="meshblock1"/>
+        <connection from="(rel 0 0).out0" to="(rel -1 0).in2"/>
     </pattern>
 
     <pattern col-range="0 0" row-range="1 2">
-        <block module="block2"/>
+        <block module="MemPort"/>
         <connection from="(rel 0 0).out" to="(rel 0 1).in2"/>
     </pattern>
 
     <pattern col-range="3 3" row-range="1 2">
-        <block module="block2"/>
-        <connection from="(rel 0 0).out" to="(rel 0 -1).in2"/>
+        <block module="meshblock1"/>
+        <connection from="(rel 0 0).out0" to="(rel 0 -1).in2"/>
     </pattern>
 
     <pattern col-range="1 2" row-range="1 2" counter="stupid counter name" wrap-around="on">
-        <block module="block1"/>
+        <block module="meshblock1"/>
     </pattern>
 </architecture>
diff -Nur cgra_me/arch/simple/archfiles/arch-homo-orth.xml lisa/cgra_me/arch/simple/archfiles/arch-homo-orth.xml
--- cgra_me/arch/simple/archfiles/arch-homo-orth.xml	2018-05-09 09:34:57.000000000 +0800
+++ lisa/cgra_me/arch/simple/archfiles/arch-homo-orth.xml	2022-02-28 16:37:25.868775474 +0800
@@ -1,9 +1,9 @@
-  <architecture col="10" row="10">
-    <diagonal row-range="0 9" col-range="0 9" 
-          out-north=".out"
-          out-east=".out"
-          out-west=".out"
-          out-south=".out"
+  <architecture col="4" row="4">
+    <mesh row-range="0 3" col-range="0 3" 
+          out-north=".out0"
+          out-east=".out1"
+          out-west=".out2"
+          out-south=".out3"
           in-north=".in0"
           in-east=".in1"
           in-west=".in2"
@@ -11,7 +11,7 @@
           io="every-side-port"
           >
       <interior>
-        <block module="block2">
+        <block module="meshblock1">
       </interior>
     </diagonal>
   </architecture>
diff -Nur cgra_me/arch/simple/arch-hetero-orth.xml lisa/cgra_me/arch/simple/arch-hetero-orth.xml
--- cgra_me/arch/simple/arch-hetero-orth.xml	2018-05-09 09:34:57.000000000 +0800
+++ lisa/cgra_me/arch/simple/arch-hetero-orth.xml	2022-02-28 16:37:25.868775474 +0800
@@ -26,9 +26,9 @@
           >
       <interior row="1">
         <block module="block1" mode="add sub mul div and or xor shl shr"/>
-        <block module="block1" mode="add sub and or xor shl shr"/>
-        <block module="block1" mode="add sub and or xor shl shr"/>
-        <block module="block1" mode="add sub and or xor shl shr"/>
+        <block module="block1" mode="add sub mul and or xor shl shr"/>
+        <block module="block1" mode="add sub mul and or xor shl shr"/>
+        <block module="block1" mode="add sub mul and or xor shl shr"/>
         <block module="block1" mode="add sub and or xor shl shr"/>
         <block module="block1" mode="add sub and or xor shl shr"/>
         <block module="block1" mode="add sub and or xor shl shr"/>
diff -Nur cgra_me/arch/simple/target_arch/arch-homo-orth_10_2_adres-no-torroid.xml lisa/cgra_me/arch/simple/target_arch/arch-homo-orth_10_2_adres-no-torroid.xml
--- cgra_me/arch/simple/target_arch/arch-homo-orth_10_2_adres-no-torroid.xml	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/arch/simple/target_arch/arch-homo-orth_10_2_adres-no-torroid.xml	2022-02-28 16:37:25.868775474 +0800
@@ -0,0 +1,81 @@
+<architecture rows="12" cols="4">
+	<!-- Add the register file to the top -->
+	<pattern row-range="0 0" col-range="0 0">
+		<block module="globalRF"/>
+	</pattern>
+
+	<!-- Add the IOs -->
+	<pattern row-range="1 1" col-range="0 3">
+		<block module="IO"/>
+	</pattern>
+
+	<!-- Add the MemUs -->
+	<pattern row-range="2 11" col-range="0 0" row-skip="2">
+		<block module="MemPort"/>
+	</pattern>
+
+	<!-- Add the VLIW FUs -->
+	<pattern row-range="3 3" col-range="0 3">
+		<block module="VLIWAdresPE"/>
+	</pattern>
+
+	<!-- Add the external register files -->
+	<pattern row-range="4 10" col-range="0 3" row-skip="2">
+		<block module="externRF1_1"/>
+	</pattern>
+
+	<!-- Add the CGA FUs -->
+	<pattern row-range="6 12" col-range="0 3" row-skip="2">
+		<block module="CGAAdresPE"/>
+	</pattern>
+
+	<!-- MemPort to PE connections -->
+	<pattern row-range="2 11" col-range="0 0" row-skip="2">
+		<connection from="(rel 0 0).out" to="(rel 1 0).in7"/>
+		<connection from="(rel 0 0).out" to="(rel 1 1).in7"/>
+		<connection from="(rel 0 0).out" to="(rel 1 2).in7"/>
+		<connection from="(rel 0 0).out" to="(rel 1 3).in7"/>
+		<connection from="(rel 1 0).out" to="(rel 0 0).in0"/>
+		<connection from="(rel 1 1).out" to="(rel 0 0).in1"/>
+		<connection from="(rel 1 2).out" to="(rel 0 0).in2"/>
+		<connection from="(rel 1 3).out" to="(rel 0 0).in3"/>
+	</pattern>
+
+	<!-- IO to PE connections -->
+	<pattern row-range="1 1" col-range="0 3">
+		<connection from="(rel 0 0).out" to="(rel 2 0).in0"/>
+		<connection from="(rel 2 0).out" to="(rel 0 0).in"/>
+	</pattern>
+
+	<!-- VLIW FUs to shared register file -->
+	<pattern row-range="3 3" col-range="0 3" counter="i">
+		<connection from="(rel -3 -(i)).out(i)*2" to="(rel 0 0).rf_in_muxa"/>
+		<connection from="(rel -3 -(i)).out(i)*2+1" to="(rel 0 0).rf_in_muxout"/>
+		<connection from="(rel 0 0).rf_out" to="(rel -3 -(i)).in(i)"/>
+	</pattern>
+
+	<!-- Connect the external regsiter files to their PEs -->
+	<pattern row-range="4 12" col-range="0 3" row-skip="2">
+		<connection from="(rel 0 0).out0" to="(rel 2 0).rf_in_muxa"/>
+		<connection from="(rel 0 0).out1" to="(rel 2 0).rf_in_muxout"/>
+		<connection from="(rel 2 0).rf_out" to="(rel 0 0).in0"/>
+	</pattern>
+
+	<!-- North/South inter PE connections -->
+	<pattern row-range="3 9" col-range="0 3" row-skip="2">
+		<connection from="(rel 0 0).out" to="(rel 3 0).in0"/>
+		<connection from="(rel 3 0).out" to="(rel 0 0).in2"/>
+	</pattern>
+
+	<!-- East/West inter PE connections -->
+	<pattern row-range="3 12" col-range="0 2" row-skip="2">
+		<connection from="(rel 0 0).out" to="(rel 0 1).in3"/>
+		<connection from="(rel 0 1).out" to="(rel 0 0).in1"/>
+	</pattern>
+
+	<!-- Add the IO ports -->
+	<pattern col-range="0 3" row-range="1 1" counter="i">
+		<inout name="bidir(i)"/>
+		<connection from="this.bidir(i)" to="(rel 0 0).bidir"/>
+	</pattern>
+</architecture>
diff -Nur cgra_me/arch/simple/target_arch/arch-homo-orth_10_2_adres-torroid.xml lisa/cgra_me/arch/simple/target_arch/arch-homo-orth_10_2_adres-torroid.xml
--- cgra_me/arch/simple/target_arch/arch-homo-orth_10_2_adres-torroid.xml	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/arch/simple/target_arch/arch-homo-orth_10_2_adres-torroid.xml	2022-02-28 16:37:25.868775474 +0800
@@ -0,0 +1,87 @@
+<architecture rows="12" cols="4">
+	<!-- Add the register file to the top -->
+	<pattern row-range="0 0" col-range="0 0">
+		<block module="globalRF"/>
+	</pattern>
+
+	<!-- Add the IOs -->
+	<pattern row-range="1 1" col-range="0 3">
+		<block module="IO"/>
+	</pattern>
+
+	<!-- Add the MemUs -->
+	<pattern row-range="2 11" col-range="0 0" row-skip="2">
+		<block module="MemPort"/>
+	</pattern>
+
+	<!-- Add the VLIW FUs -->
+	<pattern row-range="3 3" col-range="0 3">
+		<block module="VLIWAdresPETorroid"/>
+	</pattern>
+
+	<!-- Add the external register files -->
+	<pattern row-range="4 10" col-range="0 3" row-skip="2">
+		<block module="externRF1_1"/>
+	</pattern>
+
+	<!-- Add the CGA FUs -->
+	<pattern row-range="6 12" col-range="0 3" row-skip="2">
+		<block module="CGAAdresPE"/>
+	</pattern>
+
+	<!-- MemPort to PE connections -->
+	<pattern row-range="2 11" col-range="0 0" row-skip="2">
+		<connection from="(rel 0 0).out" to="(rel 1 0).in7"/>
+		<connection from="(rel 0 0).out" to="(rel 1 1).in7"/>
+		<connection from="(rel 0 0).out" to="(rel 1 2).in7"/>
+		<connection from="(rel 0 0).out" to="(rel 1 3).in7"/>
+		<connection from="(rel 1 0).out" to="(rel 0 0).in0"/>
+		<connection from="(rel 1 1).out" to="(rel 0 0).in1"/>
+		<connection from="(rel 1 2).out" to="(rel 0 0).in2"/>
+		<connection from="(rel 1 3).out" to="(rel 0 0).in3"/>
+	</pattern>
+
+	<!-- IO to PE connections -->
+	<pattern row-range="1 1" col-range="0 3">
+		<connection from="(rel 0 0).out" to="(rel 2 0).in0"/>
+		<connection from="(rel 2 0).out" to="(rel 0 0).in"/>
+	</pattern>
+
+	<!-- VLIW FUs to shared register file -->
+	<pattern row-range="3 3" col-range="0 3" counter="i">
+		<connection from="(rel -3 -(i)).out(i)*2" to="(rel 0 0).rf_in_muxa"/>
+		<connection from="(rel -3 -(i)).out(i)*2+1" to="(rel 0 0).rf_in_muxout"/>
+		<connection from="(rel 0 0).rf_out" to="(rel -3 -(i)).in(i)"/>
+	</pattern>
+
+	<!-- Connect the external regsiter files to their PEs -->
+	<pattern row-range="4 12" col-range="0 3" row-skip="2">
+		<connection from="(rel 0 0).out0" to="(rel 2 0).rf_in_muxa"/>
+		<connection from="(rel 0 0).out1" to="(rel 2 0).rf_in_muxout"/>
+		<connection from="(rel 2 0).rf_out" to="(rel 0 0).in0"/>
+	</pattern>
+
+	<!-- North/South inter PE connections -->
+	<pattern row-range="3 9" col-range="0 3" row-skip="2">
+		<connection from="(rel 0 0).out" to="(rel 3 0).in0"/>
+		<connection from="(rel 3 0).out" to="(rel 0 0).in2"/>
+	</pattern>
+
+	<!-- East/West inter PE connections with torroid -->
+	<pattern row-range="3 12" col-range="0 3" row-skip="2" wrap-around="on">
+		<connection from="(rel 0 0).out" to="(rel 0 1).in3"/>
+		<connection from="(rel 0 1).out" to="(rel 0 0).in1"/>
+	</pattern>
+
+	<!-- Torroid connections -->
+	<pattern row-range="3 3" col-range="0 3">
+		<connection from="(rel 0 0).out" to="(rel 9 0).in2"/>
+		<connection from="(rel 9 0).out" to="(rel 0 0).in4"/>
+	</pattern>
+
+	<!-- Add the IO ports -->
+	<pattern col-range="0 3" row-range="1 1" counter="i">
+		<inout name="bidir(i)"/>
+		<connection from="this.bidir(i)" to="(rel 0 0).bidir"/>
+	</pattern>
+</architecture>
diff -Nur cgra_me/arch/simple/target_arch/arch-homo-orth_2_2_1reg.xml lisa/cgra_me/arch/simple/target_arch/arch-homo-orth_2_2_1reg.xml
--- cgra_me/arch/simple/target_arch/arch-homo-orth_2_2_1reg.xml	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/arch/simple/target_arch/arch-homo-orth_2_2_1reg.xml	2022-02-28 16:37:25.868775474 +0800
@@ -0,0 +1,17 @@
+  <architecture col="4" row="4">
+    <mesh row-range="0 3" col-range="0 3" 
+          out-north=".out0"
+          out-east=".out1"
+          out-west=".out2"
+          out-south=".out3"
+          in-north=".in0"
+          in-east=".in1"
+          in-west=".in2"
+          in-south=".in3"
+          io="every-side-port"
+          >
+      <interior>
+        <block module="meshbock_1reg">
+      </interior>
+    </diagonal>
+  </architecture>
diff -Nur cgra_me/arch/simple/target_arch/arch-homo-orth_2_2_noreg.xml lisa/cgra_me/arch/simple/target_arch/arch-homo-orth_2_2_noreg.xml
--- cgra_me/arch/simple/target_arch/arch-homo-orth_2_2_noreg.xml	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/arch/simple/target_arch/arch-homo-orth_2_2_noreg.xml	2022-02-28 16:37:25.868775474 +0800
@@ -0,0 +1,17 @@
+  <architecture col="4" row="4">
+    <mesh row-range="0 3" col-range="0 3" 
+          out-north=".out0"
+          out-east=".out1"
+          out-west=".out2"
+          out-south=".out3"
+          in-north=".in0"
+          in-east=".in1"
+          in-west=".in2"
+          in-south=".in3"
+          io="every-side-port"
+          >
+      <interior>
+        <block module="meshbock_noreg">
+      </interior>
+    </diagonal>
+  </architecture>
diff -Nur cgra_me/arch/simple/target_arch/arch-homo-orth_2_2.xml lisa/cgra_me/arch/simple/target_arch/arch-homo-orth_2_2.xml
--- cgra_me/arch/simple/target_arch/arch-homo-orth_2_2.xml	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/arch/simple/target_arch/arch-homo-orth_2_2.xml	2022-02-28 16:37:25.868775474 +0800
@@ -0,0 +1,17 @@
+  <architecture col="4" row="4">
+    <mesh row-range="0 3" col-range="0 3" 
+          out-north=".out0"
+          out-east=".out1"
+          out-west=".out2"
+          out-south=".out3"
+          in-north=".in0"
+          in-east=".in1"
+          in-west=".in2"
+          in-south=".in3"
+          io="every-side-port"
+          >
+      <interior>
+        <block module="meshblock1">
+      </interior>
+    </diagonal>
+  </architecture>
diff -Nur cgra_me/arch/simple/target_arch/arch-homo-orth_3_3.xml lisa/cgra_me/arch/simple/target_arch/arch-homo-orth_3_3.xml
--- cgra_me/arch/simple/target_arch/arch-homo-orth_3_3.xml	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/arch/simple/target_arch/arch-homo-orth_3_3.xml	2022-02-28 16:37:25.868775474 +0800
@@ -0,0 +1,17 @@
+  <architecture col="5" row="5">
+    <mesh row-range="0 4" col-range="0 4" 
+          out-north=".out0"
+          out-east=".out1"
+          out-west=".out2"
+          out-south=".out3"
+          in-north=".in0"
+          in-east=".in1"
+          in-west=".in2"
+          in-south=".in3"
+          io="every-side-port"
+          >
+      <interior>
+        <block module="meshblock1">
+      </interior>
+    </diagonal>
+  </architecture>
diff -Nur cgra_me/arch/simple/target_arch/arch-homo-orth_4_4_1reg.xml lisa/cgra_me/arch/simple/target_arch/arch-homo-orth_4_4_1reg.xml
--- cgra_me/arch/simple/target_arch/arch-homo-orth_4_4_1reg.xml	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/arch/simple/target_arch/arch-homo-orth_4_4_1reg.xml	2022-02-28 16:37:25.868775474 +0800
@@ -0,0 +1,17 @@
+  <architecture col="6" row="6">
+    <mesh row-range="0 5" col-range="0 5" 
+          out-north=".out0"
+          out-east=".out1"
+          out-west=".out2"
+          out-south=".out3"
+          in-north=".in0"
+          in-east=".in1"
+          in-west=".in2"
+          in-south=".in3"
+          io="every-side-port"
+          >
+      <interior>
+        <block module="meshbock_1reg">
+      </interior>
+    </diagonal>
+  </architecture>
diff -Nur cgra_me/arch/simple/target_arch/arch-homo-orth_4_4_leftmostmemory.xml lisa/cgra_me/arch/simple/target_arch/arch-homo-orth_4_4_leftmostmemory.xml
--- cgra_me/arch/simple/target_arch/arch-homo-orth_4_4_leftmostmemory.xml	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/arch/simple/target_arch/arch-homo-orth_4_4_leftmostmemory.xml	2022-02-28 16:37:25.868775474 +0800
@@ -0,0 +1,17 @@
+  <architecture col="6" row="6">
+    <mesh row-range="0 5" col-range="0 5" 
+          out-north=".out0"
+          out-east=".out1"
+          out-west=".out2"
+          out-south=".out3"
+          in-north=".in0"
+          in-east=".in1"
+          in-west=".in2"
+          in-south=".in3"
+          io="every-side-port"
+          >
+      <interior>
+        <block module="meshblock1">
+      </interior>
+    </diagonal>
+  </architecture>
diff -Nur cgra_me/arch/simple/target_arch/arch-homo-orth_4_4_noreg.xml lisa/cgra_me/arch/simple/target_arch/arch-homo-orth_4_4_noreg.xml
--- cgra_me/arch/simple/target_arch/arch-homo-orth_4_4_noreg.xml	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/arch/simple/target_arch/arch-homo-orth_4_4_noreg.xml	2022-02-28 16:37:25.868775474 +0800
@@ -0,0 +1,17 @@
+  <architecture col="6" row="6">
+    <mesh row-range="0 5" col-range="0 5" 
+          out-north=".out0"
+          out-east=".out1"
+          out-west=".out2"
+          out-south=".out3"
+          in-north=".in0"
+          in-east=".in1"
+          in-west=".in2"
+          in-south=".in3"
+          io="every-side-port"
+          >
+      <interior>
+        <block module="meshbock_noreg">
+      </interior>
+    </diagonal>
+  </architecture>
diff -Nur cgra_me/arch/simple/target_arch/arch-homo-orth_4_4_specialNOC.xml lisa/cgra_me/arch/simple/target_arch/arch-homo-orth_4_4_specialNOC.xml
--- cgra_me/arch/simple/target_arch/arch-homo-orth_4_4_specialNOC.xml	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/arch/simple/target_arch/arch-homo-orth_4_4_specialNOC.xml	2022-02-28 16:37:25.868775474 +0800
@@ -0,0 +1,17 @@
+  <architecture col="6" row="6">
+    <mesh row-range="0 5" col-range="0 5" 
+          out-north=".out0"
+          out-east=".out1"
+          out-west=".out2"
+          out-south=".out3"
+          in-north=".in0"
+          in-east=".in1"
+          in-west=".in2"
+          in-south=".in3"
+          io="every-side-port"
+          >
+      <interior>
+        <block module="meshblock1">
+      </interior>
+    </diagonal>
+  </architecture>
diff -Nur cgra_me/arch/simple/target_arch/arch-homo-orth_4_4.xml lisa/cgra_me/arch/simple/target_arch/arch-homo-orth_4_4.xml
--- cgra_me/arch/simple/target_arch/arch-homo-orth_4_4.xml	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/arch/simple/target_arch/arch-homo-orth_4_4.xml	2022-02-28 16:37:25.868775474 +0800
@@ -0,0 +1,17 @@
+  <architecture col="6" row="6">
+    <mesh row-range="0 5" col-range="0 5" 
+          out-north=".out0"
+          out-east=".out1"
+          out-west=".out2"
+          out-south=".out3"
+          in-north=".in0"
+          in-east=".in1"
+          in-west=".in2"
+          in-south=".in3"
+          io="every-side-port"
+          >
+      <interior>
+        <block module="meshblock1">
+      </interior>
+    </diagonal>
+  </architecture>
diff -Nur cgra_me/arch/simple/target_arch/arch-homo-orth_5_5_systolic.xml lisa/cgra_me/arch/simple/target_arch/arch-homo-orth_5_5_systolic.xml
--- cgra_me/arch/simple/target_arch/arch-homo-orth_5_5_systolic.xml	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/arch/simple/target_arch/arch-homo-orth_5_5_systolic.xml	2022-02-28 16:37:25.868775474 +0800
@@ -0,0 +1,17 @@
+  <architecture col="8" row="8">
+    <mesh row-range="0 6" col-range="0 6" 
+          out-north=".out0"
+          out-east=".out1"
+          out-west=".out2"
+          out-south=".out3"
+          in-north=".in0"
+          in-east=".in1"
+          in-west=".in2"
+          in-south=".in3"
+          io="every-side-port"
+          >
+      <interior>
+        <block module="meshblock1">
+      </interior>
+    </diagonal>
+  </architecture>
diff -Nur cgra_me/arch/simple/target_arch/arch-homo-orth_6_6.xml lisa/cgra_me/arch/simple/target_arch/arch-homo-orth_6_6.xml
--- cgra_me/arch/simple/target_arch/arch-homo-orth_6_6.xml	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/arch/simple/target_arch/arch-homo-orth_6_6.xml	2022-02-28 16:37:25.868775474 +0800
@@ -0,0 +1,17 @@
+  <architecture col="8" row="8">
+    <mesh row-range="0 7" col-range="0 7" 
+          out-north=".out0"
+          out-east=".out1"
+          out-west=".out2"
+          out-south=".out3"
+          in-north=".in0"
+          in-east=".in1"
+          in-west=".in2"
+          in-south=".in3"
+          io="every-side-port"
+          >
+      <interior>
+        <block module="meshblock1">
+      </interior>
+    </diagonal>
+  </architecture>
diff -Nur cgra_me/arch/simple/target_arch/arch-homo-orth_8_8.xml lisa/cgra_me/arch/simple/target_arch/arch-homo-orth_8_8.xml
--- cgra_me/arch/simple/target_arch/arch-homo-orth_8_8.xml	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/arch/simple/target_arch/arch-homo-orth_8_8.xml	2022-02-28 16:37:25.868775474 +0800
@@ -0,0 +1,17 @@
+  <architecture col="10" row="10">
+    <mesh row-range="0 9" col-range="0 9" 
+          out-north=".out0"
+          out-east=".out1"
+          out-west=".out2"
+          out-south=".out3"
+          in-north=".in0"
+          in-east=".in1"
+          in-west=".in2"
+          in-south=".in3"
+          io="every-side-port"
+          >
+      <interior>
+        <block module="meshblock1">
+      </interior>
+    </diagonal>
+  </architecture>
diff -Nur cgra_me/benchmarks/machsuite/gemm/gemm.c lisa/cgra_me/benchmarks/machsuite/gemm/gemm.c
--- cgra_me/benchmarks/machsuite/gemm/gemm.c	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/machsuite/gemm/gemm.c	2022-02-28 16:37:25.868775474 +0800
@@ -0,0 +1,23 @@
+#include <stdio.h>
+
+volatile int * N;
+volatile int *m1;
+volatile int *m2;
+int *c;
+
+int main() {
+    int i, col_size = 6, i_col , k_col, mult, k, j;
+    int n = *N;
+    m1 [1] = 1;
+    m1[2] = 1;
+
+    int sum = 0;
+    for (k = 1; k < n-1; k++) {
+    //DFGLoop: loop
+        k_col = k * col_size;
+        mult = m1[i_col + k] * m2[k_col + j];
+        sum += mult;
+    }
+
+    return sum;
+}
diff -Nur cgra_me/benchmarks/machsuite/gemm/Makefile lisa/cgra_me/benchmarks/machsuite/gemm/Makefile
--- cgra_me/benchmarks/machsuite/gemm/Makefile	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/machsuite/gemm/Makefile	2022-02-28 16:37:25.868775474 +0800
@@ -0,0 +1 @@
+include ../../rules.mk
diff -Nur cgra_me/benchmarks/machsuite/spmv/Makefile lisa/cgra_me/benchmarks/machsuite/spmv/Makefile
--- cgra_me/benchmarks/machsuite/spmv/Makefile	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/machsuite/spmv/Makefile	2022-02-28 16:37:25.868775474 +0800
@@ -0,0 +1 @@
+include ../../rules.mk
diff -Nur cgra_me/benchmarks/machsuite/spmv/spmv.c lisa/cgra_me/benchmarks/machsuite/spmv/spmv.c
--- cgra_me/benchmarks/machsuite/spmv/spmv.c	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/machsuite/spmv/spmv.c	2022-02-28 16:37:25.868775474 +0800
@@ -0,0 +1,21 @@
+#include <stdio.h>
+
+volatile int * N;
+volatile int *vec;
+volatile int *cols;
+volatile int *nzval;
+int *c;
+
+int main() {
+    int i, j , L, Si;
+    int n = *N;
+
+    int sum = 0;
+    for (j = 1; j < n-1; j++) {
+    //DFGLoop: loop
+      Si = nzval[j + i*L] * vec[cols[j + i*L]];
+        sum += Si;
+    }
+
+    return sum;
+}
diff -Nur cgra_me/benchmarks/machsuite/stencil/Makefile lisa/cgra_me/benchmarks/machsuite/stencil/Makefile
--- cgra_me/benchmarks/machsuite/stencil/Makefile	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/machsuite/stencil/Makefile	2022-02-28 16:37:25.868775474 +0800
@@ -0,0 +1 @@
+include ../../rules.mk
diff -Nur cgra_me/benchmarks/machsuite/stencil/stencil.c lisa/cgra_me/benchmarks/machsuite/stencil/stencil.c
--- cgra_me/benchmarks/machsuite/stencil/stencil.c	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/machsuite/stencil/stencil.c	2022-02-28 16:37:25.868775474 +0800
@@ -0,0 +1,24 @@
+#include <stdio.h>
+
+volatile int * N;
+volatile int *filter;
+volatile int *orig;
+int c;
+
+int main() {
+    orig[1] = 10;
+    int i, mul = 2, k1 , k2 = 6, temp=7, r, col_size=3;
+    int n = *N;
+
+    int sum = 0;
+    k1 = n +1;
+    for (k1 = 0; k1 < 100; k1++){
+        for (k2 = 1; k2 < n-1; k2++) {
+        //DFGLoop: loop
+            mul = filter[k1*3 + k2] * orig[(r+k1)*col_size + c+k2];
+            temp += mul;
+        }
+    }
+
+    return temp;
+}
diff -Nur cgra_me/benchmarks/microbench/accumulate/pre-gen-graph_loop.dot lisa/cgra_me/benchmarks/microbench/accumulate/pre-gen-graph_loop.dot
--- cgra_me/benchmarks/microbench/accumulate/pre-gen-graph_loop.dot	2018-05-09 09:34:57.000000000 +0800
+++ lisa/cgra_me/benchmarks/microbench/accumulate/pre-gen-graph_loop.dot	1970-01-01 07:30:00.000000000 +0730
@@ -1,42 +0,0 @@
-digraph G {
-add0[opcode=add];
-const1[opcode=const];
-mul2[opcode=mul];
-const3[opcode=const];
-load4[opcode=load];
-add5[opcode=add];
-const6[opcode=const];
-mul7[opcode=mul];
-const8[opcode=const];
-load9[opcode=load];
-add10[opcode=add];
-mul11[opcode=mul];
-const12[opcode=const];
-load13[opcode=load];
-mul14[opcode=mul];
-store15[opcode=store];
-add16[opcode=add];
-output17[opcode=output];
-add0->mul2[operand=1]; //add->gep_mul
-add0->add0[operand=0]; //add->add
-add0->add5[operand=0]; //add->add
-add0->mul11[operand=1]; //add->gep_mul
-load4->add10[operand=1]; //load->add
-add5->mul7[operand=1]; //add->gep_mul
-load9->add10[operand=0]; //load->add
-add10->mul14[operand=1]; //add->mul
-load13->mul14[operand=0]; //load->mul
-mul14->store15[operand=0]; //mul->store
-mul14->add16[operand=0]; //mul->add
-add16->output17[operand=0]; //add->output
-add16->add16[operand=1]; //add->add
-const1->add0[operand=1]; //const->add
-const3->mul2[operand=0]; //gep_const->gep_mul
-mul2->load4[operand=0]; //gep_mul->load
-const6->add5[operand=1]; //const->add
-const8->mul7[operand=0]; //gep_const->gep_mul
-mul7->load9[operand=0]; //gep_mul->load
-const12->mul11[operand=0]; //gep_const->gep_mul
-mul11->load13[operand=0]; //gep_mul->load
-mul11->store15[operand=1]; //gep_mul->store
-}
diff -Nur cgra_me/benchmarks/microbench/cap/pre-gen-graph_loop.dot lisa/cgra_me/benchmarks/microbench/cap/pre-gen-graph_loop.dot
--- cgra_me/benchmarks/microbench/cap/pre-gen-graph_loop.dot	2018-05-09 09:34:57.000000000 +0800
+++ lisa/cgra_me/benchmarks/microbench/cap/pre-gen-graph_loop.dot	1970-01-01 07:30:00.000000000 +0730
@@ -1,55 +0,0 @@
-digraph G {
-mul0[opcode=mul];
-const1[opcode=const];
-load2[opcode=load];
-mul3[opcode=mul];
-const4[opcode=const];
-load5[opcode=load];
-const6[opcode=const];
-mul7[opcode=mul];
-shra8[opcode=shra];
-const9[opcode=const];
-mul10[opcode=mul];
-const11[opcode=const];
-load12[opcode=load];
-mul13[opcode=mul];
-shra14[opcode=shra];
-const15[opcode=const];
-mul16[opcode=mul];
-mul17[opcode=mul];
-mul18[opcode=mul];
-mul19[opcode=mul];
-const20[opcode=const];
-store21[opcode=store];
-add22[opcode=add];
-const23[opcode=const];
-load2->mul3[operand=0]; //load->mul
-load2->mul16[operand=1]; //load->mul
-mul3->mul7[operand=0]; //mul->mul
-mul3->mul13[operand=0]; //mul->mul
-load5->mul7[operand=1]; //load->mul
-load5->mul16[operand=0]; //load->mul
-mul7->shra8[operand=0]; //mul->ashr
-shra8->mul17[operand=1]; //ashr->mul
-load12->mul13[operand=1]; //load->mul
-mul13->shra14[operand=0]; //mul->ashr
-shra14->mul18[operand=1]; //ashr->mul
-mul16->mul17[operand=0]; //mul->mul
-mul17->mul18[operand=0]; //mul->mul
-mul18->store21[operand=0]; //mul->store
-add22->mul0[operand=1]; //add->gep_mul
-add22->mul10[operand=1]; //add->gep_mul
-add22->mul19[operand=1]; //add->gep_mul
-add22->add22[operand=0]; //add->add
-const1->mul0[operand=0]; //gep_const->gep_mul
-mul0->load2[operand=0]; //gep_mul->load
-const4->mul3[operand=1]; //const->mul
-const6->load5[operand=0]; //const->load
-const9->shra8[operand=1]; //const->ashr
-const11->mul10[operand=0]; //gep_const->gep_mul
-mul10->load12[operand=0]; //gep_mul->load
-const15->shra14[operand=1]; //const->ashr
-const20->mul19[operand=0]; //gep_const->gep_mul
-mul19->store21[operand=1]; //gep_mul->store
-const23->add22[operand=1]; //const->add
-}
diff -Nur cgra_me/benchmarks/microbench/conv2/pre-gen-graph_loop.dot lisa/cgra_me/benchmarks/microbench/conv2/pre-gen-graph_loop.dot
--- cgra_me/benchmarks/microbench/conv2/pre-gen-graph_loop.dot	2018-05-09 09:34:57.000000000 +0800
+++ lisa/cgra_me/benchmarks/microbench/conv2/pre-gen-graph_loop.dot	1970-01-01 07:30:00.000000000 +0730
@@ -1,36 +0,0 @@
-digraph G {
-mul0[opcode=mul];
-const1[opcode=const];
-load2[opcode=load];
-mul3[opcode=mul];
-const4[opcode=const];
-add5[opcode=add];
-const6[opcode=const];
-mul7[opcode=mul];
-const8[opcode=const];
-load9[opcode=load];
-mul10[opcode=mul];
-const11[opcode=const];
-add12[opcode=add];
-mul13[opcode=mul];
-const14[opcode=const];
-store15[opcode=store];
-load2->mul3[operand=0]; //load->mul
-mul3->add12[operand=1]; //mul->add
-add5->mul7[operand=1]; //add->gep_mul
-add5->mul0[operand=1]; //add->gep_mul
-add5->add5[operand=0]; //add->add
-add5->mul13[operand=1]; //add->gep_mul
-load9->mul10[operand=0]; //load->mul
-mul10->add12[operand=0]; //mul->add
-add12->store15[operand=0]; //add->store
-const1->mul0[operand=0]; //gep_const->gep_mul
-mul0->load2[operand=0]; //gep_mul->load
-const4->mul3[operand=1]; //const->mul
-const6->add5[operand=1]; //const->add
-const8->mul7[operand=0]; //gep_const->gep_mul
-mul7->load9[operand=0]; //gep_mul->load
-const11->mul10[operand=1]; //const->mul
-const14->mul13[operand=0]; //gep_const->gep_mul
-mul13->store15[operand=1]; //gep_mul->store
-}
diff -Nur cgra_me/benchmarks/microbench/conv3/pre-gen-graph_loop.dot lisa/cgra_me/benchmarks/microbench/conv3/pre-gen-graph_loop.dot
--- cgra_me/benchmarks/microbench/conv3/pre-gen-graph_loop.dot	2018-05-09 09:34:57.000000000 +0800
+++ lisa/cgra_me/benchmarks/microbench/conv3/pre-gen-graph_loop.dot	1970-01-01 07:30:00.000000000 +0730
@@ -1,53 +0,0 @@
-digraph G {
-mul0[opcode=mul];
-const1[opcode=const];
-load2[opcode=load];
-mul3[opcode=mul];
-const4[opcode=const];
-add5[opcode=add];
-const6[opcode=const];
-mul7[opcode=mul];
-const8[opcode=const];
-load9[opcode=load];
-mul10[opcode=mul];
-const11[opcode=const];
-add12[opcode=add];
-add13[opcode=add];
-const14[opcode=const];
-mul15[opcode=mul];
-const16[opcode=const];
-load17[opcode=load];
-mul18[opcode=mul];
-const19[opcode=const];
-add20[opcode=add];
-mul21[opcode=mul];
-const22[opcode=const];
-store23[opcode=store];
-load2->mul3[operand=0]; //load->mul
-mul3->add12[operand=1]; //mul->add
-add5->mul7[operand=1]; //add->gep_mul
-add5->mul0[operand=1]; //add->gep_mul
-add5->add5[operand=0]; //add->add
-add5->add13[operand=0]; //add->add
-add5->mul21[operand=1]; //add->gep_mul
-load9->mul10[operand=0]; //load->mul
-mul10->add12[operand=0]; //mul->add
-add12->add20[operand=0]; //add->add
-add13->mul15[operand=1]; //add->gep_mul
-load17->mul18[operand=0]; //load->mul
-mul18->add20[operand=1]; //mul->add
-add20->store23[operand=0]; //add->store
-const1->mul0[operand=0]; //gep_const->gep_mul
-mul0->load2[operand=0]; //gep_mul->load
-const4->mul3[operand=1]; //const->mul
-const6->add5[operand=1]; //const->add
-const8->mul7[operand=0]; //gep_const->gep_mul
-mul7->load9[operand=0]; //gep_mul->load
-const11->mul10[operand=1]; //const->mul
-const14->add13[operand=1]; //const->add
-const16->mul15[operand=0]; //gep_const->gep_mul
-mul15->load17[operand=0]; //gep_mul->load
-const19->mul18[operand=1]; //const->mul
-const22->mul21[operand=0]; //gep_const->gep_mul
-mul21->store23[operand=1]; //gep_mul->store
-}
diff -Nur cgra_me/benchmarks/microbench/mac/pre-gen-graph_loop.dot lisa/cgra_me/benchmarks/microbench/mac/pre-gen-graph_loop.dot
--- cgra_me/benchmarks/microbench/mac/pre-gen-graph_loop.dot	2018-05-09 09:34:57.000000000 +0800
+++ lisa/cgra_me/benchmarks/microbench/mac/pre-gen-graph_loop.dot	1970-01-01 07:30:00.000000000 +0730
@@ -1,26 +0,0 @@
-digraph G {
-mul0[opcode=mul];
-const1[opcode=const];
-load2[opcode=load];
-mul3[opcode=mul];
-const4[opcode=const];
-load5[opcode=load];
-mul6[opcode=mul];
-add7[opcode=add];
-output8[opcode=output];
-add9[opcode=add];
-const10[opcode=const];
-load2->mul6[operand=1]; //load->mul
-load5->mul6[operand=0]; //load->mul
-mul6->add7[operand=0]; //mul->add
-add7->output8[operand=0]; //add->output
-add7->add7[operand=1]; //add->add
-add9->mul0[operand=1]; //add->gep_mul
-add9->mul3[operand=1]; //add->gep_mul
-add9->add9[operand=0]; //add->add
-const1->mul0[operand=0]; //gep_const->gep_mul
-mul0->load2[operand=0]; //gep_mul->load
-const4->mul3[operand=0]; //gep_const->gep_mul
-mul3->load5[operand=0]; //gep_mul->load
-const10->add9[operand=1]; //const->add
-}
diff -Nur cgra_me/benchmarks/microbench/mac2/pre-gen-graph_loop.dot lisa/cgra_me/benchmarks/microbench/mac2/pre-gen-graph_loop.dot
--- cgra_me/benchmarks/microbench/mac2/pre-gen-graph_loop.dot	2018-05-09 09:34:57.000000000 +0800
+++ lisa/cgra_me/benchmarks/microbench/mac2/pre-gen-graph_loop.dot	1970-01-01 07:30:00.000000000 +0730
@@ -1,56 +0,0 @@
-digraph G {
-mul0[opcode=mul];
-const1[opcode=const];
-load2[opcode=load];
-mul3[opcode=mul];
-const4[opcode=const];
-load5[opcode=load];
-mul6[opcode=mul];
-add7[opcode=add];
-output8[opcode=output];
-add9[opcode=add];
-const10[opcode=const];
-mul11[opcode=mul];
-mul12[opcode=mul];
-const13[opcode=const];
-load14[opcode=load];
-mul15[opcode=mul];
-mul16[opcode=mul];
-const17[opcode=const];
-load18[opcode=load];
-mul19[opcode=mul];
-add20[opcode=add];
-output21[opcode=output];
-add22[opcode=add];
-const23[opcode=const];
-load2->mul6[operand=1]; //load->mul
-load2->mul11[operand=1]; //load->mul
-load5->mul6[operand=0]; //load->mul
-load5->add9[operand=0]; //load->add
-mul6->add7[operand=0]; //mul->add
-add7->output8[operand=0]; //add->output
-add7->add7[operand=1]; //add->add
-add9->mul11[operand=0]; //add->mul
-mul11->mul15[operand=0]; //mul->mul
-load14->mul15[operand=1]; //load->mul
-mul15->mul19[operand=0]; //mul->mul
-load18->mul19[operand=1]; //load->mul
-mul19->add20[operand=0]; //mul->add
-add20->output21[operand=0]; //add->output
-add20->add20[operand=1]; //add->add
-add22->mul0[operand=1]; //add->gep_mul
-add22->mul3[operand=1]; //add->gep_mul
-add22->mul12[operand=1]; //add->gep_mul
-add22->mul16[operand=1]; //add->gep_mul
-add22->add22[operand=0]; //add->add
-const1->mul0[operand=0]; //gep_const->gep_mul
-mul0->load2[operand=0]; //gep_mul->load
-const4->mul3[operand=0]; //gep_const->gep_mul
-mul3->load5[operand=0]; //gep_mul->load
-const10->add9[operand=1]; //const->add
-const13->mul12[operand=0]; //gep_const->gep_mul
-mul12->load14[operand=0]; //gep_mul->load
-const17->mul16[operand=0]; //gep_const->gep_mul
-mul16->load18[operand=0]; //gep_mul->load
-const23->add22[operand=1]; //const->add
-}
diff -Nur cgra_me/benchmarks/microbench/matrixmultiply/pre-gen-graph_loop.dot lisa/cgra_me/benchmarks/microbench/matrixmultiply/pre-gen-graph_loop.dot
--- cgra_me/benchmarks/microbench/matrixmultiply/pre-gen-graph_loop.dot	2018-05-09 09:34:57.000000000 +0800
+++ lisa/cgra_me/benchmarks/microbench/matrixmultiply/pre-gen-graph_loop.dot	1970-01-01 07:30:00.000000000 +0730
@@ -1,38 +0,0 @@
-digraph G {
-mul0[opcode=mul];
-const1[opcode=const];
-mul2[opcode=mul];
-const3[opcode=const];
-add4[opcode=add];
-load5[opcode=load];
-mul6[opcode=mul];
-const7[opcode=const];
-mul8[opcode=mul];
-const9[opcode=const];
-add10[opcode=add];
-load11[opcode=load];
-mul12[opcode=mul];
-add13[opcode=add];
-output14[opcode=output];
-add15[opcode=add];
-const16[opcode=const];
-load5->mul12[operand=1]; //load->mul
-load11->mul12[operand=0]; //load->mul
-mul12->add13[operand=0]; //mul->add
-add13->output14[operand=0]; //add->output
-add13->add13[operand=1]; //add->add
-add15->mul2[operand=1]; //add->gep_mul
-add15->mul6[operand=1]; //add->gep_mul
-add15->add15[operand=0]; //add->add
-const1->mul0[operand=0]; //gep_const->gep_mul
-const3->mul2[operand=0]; //gep_const->gep_mul
-mul0->add4[operand=0]; //gep_mul->gep_add
-mul2->add4[operand=1]; //gep_mul->gep_add
-add4->load5[operand=0]; //gep_add->load
-const7->mul6[operand=0]; //gep_const->gep_mul
-const9->mul8[operand=0]; //gep_const->gep_mul
-mul6->add10[operand=0]; //gep_mul->gep_add
-mul8->add10[operand=1]; //gep_mul->gep_add
-add10->load11[operand=0]; //gep_add->load
-const16->add15[operand=1]; //const->add
-}
Binary files cgra_me/benchmarks/microbench/matrixmultiply/pre-gen-graph_loop.pdf and lisa/cgra_me/benchmarks/microbench/matrixmultiply/pre-gen-graph_loop.pdf differ
diff -Nur cgra_me/benchmarks/microbench/matrixmultiply2/Makefile lisa/cgra_me/benchmarks/microbench/matrixmultiply2/Makefile
--- cgra_me/benchmarks/microbench/matrixmultiply2/Makefile	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/microbench/matrixmultiply2/Makefile	2022-02-28 16:37:25.872775483 +0800
@@ -0,0 +1 @@
+include ../../rules.mk
diff -Nur cgra_me/benchmarks/microbench/matrixmultiply2/matrixmultiply.c lisa/cgra_me/benchmarks/microbench/matrixmultiply2/matrixmultiply.c
--- cgra_me/benchmarks/microbench/matrixmultiply2/matrixmultiply.c	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/microbench/matrixmultiply2/matrixmultiply.c	2022-02-28 16:37:25.872775483 +0800
@@ -0,0 +1,45 @@
+// matrix multiply
+// Author: Andrew Canis
+// Date: June 13, 2012
+
+#include <stdio.h>
+
+// matrices are SIZE x SIZE
+#define SIZE 20
+
+volatile int A1[SIZE][SIZE] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399};
+volatile int B1[SIZE][SIZE] = {400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799};
+
+volatile int resultAB1[SIZE][SIZE];
+
+__attribute__((noinline)) int multiply(int i, int j) {
+    int k, sum = 0;
+    for(k = 0; k < SIZE; k++) {
+    //DFGLoop: loop
+        sum += A1[i][k] * B1[k][j];
+    }
+    resultAB1[i][j] = sum;
+    return sum;
+}
+
+int main(void) {
+    int i, j;
+    
+    unsigned long long count = 0;
+    for(i = 0; i < SIZE; i++) {
+        for(j = 0; j < SIZE; j++) {
+            count += multiply(i, j);
+        }
+    }
+
+    printf ("Result: %lld\n", count);
+    if (count == 962122000) {
+        printf("RESULT: PASS\n");
+    } else {
+        printf("RESULT: FAIL\n");
+    }
+    return count;
+
+}
+
+
Binary files cgra_me/benchmarks/microbench/matrixmultiply2/pre-gen-graph_loop.pdf and lisa/cgra_me/benchmarks/microbench/matrixmultiply2/pre-gen-graph_loop.pdf differ
diff -Nur cgra_me/benchmarks/microbench/mults1/pre-gen-graph_loop.dot lisa/cgra_me/benchmarks/microbench/mults1/pre-gen-graph_loop.dot
--- cgra_me/benchmarks/microbench/mults1/pre-gen-graph_loop.dot	2018-05-09 09:34:57.000000000 +0800
+++ lisa/cgra_me/benchmarks/microbench/mults1/pre-gen-graph_loop.dot	1970-01-01 07:30:00.000000000 +0730
@@ -1,68 +0,0 @@
-digraph G {
-mul0[opcode=mul];
-const1[opcode=const];
-load2[opcode=load];
-mul3[opcode=mul];
-const4[opcode=const];
-add5[opcode=add];
-const6[opcode=const];
-mul7[opcode=mul];
-const8[opcode=const];
-load9[opcode=load];
-mul10[opcode=mul];
-const11[opcode=const];
-add12[opcode=add];
-const13[opcode=const];
-mul14[opcode=mul];
-const15[opcode=const];
-load16[opcode=load];
-mul17[opcode=mul];
-const18[opcode=const];
-add19[opcode=add];
-const20[opcode=const];
-mul21[opcode=mul];
-const22[opcode=const];
-load23[opcode=load];
-mul24[opcode=mul];
-const25[opcode=const];
-add26[opcode=add];
-add27[opcode=add];
-add28[opcode=add];
-add29[opcode=add];
-output30[opcode=output];
-load2->mul3[operand=0]; //load->mul
-mul3->add26[operand=0]; //mul->add
-add5->mul7[operand=1]; //add->gep_mul
-add5->mul0[operand=1]; //add->gep_mul
-add5->add5[operand=0]; //add->add
-add5->add12[operand=0]; //add->add
-add5->add19[operand=0]; //add->add
-load9->mul10[operand=0]; //load->mul
-mul10->add27[operand=1]; //mul->add
-add12->mul14[operand=1]; //add->gep_mul
-load16->mul17[operand=0]; //load->mul
-mul17->add28[operand=1]; //mul->add
-add19->mul21[operand=1]; //add->gep_mul
-load23->mul24[operand=0]; //load->mul
-mul24->add29[operand=1]; //mul->add
-add26->add27[operand=0]; //add->add
-add27->add28[operand=0]; //add->add
-add28->add29[operand=0]; //add->add
-add29->output30[operand=0]; //add->output
-add29->add26[operand=1]; //add->add
-const1->mul0[operand=0]; //gep_const->gep_mul
-mul0->load2[operand=0]; //gep_mul->load
-const4->mul3[operand=1]; //const->mul
-const6->add5[operand=1]; //const->add
-const8->mul7[operand=0]; //gep_const->gep_mul
-mul7->load9[operand=0]; //gep_mul->load
-const11->mul10[operand=1]; //const->mul
-const13->add12[operand=1]; //const->add
-const15->mul14[operand=0]; //gep_const->gep_mul
-mul14->load16[operand=0]; //gep_mul->load
-const18->mul17[operand=1]; //const->mul
-const20->add19[operand=1]; //const->add
-const22->mul21[operand=0]; //gep_const->gep_mul
-mul21->load23[operand=0]; //gep_mul->load
-const25->mul24[operand=1]; //const->mul
-}
diff -Nur cgra_me/benchmarks/microbench/mults2/pre-gen-graph_loop.dot lisa/cgra_me/benchmarks/microbench/mults2/pre-gen-graph_loop.dot
--- cgra_me/benchmarks/microbench/mults2/pre-gen-graph_loop.dot	2018-05-09 09:34:57.000000000 +0800
+++ lisa/cgra_me/benchmarks/microbench/mults2/pre-gen-graph_loop.dot	1970-01-01 07:30:00.000000000 +0730
@@ -1,58 +0,0 @@
-digraph G {
-mul0[opcode=mul];
-const1[opcode=const];
-load2[opcode=load];
-add3[opcode=add];
-const4[opcode=const];
-mul5[opcode=mul];
-const6[opcode=const];
-load7[opcode=load];
-add8[opcode=add];
-mul9[opcode=mul];
-const10[opcode=const];
-load11[opcode=load];
-add12[opcode=add];
-const13[opcode=const];
-mul14[opcode=mul];
-const15[opcode=const];
-load16[opcode=load];
-add17[opcode=add];
-mul18[opcode=mul];
-const19[opcode=const];
-mul20[opcode=mul];
-mul21[opcode=mul];
-mul22[opcode=mul];
-add23[opcode=add];
-output24[opcode=output];
-load2->add8[operand=1]; //load->add
-add3->mul5[operand=1]; //add->gep_mul
-add3->mul0[operand=1]; //add->gep_mul
-add3->add3[operand=0]; //add->add
-add3->mul9[operand=1]; //add->gep_mul
-add3->add12[operand=0]; //add->add
-load7->add8[operand=0]; //load->add
-add8->mul18[operand=0]; //add->mul
-load11->add17[operand=1]; //load->add
-load11->mul20[operand=1]; //load->mul
-add12->mul14[operand=1]; //add->gep_mul
-load16->add17[operand=0]; //load->add
-load16->mul21[operand=1]; //load->mul
-add17->mul22[operand=1]; //add->mul
-mul18->mul20[operand=0]; //mul->mul
-mul20->mul21[operand=0]; //mul->mul
-mul21->mul22[operand=0]; //mul->mul
-mul22->add23[operand=0]; //mul->add
-add23->output24[operand=0]; //add->output
-add23->add23[operand=1]; //add->add
-const1->mul0[operand=0]; //gep_const->gep_mul
-mul0->load2[operand=0]; //gep_mul->load
-const4->add3[operand=1]; //const->add
-const6->mul5[operand=0]; //gep_const->gep_mul
-mul5->load7[operand=0]; //gep_mul->load
-const10->mul9[operand=0]; //gep_const->gep_mul
-mul9->load11[operand=0]; //gep_mul->load
-const13->add12[operand=1]; //const->add
-const15->mul14[operand=0]; //gep_const->gep_mul
-mul14->load16[operand=0]; //gep_mul->load
-const19->mul18[operand=1]; //const->mul
-}
diff -Nur cgra_me/benchmarks/microbench/nomem1/pre-gen-graph_loop.dot lisa/cgra_me/benchmarks/microbench/nomem1/pre-gen-graph_loop.dot
--- cgra_me/benchmarks/microbench/nomem1/pre-gen-graph_loop.dot	2018-05-09 09:34:57.000000000 +0800
+++ lisa/cgra_me/benchmarks/microbench/nomem1/pre-gen-graph_loop.dot	1970-01-01 07:30:00.000000000 +0730
@@ -1,15 +0,0 @@
-digraph G {
-mul0[opcode=mul];
-const1[opcode=const];
-add2[opcode=add];
-output3[opcode=output];
-add4[opcode=add];
-const5[opcode=const];
-mul0->add2[operand=0]; //mul->add
-add2->output3[operand=0]; //add->output
-add2->add2[operand=1]; //add->add
-add4->mul0[operand=0]; //add->mul
-add4->add4[operand=0]; //add->add
-const1->mul0[operand=1]; //const->mul
-const5->add4[operand=1]; //const->add
-}
diff -Nur cgra_me/benchmarks/microbench/simple/pre-gen-graph_loop.dot lisa/cgra_me/benchmarks/microbench/simple/pre-gen-graph_loop.dot
--- cgra_me/benchmarks/microbench/simple/pre-gen-graph_loop.dot	2018-05-09 09:34:57.000000000 +0800
+++ lisa/cgra_me/benchmarks/microbench/simple/pre-gen-graph_loop.dot	1970-01-01 07:30:00.000000000 +0730
@@ -1,28 +0,0 @@
-digraph G {
-mul0[opcode=mul];
-const1[opcode=const];
-load2[opcode=load];
-mul3[opcode=mul];
-const4[opcode=const];
-load5[opcode=load];
-add6[opcode=add];
-mul7[opcode=mul];
-const8[opcode=const];
-store9[opcode=store];
-add10[opcode=add];
-const11[opcode=const];
-load2->add6[operand=1]; //load->add
-load5->add6[operand=0]; //load->add
-add6->store9[operand=0]; //add->store
-add10->mul0[operand=1]; //add->gep_mul
-add10->mul3[operand=1]; //add->gep_mul
-add10->mul7[operand=1]; //add->gep_mul
-add10->add10[operand=0]; //add->add
-const1->mul0[operand=0]; //gep_const->gep_mul
-mul0->load2[operand=0]; //gep_mul->load
-const4->mul3[operand=0]; //gep_const->gep_mul
-mul3->load5[operand=0]; //gep_mul->load
-const8->mul7[operand=0]; //gep_const->gep_mul
-mul7->store9[operand=1]; //gep_mul->store
-const11->add10[operand=1]; //const->add
-}
diff -Nur cgra_me/benchmarks/microbench/simple2/pre-gen-graph_loop.dot lisa/cgra_me/benchmarks/microbench/simple2/pre-gen-graph_loop.dot
--- cgra_me/benchmarks/microbench/simple2/pre-gen-graph_loop.dot	2018-05-09 09:34:57.000000000 +0800
+++ lisa/cgra_me/benchmarks/microbench/simple2/pre-gen-graph_loop.dot	1970-01-01 07:30:00.000000000 +0730
@@ -1,28 +0,0 @@
-digraph G {
-mul0[opcode=mul];
-const1[opcode=const];
-load2[opcode=load];
-mul3[opcode=mul];
-const4[opcode=const];
-load5[opcode=load];
-mul6[opcode=mul];
-mul7[opcode=mul];
-const8[opcode=const];
-store9[opcode=store];
-add10[opcode=add];
-const11[opcode=const];
-load2->mul6[operand=1]; //load->mul
-load5->mul6[operand=0]; //load->mul
-mul6->store9[operand=0]; //mul->store
-add10->mul0[operand=1]; //add->gep_mul
-add10->mul3[operand=1]; //add->gep_mul
-add10->mul7[operand=1]; //add->gep_mul
-add10->add10[operand=0]; //add->add
-const1->mul0[operand=0]; //gep_const->gep_mul
-mul0->load2[operand=0]; //gep_mul->load
-const4->mul3[operand=0]; //gep_const->gep_mul
-mul3->load5[operand=0]; //gep_mul->load
-const8->mul7[operand=0]; //gep_const->gep_mul
-mul7->store9[operand=1]; //gep_mul->store
-const11->add10[operand=1]; //const->add
-}
diff -Nur cgra_me/benchmarks/microbench/sum/pre-gen-graph_loop.dot lisa/cgra_me/benchmarks/microbench/sum/pre-gen-graph_loop.dot
--- cgra_me/benchmarks/microbench/sum/pre-gen-graph_loop.dot	2018-05-09 09:34:57.000000000 +0800
+++ lisa/cgra_me/benchmarks/microbench/sum/pre-gen-graph_loop.dot	1970-01-01 07:30:00.000000000 +0730
@@ -1,17 +0,0 @@
-digraph G {
-mul0[opcode=mul];
-const1[opcode=const];
-load2[opcode=load];
-add3[opcode=add];
-output4[opcode=output];
-add5[opcode=add];
-const6[opcode=const];
-load2->add3[operand=0]; //load->add
-add3->output4[operand=0]; //add->output
-add3->add3[operand=1]; //add->add
-add5->mul0[operand=1]; //add->gep_mul
-add5->add5[operand=0]; //add->add
-const1->mul0[operand=0]; //gep_const->gep_mul
-mul0->load2[operand=0]; //gep_mul->load
-const6->add5[operand=1]; //const->add
-}
diff -Nur cgra_me/benchmarks/polybench/2mm/2mm.c lisa/cgra_me/benchmarks/polybench/2mm/2mm.c
--- cgra_me/benchmarks/polybench/2mm/2mm.c	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/2mm/2mm.c	2022-02-28 16:37:25.872775483 +0800
@@ -0,0 +1,36 @@
+#include <stdio.h>
+
+volatile int * N;
+volatile int *a;
+volatile int *b;
+int *c;
+int **tmp;
+volatile int **A;
+volatile int **B;
+
+int main() {
+    int i;
+    int j;
+    int k;
+    int alpha = 10;
+    int n = *N;
+
+    int sum = 0;
+
+ 
+    for (k = 1; k < n-1; ++k){
+        //DFGLoop: loop
+        sum += alpha * A[i][k] * B[k][j];
+
+        sum += A[i][k];
+    }
+
+    // for (i = 1; i < n-1; i++) {
+    
+    //     c[i] *= a[i+1] + b[i-1];
+    //     sum += c[i];
+    // }
+
+
+    return sum;
+}
diff -Nur cgra_me/benchmarks/polybench/2mm/Makefile lisa/cgra_me/benchmarks/polybench/2mm/Makefile
--- cgra_me/benchmarks/polybench/2mm/Makefile	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/2mm/Makefile	2022-02-28 16:37:25.872775483 +0800
@@ -0,0 +1 @@
+include ../../rules.mk
diff -Nur cgra_me/benchmarks/polybench/2mm/my_graph_loop.dot lisa/cgra_me/benchmarks/polybench/2mm/my_graph_loop.dot
--- cgra_me/benchmarks/polybench/2mm/my_graph_loop.dot	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/2mm/my_graph_loop.dot	2022-02-28 16:37:25.872775483 +0800
@@ -0,0 +1,36 @@
+digraph G {
+mul0[opcode=mul];
+const1[opcode=const];
+load2[opcode=load];
+mul3[opcode=mul];
+const4[opcode=const];
+mul5[opcode=mul];
+const6[opcode=const];
+load7[opcode=load];
+load8[opcode=load];
+mul9[opcode=mul];
+add10[opcode=add];
+load11[opcode=load];
+add12[opcode=add];
+output13[opcode=output];
+add14[opcode=add];
+const15[opcode=const];
+load2->mul3[operand=0]; //load->mul
+mul3->mul9[operand=0]; //mul->mul
+load7->load8[operand=0]; //load->load
+load8->mul9[operand=1]; //load->mul
+mul9->add10[operand=0]; //mul->add
+add10->add12[operand=0]; //add->add
+load11->add12[operand=1]; //load->add
+add12->output13[operand=0]; //add->output
+add12->add10[operand=1]; //add->add
+add14->mul0[operand=1]; //add->gep_mul
+add14->mul5[operand=1]; //add->gep_mul
+const1->mul0[operand=0]; //gep_const->gep_mul
+mul0->load2[operand=0]; //gep_mul->load
+mul0->load11[operand=0]; //gep_mul->load
+const4->mul3[operand=1]; //const->mul
+const6->mul5[operand=0]; //gep_const->gep_mul
+mul5->load7[operand=0]; //gep_mul->load
+const15->add14[operand=1]; //const->add
+}
diff -Nur cgra_me/benchmarks/polybench/2mm_unroll/2mm.c lisa/cgra_me/benchmarks/polybench/2mm_unroll/2mm.c
--- cgra_me/benchmarks/polybench/2mm_unroll/2mm.c	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/2mm_unroll/2mm.c	2022-02-28 16:37:25.872775483 +0800
@@ -0,0 +1,37 @@
+#include <stdio.h>
+
+volatile int * N;
+volatile int *a;
+volatile int *b;
+int *c;
+int **tmp;
+volatile int **A;
+volatile int **B;
+
+int main() {
+    int i;
+    int j;
+    int k;
+    int alpha = 10;
+    int n = *N;
+
+    int sum = 0;
+
+ 
+    for (k = 1; k < n-1; ++k){
+        //DFGLoop: loop
+        sum += alpha * A[i][k] * B[k][j];
+        sum += alpha * A[i][k+1] * B[k+1][j];
+
+        sum += A[i][k+1];
+    }
+
+    // for (i = 1; i < n-1; i++) {
+    
+    //     c[i] *= a[i+1] + b[i-1];
+    //     sum += c[i];
+    // }
+
+
+    return sum;
+}
diff -Nur cgra_me/benchmarks/polybench/2mm_unroll/Makefile lisa/cgra_me/benchmarks/polybench/2mm_unroll/Makefile
--- cgra_me/benchmarks/polybench/2mm_unroll/Makefile	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/2mm_unroll/Makefile	2022-02-28 16:37:25.872775483 +0800
@@ -0,0 +1 @@
+include ../../rules.mk
diff -Nur cgra_me/benchmarks/polybench/2mm_unroll/my_graph_loop.dot lisa/cgra_me/benchmarks/polybench/2mm_unroll/my_graph_loop.dot
--- cgra_me/benchmarks/polybench/2mm_unroll/my_graph_loop.dot	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/2mm_unroll/my_graph_loop.dot	2022-02-28 16:37:25.872775483 +0800
@@ -0,0 +1,56 @@
+digraph G {
+mul0[opcode=mul];
+const1[opcode=const];
+load2[opcode=load];
+mul3[opcode=mul];
+const4[opcode=const];
+load5[opcode=load];
+load6[opcode=load];
+mul7[opcode=mul];
+add8[opcode=add];
+const9[opcode=const];
+mul10[opcode=mul];
+const11[opcode=const];
+load12[opcode=load];
+mul13[opcode=mul];
+const14[opcode=const];
+load15[opcode=load];
+load16[opcode=load];
+mul17[opcode=mul];
+load18[opcode=load];
+add19[opcode=add];
+mul20[opcode=mul];
+const21[opcode=const];
+add22[opcode=add];
+add23[opcode=add];
+output24[opcode=output];
+load2->mul7[operand=1]; //load->mul
+load5->load6[operand=0]; //load->load
+load6->mul7[operand=0]; //load->mul
+mul7->add19[operand=1]; //mul->add
+add8->mul10[operand=1]; //add->gep_mul
+add8->mul13[operand=1]; //add->gep_mul
+add8->mul0[operand=1]; //add->gep_mul
+add8->mul3[operand=1]; //add->gep_mul
+load12->mul17[operand=1]; //load->mul
+load15->load16[operand=0]; //load->load
+load16->mul17[operand=0]; //load->mul
+mul17->add19[operand=0]; //mul->add
+load18->add22[operand=0]; //load->add
+add19->mul20[operand=0]; //add->mul
+mul20->add23[operand=1]; //mul->add
+add22->add23[operand=0]; //add->add
+add23->output24[operand=0]; //add->output
+add23->add22[operand=1]; //add->add
+const1->mul0[operand=0]; //gep_const->gep_mul
+mul0->load2[operand=0]; //gep_mul->load
+const4->mul3[operand=0]; //gep_const->gep_mul
+mul3->load5[operand=0]; //gep_mul->load
+const9->add8[operand=1]; //const->add
+const11->mul10[operand=0]; //gep_const->gep_mul
+mul10->load12[operand=0]; //gep_mul->load
+mul10->load18[operand=0]; //gep_mul->load
+const14->mul13[operand=0]; //gep_const->gep_mul
+mul13->load15[operand=0]; //gep_mul->load
+const21->mul20[operand=1]; //const->mul
+}
diff -Nur cgra_me/benchmarks/polybench/atax/atax.c lisa/cgra_me/benchmarks/polybench/atax/atax.c
--- cgra_me/benchmarks/polybench/atax/atax.c	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/atax/atax.c	2022-02-28 16:37:25.872775483 +0800
@@ -0,0 +1,34 @@
+#include <stdio.h>
+
+volatile int * N;
+volatile int **A;
+volatile int *y;
+volatile int *tmp;
+int *c;
+
+int main() {
+    int i;
+    int j;
+    int n = *N;
+
+    int sum = 0;
+    for (j = 1; j < n-1; j++) {
+    //DFGLoop: loop
+        y[j] = y[j] + A[i][j] * tmp[i];
+    }
+
+//     #pragma scop
+//   for (i = 0; i < _PB_NY; i++)
+//     y[i] = 0;
+//   for (i = 0; i < _PB_NX; i++)
+//     {
+//       tmp[i] = 0;
+//       for (j = 0; j < _PB_NY; j++)
+// 	tmp[i] = tmp[i] + A[i][j] * x[j];
+//       for (j = 0; j < _PB_NY; j++)
+// 	y[j] = y[j] + A[i][j] * tmp[i];
+//     }
+// #pragma endscop
+
+    return sum;
+}
diff -Nur cgra_me/benchmarks/polybench/atax/Makefile lisa/cgra_me/benchmarks/polybench/atax/Makefile
--- cgra_me/benchmarks/polybench/atax/Makefile	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/atax/Makefile	2022-02-28 16:37:25.872775483 +0800
@@ -0,0 +1 @@
+include ../../rules.mk
diff -Nur cgra_me/benchmarks/polybench/atax/my_graph_loop.dot lisa/cgra_me/benchmarks/polybench/atax/my_graph_loop.dot
--- cgra_me/benchmarks/polybench/atax/my_graph_loop.dot	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/atax/my_graph_loop.dot	2022-02-28 16:37:25.872775483 +0800
@@ -0,0 +1,31 @@
+digraph G {
+mul0[opcode=mul];
+const1[opcode=const];
+load2[opcode=load];
+mul3[opcode=mul];
+const4[opcode=const];
+load5[opcode=load];
+load6[opcode=load];
+const7[opcode=const];
+load8[opcode=load];
+mul9[opcode=mul];
+add10[opcode=add];
+store11[opcode=store];
+add12[opcode=add];
+const13[opcode=const];
+load2->add10[operand=1]; //load->add
+load5->mul9[operand=1]; //load->mul
+load6->load8[operand=0]; //load->load
+load8->mul9[operand=0]; //load->mul
+mul9->add10[operand=0]; //mul->add
+add10->store11[operand=0]; //add->store
+add12->mul0[operand=1]; //add->gep_mul
+add12->mul3[operand=1]; //add->gep_mul
+const1->mul0[operand=0]; //gep_const->gep_mul
+mul0->load2[operand=0]; //gep_mul->load
+mul0->store11[operand=1]; //gep_mul->store
+const4->mul3[operand=0]; //gep_const->gep_mul
+mul3->load5[operand=0]; //gep_mul->load
+const7->load6[operand=0]; //const->load
+const13->add12[operand=1]; //const->add
+}
diff -Nur cgra_me/benchmarks/polybench/atax_unroll/atax.c lisa/cgra_me/benchmarks/polybench/atax_unroll/atax.c
--- cgra_me/benchmarks/polybench/atax_unroll/atax.c	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/atax_unroll/atax.c	2022-02-28 16:37:25.872775483 +0800
@@ -0,0 +1,35 @@
+#include <stdio.h>
+
+volatile int * N;
+volatile int **A;
+volatile int *y;
+volatile int *tmp;
+int *c;
+
+int main() {
+    int i;
+    int j;
+    int n = *N;
+
+    int sum = 0;
+    for (j = 1; j < n-1; j++) {
+    //DFGLoop: loop
+        y[j] = y[j] + A[i][j] * tmp[i];
+        y[j+1] = y[j+1] + A[i][j+1] * tmp[i];
+    }
+
+//     #pragma scop
+//   for (i = 0; i < _PB_NY; i++)
+//     y[i] = 0;
+//   for (i = 0; i < _PB_NX; i++)
+//     {
+//       tmp[i] = 0;
+//       for (j = 0; j < _PB_NY; j++)
+// 	tmp[i] = tmp[i] + A[i][j] * x[j];
+//       for (j = 0; j < _PB_NY; j++)
+// 	y[j] = y[j] + A[i][j] * tmp[i];
+//     }
+// #pragma endscop
+
+    return sum;
+}
diff -Nur cgra_me/benchmarks/polybench/atax_unroll/Makefile lisa/cgra_me/benchmarks/polybench/atax_unroll/Makefile
--- cgra_me/benchmarks/polybench/atax_unroll/Makefile	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/atax_unroll/Makefile	2022-02-28 16:37:25.872775483 +0800
@@ -0,0 +1 @@
+include ../../rules.mk
diff -Nur cgra_me/benchmarks/polybench/atax_unroll/my_graph_loop.dot lisa/cgra_me/benchmarks/polybench/atax_unroll/my_graph_loop.dot
--- cgra_me/benchmarks/polybench/atax_unroll/my_graph_loop.dot	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/atax_unroll/my_graph_loop.dot	2022-02-28 16:37:25.872775483 +0800
@@ -0,0 +1,54 @@
+digraph G {
+mul0[opcode=mul];
+const1[opcode=const];
+load2[opcode=load];
+mul3[opcode=mul];
+const4[opcode=const];
+load5[opcode=load];
+load6[opcode=load];
+const7[opcode=const];
+load8[opcode=load];
+mul9[opcode=mul];
+add10[opcode=add];
+store11[opcode=store];
+add12[opcode=add];
+const13[opcode=const];
+mul14[opcode=mul];
+const15[opcode=const];
+load16[opcode=load];
+mul17[opcode=mul];
+const18[opcode=const];
+load19[opcode=load];
+load20[opcode=load];
+mul21[opcode=mul];
+add22[opcode=add];
+store23[opcode=store];
+load2->add10[operand=1]; //load->add
+load5->mul9[operand=1]; //load->mul
+load6->load8[operand=0]; //load->load
+load6->load20[operand=0]; //load->load
+load8->mul9[operand=0]; //load->mul
+mul9->add10[operand=0]; //mul->add
+add10->store11[operand=0]; //add->store
+add12->mul14[operand=1]; //add->gep_mul
+add12->mul17[operand=1]; //add->gep_mul
+add12->mul0[operand=1]; //add->gep_mul
+add12->mul3[operand=1]; //add->gep_mul
+load16->add22[operand=1]; //load->add
+load19->mul21[operand=1]; //load->mul
+load20->mul21[operand=0]; //load->mul
+mul21->add22[operand=0]; //mul->add
+add22->store23[operand=0]; //add->store
+const1->mul0[operand=0]; //gep_const->gep_mul
+mul0->load2[operand=0]; //gep_mul->load
+mul0->store11[operand=1]; //gep_mul->store
+const4->mul3[operand=0]; //gep_const->gep_mul
+mul3->load5[operand=0]; //gep_mul->load
+const7->load6[operand=0]; //const->load
+const13->add12[operand=1]; //const->add
+const15->mul14[operand=0]; //gep_const->gep_mul
+mul14->load16[operand=0]; //gep_mul->load
+mul14->store23[operand=1]; //gep_mul->store
+const18->mul17[operand=0]; //gep_const->gep_mul
+mul17->load19[operand=0]; //gep_mul->load
+}
diff -Nur cgra_me/benchmarks/polybench/bicg/bicg.c lisa/cgra_me/benchmarks/polybench/bicg/bicg.c
--- cgra_me/benchmarks/polybench/bicg/bicg.c	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/bicg/bicg.c	2022-02-28 16:37:25.872775483 +0800
@@ -0,0 +1,42 @@
+#include <stdio.h>
+
+volatile int * N;
+volatile int **A;
+volatile int *p;
+volatile int *r;
+volatile int *s;
+volatile int *q;
+
+
+int *c;
+
+int main() {
+    int i;
+    int j;
+    int n = *N;
+
+    int sum = 0;
+    for (j = 1; j < n-1; j++) {
+    //DFGLoop: loop
+        s[j] = s[j] + r[i] * A[i][j];
+	  q[i] = q[i] + A[i][j] * p[j];
+    }
+
+
+// #pragma scop
+//   for (i = 0; i < _PB_NY; i++)
+//     s[i] = 0;
+//   for (i = 0; i < _PB_NX; i++)
+//     {
+//       q[i] = 0;
+//       for (j = 0; j < _PB_NY; j++)
+// 	{
+// 	  s[j] = s[j] + r[i] * A[i][j];
+// 	  q[i] = q[i] + A[i][j] * p[j];
+// 	}
+//     }
+// #pragma endscop
+
+
+    return sum;
+}
diff -Nur cgra_me/benchmarks/polybench/bicg/Makefile lisa/cgra_me/benchmarks/polybench/bicg/Makefile
--- cgra_me/benchmarks/polybench/bicg/Makefile	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/bicg/Makefile	2022-02-28 16:37:25.872775483 +0800
@@ -0,0 +1 @@
+include ../../rules.mk
diff -Nur cgra_me/benchmarks/polybench/bicg/my_graph_loop.dot lisa/cgra_me/benchmarks/polybench/bicg/my_graph_loop.dot
--- cgra_me/benchmarks/polybench/bicg/my_graph_loop.dot	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/bicg/my_graph_loop.dot	2022-02-28 16:37:25.872775483 +0800
@@ -0,0 +1,53 @@
+digraph G {
+mul0[opcode=mul];
+const1[opcode=const];
+load2[opcode=load];
+load3[opcode=load];
+const4[opcode=const];
+load5[opcode=load];
+mul6[opcode=mul];
+const7[opcode=const];
+load8[opcode=load];
+mul9[opcode=mul];
+add10[opcode=add];
+store11[opcode=store];
+load12[opcode=load];
+const13[opcode=const];
+load14[opcode=load];
+load15[opcode=load];
+mul16[opcode=mul];
+const17[opcode=const];
+load18[opcode=load];
+mul19[opcode=mul];
+add20[opcode=add];
+store21[opcode=store];
+add22[opcode=add];
+const23[opcode=const];
+load2->add10[operand=1]; //load->add
+load3->load5[operand=0]; //load->load
+load5->mul9[operand=1]; //load->mul
+load8->mul9[operand=0]; //load->mul
+mul9->add10[operand=0]; //mul->add
+add10->store11[operand=0]; //add->store
+load12->load14[operand=0]; //load->load
+load12->store21[operand=1]; //load->store
+load14->add20[operand=1]; //load->add
+load15->mul19[operand=1]; //load->mul
+load18->mul19[operand=0]; //load->mul
+mul19->add20[operand=0]; //mul->add
+add20->store21[operand=0]; //add->store
+add22->mul0[operand=1]; //add->gep_mul
+add22->mul6[operand=1]; //add->gep_mul
+add22->mul16[operand=1]; //add->gep_mul
+const1->mul0[operand=0]; //gep_const->gep_mul
+mul0->load2[operand=0]; //gep_mul->load
+mul0->store11[operand=1]; //gep_mul->store
+const4->load3[operand=0]; //const->load
+const7->mul6[operand=0]; //gep_const->gep_mul
+mul6->load8[operand=0]; //gep_mul->load
+mul6->load15[operand=0]; //gep_mul->load
+const13->load12[operand=0]; //const->load
+const17->mul16[operand=0]; //gep_const->gep_mul
+mul16->load18[operand=0]; //gep_mul->load
+const23->add22[operand=1]; //const->add
+}
diff -Nur cgra_me/benchmarks/polybench/bicg_unroll/bicg.c lisa/cgra_me/benchmarks/polybench/bicg_unroll/bicg.c
--- cgra_me/benchmarks/polybench/bicg_unroll/bicg.c	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/bicg_unroll/bicg.c	2022-02-28 16:37:25.872775483 +0800
@@ -0,0 +1,46 @@
+#include <stdio.h>
+
+volatile int * N;
+volatile int **A;
+volatile int *p;
+volatile int *r;
+volatile int *s;
+volatile int *q;
+
+
+int *c;
+
+int main() {
+    int i;
+    int j;
+    int n = *N;
+
+    int sum = 0;
+    for (j = 1; j < n-1; j++) {
+    //DFGLoop: loop
+        s[j] = s[j] + r[i] * A[i][j];
+	  q[i] = q[i] + A[i][j] * p[j];
+
+
+        s[j+1] = s[j+1] + r[i] * A[i][j+1];
+	  q[i] = q[i] + A[i][j+1] * p[j+1];
+    }
+
+
+// #pragma scop
+//   for (i = 0; i < _PB_NY; i++)
+//     s[i] = 0;
+//   for (i = 0; i < _PB_NX; i++)
+//     {
+//       q[i] = 0;
+//       for (j = 0; j < _PB_NY; j++)
+// 	{
+// 	  s[j] = s[j] + r[i] * A[i][j];
+// 	  q[i] = q[i] + A[i][j] * p[j];
+// 	}
+//     }
+// #pragma endscop
+
+
+    return sum;
+}
diff -Nur cgra_me/benchmarks/polybench/bicg_unroll/Makefile lisa/cgra_me/benchmarks/polybench/bicg_unroll/Makefile
--- cgra_me/benchmarks/polybench/bicg_unroll/Makefile	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/bicg_unroll/Makefile	2022-02-28 16:37:25.872775483 +0800
@@ -0,0 +1 @@
+include ../../rules.mk
diff -Nur cgra_me/benchmarks/polybench/bicg_unroll/my_graph_loop.dot lisa/cgra_me/benchmarks/polybench/bicg_unroll/my_graph_loop.dot
--- cgra_me/benchmarks/polybench/bicg_unroll/my_graph_loop.dot	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/bicg_unroll/my_graph_loop.dot	2022-02-28 16:37:25.872775483 +0800
@@ -0,0 +1,95 @@
+digraph G {
+mul0[opcode=mul];
+const1[opcode=const];
+load2[opcode=load];
+load3[opcode=load];
+const4[opcode=const];
+load5[opcode=load];
+mul6[opcode=mul];
+const7[opcode=const];
+load8[opcode=load];
+mul9[opcode=mul];
+add10[opcode=add];
+store11[opcode=store];
+load12[opcode=load];
+const13[opcode=const];
+load14[opcode=load];
+load15[opcode=load];
+mul16[opcode=mul];
+const17[opcode=const];
+load18[opcode=load];
+mul19[opcode=mul];
+add20[opcode=add];
+store21[opcode=store];
+add22[opcode=add];
+const23[opcode=const];
+mul24[opcode=mul];
+const25[opcode=const];
+load26[opcode=load];
+load27[opcode=load];
+mul28[opcode=mul];
+const29[opcode=const];
+load30[opcode=load];
+mul31[opcode=mul];
+add32[opcode=add];
+store33[opcode=store];
+load34[opcode=load];
+load35[opcode=load];
+mul36[opcode=mul];
+const37[opcode=const];
+load38[opcode=load];
+mul39[opcode=mul];
+add40[opcode=add];
+store41[opcode=store];
+load2->add10[operand=1]; //load->add
+load3->load5[operand=0]; //load->load
+load3->load27[operand=0]; //load->load
+load5->mul9[operand=1]; //load->mul
+load8->mul9[operand=0]; //load->mul
+mul9->add10[operand=0]; //mul->add
+add10->store11[operand=0]; //add->store
+load12->load14[operand=0]; //load->load
+load12->store21[operand=1]; //load->store
+load12->load34[operand=0]; //load->load
+load12->store41[operand=1]; //load->store
+load14->add20[operand=1]; //load->add
+load15->mul19[operand=1]; //load->mul
+load18->mul19[operand=0]; //load->mul
+mul19->add20[operand=0]; //mul->add
+add20->store21[operand=0]; //add->store
+add22->mul24[operand=1]; //add->gep_mul
+add22->mul28[operand=1]; //add->gep_mul
+add22->mul36[operand=1]; //add->gep_mul
+add22->mul0[operand=1]; //add->gep_mul
+add22->mul6[operand=1]; //add->gep_mul
+add22->mul16[operand=1]; //add->gep_mul
+load26->add32[operand=1]; //load->add
+load27->mul31[operand=1]; //load->mul
+load30->mul31[operand=0]; //load->mul
+mul31->add32[operand=0]; //mul->add
+add32->store33[operand=0]; //add->store
+load34->add40[operand=1]; //load->add
+load35->mul39[operand=1]; //load->mul
+load38->mul39[operand=0]; //load->mul
+mul39->add40[operand=0]; //mul->add
+add40->store41[operand=0]; //add->store
+const1->mul0[operand=0]; //gep_const->gep_mul
+mul0->load2[operand=0]; //gep_mul->load
+mul0->store11[operand=1]; //gep_mul->store
+const4->load3[operand=0]; //const->load
+const7->mul6[operand=0]; //gep_const->gep_mul
+mul6->load8[operand=0]; //gep_mul->load
+mul6->load15[operand=0]; //gep_mul->load
+const13->load12[operand=0]; //const->load
+const17->mul16[operand=0]; //gep_const->gep_mul
+mul16->load18[operand=0]; //gep_mul->load
+const23->add22[operand=1]; //const->add
+const25->mul24[operand=0]; //gep_const->gep_mul
+mul24->load26[operand=0]; //gep_mul->load
+mul24->store33[operand=1]; //gep_mul->store
+const29->mul28[operand=0]; //gep_const->gep_mul
+mul28->load30[operand=0]; //gep_mul->load
+mul28->load35[operand=0]; //gep_mul->load
+const37->mul36[operand=0]; //gep_const->gep_mul
+mul36->load38[operand=0]; //gep_mul->load
+}
diff -Nur cgra_me/benchmarks/polybench/cholesky/cholesky.c lisa/cgra_me/benchmarks/polybench/cholesky/cholesky.c
--- cgra_me/benchmarks/polybench/cholesky/cholesky.c	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/cholesky/cholesky.c	2022-02-28 16:37:25.872775483 +0800
@@ -0,0 +1,44 @@
+#include <stdio.h>
+
+volatile int *N;
+volatile int *a;
+volatile int *b;
+volatile int **A;
+volatile int *p;
+
+int *c;
+
+int main()
+{
+    int i;
+    int n = *N;
+    int _PB_N, x = 1000, j, k;
+
+    int sum = 0;
+    x = 100;
+    A[0][0] = 1;
+    for (k = 1; k < n - 1; k++)
+    {
+        //DFGLoop: loop
+        x = x - A[j][k] * A[i][k];
+    }
+
+    for (i = 0; i < _PB_N; ++i)
+    {
+        x = A[i][i];
+        for (j = 0; j <= i - 1; ++j)
+            x = x - A[i][j] * A[i][j];
+        p[i] = x;
+        for (j = i + 1; j < _PB_N; ++j)
+        {
+            x = A[i][j];
+            for (k = 0; k <= i - 1; ++k)
+            {
+                x = x - A[j][k] * A[i][k];
+            }
+            A[j][i] = x * p[i];
+        }
+    }
+
+    return x;
+}
diff -Nur cgra_me/benchmarks/polybench/cholesky/Makefile lisa/cgra_me/benchmarks/polybench/cholesky/Makefile
--- cgra_me/benchmarks/polybench/cholesky/Makefile	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/cholesky/Makefile	2022-02-28 16:37:25.872775483 +0800
@@ -0,0 +1 @@
+include ../../rules.mk
diff -Nur cgra_me/benchmarks/polybench/cholesky/my_graph_loop.dot lisa/cgra_me/benchmarks/polybench/cholesky/my_graph_loop.dot
--- cgra_me/benchmarks/polybench/cholesky/my_graph_loop.dot	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/cholesky/my_graph_loop.dot	2022-02-28 16:37:25.872775483 +0800
@@ -0,0 +1,20 @@
+digraph G {
+mul0[opcode=mul];
+const1[opcode=const];
+load2[opcode=load];
+load3[opcode=load];
+mul4[opcode=mul];
+sub5[opcode=sub];
+output6[opcode=output];
+add7[opcode=add];
+const8[opcode=const];
+load2->mul4[operand=1]; //load->mul
+load3->mul4[operand=0]; //load->mul
+mul4->sub5[operand=1]; //mul->sub
+sub5->output6[operand=0]; //sub->output
+add7->mul0[operand=1]; //add->gep_mul
+const1->mul0[operand=0]; //gep_const->gep_mul
+mul0->load2[operand=0]; //gep_mul->load
+mul0->load3[operand=0]; //gep_mul->load
+const8->add7[operand=1]; //const->add
+}
diff -Nur cgra_me/benchmarks/polybench/cholesky_unroll/cholesky.c lisa/cgra_me/benchmarks/polybench/cholesky_unroll/cholesky.c
--- cgra_me/benchmarks/polybench/cholesky_unroll/cholesky.c	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/cholesky_unroll/cholesky.c	2022-02-28 16:37:25.872775483 +0800
@@ -0,0 +1,45 @@
+#include <stdio.h>
+
+volatile int *N;
+volatile int *a;
+volatile int *b;
+volatile int **A;
+volatile int *p;
+
+int *c;
+
+int main()
+{
+    int i;
+    int n = *N;
+    int _PB_N, x = 1000, j, k;
+
+    int sum = 0;
+    x = 100;
+    A[0][0] = 1;
+    for (k = 1; k < n - 1; k++)
+    {
+        //DFGLoop: loop
+        x = x - A[j][k] * A[i][k];
+        x = x - A[j][k+1] * A[i][k+1];
+    }
+
+    for (i = 0; i < _PB_N; ++i)
+    {
+        x = A[i][i];
+        for (j = 0; j <= i - 1; ++j)
+            x = x - A[i][j] * A[i][j];
+        p[i] = x;
+        for (j = i + 1; j < _PB_N; ++j)
+        {
+            x = A[i][j];
+            for (k = 0; k <= i - 1; ++k)
+            {
+                x = x - A[j][k] * A[i][k];
+            }
+            A[j][i] = x * p[i];
+        }
+    }
+
+    return x;
+}
diff -Nur cgra_me/benchmarks/polybench/cholesky_unroll/Makefile lisa/cgra_me/benchmarks/polybench/cholesky_unroll/Makefile
--- cgra_me/benchmarks/polybench/cholesky_unroll/Makefile	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/cholesky_unroll/Makefile	2022-02-28 16:37:25.872775483 +0800
@@ -0,0 +1 @@
+include ../../rules.mk
diff -Nur cgra_me/benchmarks/polybench/cholesky_unroll/my_graph_loop.dot lisa/cgra_me/benchmarks/polybench/cholesky_unroll/my_graph_loop.dot
--- cgra_me/benchmarks/polybench/cholesky_unroll/my_graph_loop.dot	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/cholesky_unroll/my_graph_loop.dot	2022-02-28 16:37:25.872775483 +0800
@@ -0,0 +1,35 @@
+digraph G {
+mul0[opcode=mul];
+const1[opcode=const];
+load2[opcode=load];
+load3[opcode=load];
+mul4[opcode=mul];
+add5[opcode=add];
+const6[opcode=const];
+mul7[opcode=mul];
+const8[opcode=const];
+load9[opcode=load];
+load10[opcode=load];
+mul11[opcode=mul];
+add12[opcode=add];
+sub13[opcode=sub];
+output14[opcode=output];
+load2->mul4[operand=1]; //load->mul
+load3->mul4[operand=0]; //load->mul
+mul4->add12[operand=1]; //mul->add
+add5->mul7[operand=1]; //add->gep_mul
+add5->mul0[operand=1]; //add->gep_mul
+add5->add5[operand=0]; //add->add
+load9->mul11[operand=1]; //load->mul
+load10->mul11[operand=0]; //load->mul
+mul11->add12[operand=0]; //mul->add
+add12->sub13[operand=1]; //add->sub
+sub13->output14[operand=0]; //sub->output
+const1->mul0[operand=0]; //gep_const->gep_mul
+mul0->load2[operand=0]; //gep_mul->load
+mul0->load3[operand=0]; //gep_mul->load
+const6->add5[operand=1]; //const->add
+const8->mul7[operand=0]; //gep_const->gep_mul
+mul7->load9[operand=0]; //gep_mul->load
+mul7->load10[operand=0]; //gep_mul->load
+}
diff -Nur cgra_me/benchmarks/polybench/doitgen/doitgen.c lisa/cgra_me/benchmarks/polybench/doitgen/doitgen.c
--- cgra_me/benchmarks/polybench/doitgen/doitgen.c	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/doitgen/doitgen.c	2022-02-28 16:37:25.904775549 +0800
@@ -0,0 +1,39 @@
+#include <stdio.h>
+
+volatile int * N;
+volatile int *a;
+volatile int *b;
+volatile int ***sum;
+volatile int ***A;
+volatile int **C4;
+
+int *c;
+
+int main() {
+    int i;
+    int n = *N;
+    int r;
+    int  p, q, s;
+    int _PB_NR, _PB_NQ, _PB_NP;
+
+    // int sum = 0;
+    for (s = 1; s < n-1; s++) {
+    //DFGLoop: loop
+         sum[r][q][p] = sum[r][q][p] + A[r][q][s] * C4[s][p];
+    }
+
+//     #pragma scop
+//   for (r = 0; r < _PB_NR; r++)
+//     for (q = 0; q < _PB_NQ; q++)  {
+//       for (p = 0; p < _PB_NP; p++)  {
+// 	sum[r][q][p] = 0;
+// 	for (s = 0; s < _PB_NP; s++)
+// 	  sum[r][q][p] = sum[r][q][p] + A[r][q][s] * C4[s][p];
+//       }
+//       for (p = 0; p < _PB_NR; p++)
+// 	A[r][q][p] = sum[r][q][p];
+//     }
+// #pragma endscop
+
+    return 0;
+}
diff -Nur cgra_me/benchmarks/polybench/doitgen/Makefile lisa/cgra_me/benchmarks/polybench/doitgen/Makefile
--- cgra_me/benchmarks/polybench/doitgen/Makefile	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/doitgen/Makefile	2022-02-28 16:37:25.904775549 +0800
@@ -0,0 +1 @@
+include ../../rules.mk
diff -Nur cgra_me/benchmarks/polybench/doitgen/my_graph_loop.dot lisa/cgra_me/benchmarks/polybench/doitgen/my_graph_loop.dot
--- cgra_me/benchmarks/polybench/doitgen/my_graph_loop.dot	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/doitgen/my_graph_loop.dot	2022-02-28 16:37:25.904775549 +0800
@@ -0,0 +1,39 @@
+digraph G {
+load0[opcode=load];
+const1[opcode=const];
+output2[opcode=output];
+load3[opcode=load];
+load4[opcode=load];
+load5[opcode=load];
+mul6[opcode=mul];
+const7[opcode=const];
+load8[opcode=load];
+mul9[opcode=mul];
+const10[opcode=const];
+load11[opcode=load];
+load12[opcode=load];
+mul13[opcode=mul];
+add14[opcode=add];
+store15[opcode=store];
+add16[opcode=add];
+const17[opcode=const];
+load0->output2[operand=0]; //load->output
+load0->load3[operand=0]; //load->load
+load3->load4[operand=0]; //load->load
+load4->load5[operand=0]; //load->load
+load4->store15[operand=1]; //load->store
+load5->add14[operand=1]; //load->add
+load8->mul13[operand=1]; //load->mul
+load11->load12[operand=0]; //load->load
+load12->mul13[operand=0]; //load->mul
+mul13->add14[operand=0]; //mul->add
+add14->store15[operand=0]; //add->store
+add16->mul6[operand=1]; //add->gep_mul
+add16->mul9[operand=1]; //add->gep_mul
+const1->load0[operand=0]; //const->load
+const7->mul6[operand=0]; //gep_const->gep_mul
+mul6->load8[operand=0]; //gep_mul->load
+const10->mul9[operand=0]; //gep_const->gep_mul
+mul9->load11[operand=0]; //gep_mul->load
+const17->add16[operand=1]; //const->add
+}
diff -Nur cgra_me/benchmarks/polybench/doitgen_unroll/doitgen.c lisa/cgra_me/benchmarks/polybench/doitgen_unroll/doitgen.c
--- cgra_me/benchmarks/polybench/doitgen_unroll/doitgen.c	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/doitgen_unroll/doitgen.c	2022-02-28 16:37:25.904775549 +0800
@@ -0,0 +1,41 @@
+#include <stdio.h>
+
+volatile int * N;
+volatile int *a;
+volatile int *b;
+volatile int ***sum;
+volatile int ***A;
+volatile int **C4;
+
+int *c;
+
+int main() {
+    int i;
+    int n = *N;
+    int r;
+    int  p, q, s;
+    int _PB_NR, _PB_NQ, _PB_NP;
+
+    // int sum = 0;
+    for (s = 1; s < n-1; s++) {
+    //DFGLoop: loop
+         sum[r][q][p] = sum[r][q][p] + A[r][q][s] * C4[s][p];
+
+         sum[r][q][p] = sum[r][q][p] + A[r][q][s+1] * C4[s+1][p];
+    }
+
+//     #pragma scop
+//   for (r = 0; r < _PB_NR; r++)
+//     for (q = 0; q < _PB_NQ; q++)  {
+//       for (p = 0; p < _PB_NP; p++)  {
+// 	sum[r][q][p] = 0;
+// 	for (s = 0; s < _PB_NP; s++)
+// 	  sum[r][q][p] = sum[r][q][p] + A[r][q][s] * C4[s][p];
+//       }
+//       for (p = 0; p < _PB_NR; p++)
+// 	A[r][q][p] = sum[r][q][p];
+//     }
+// #pragma endscop
+
+    return 0;
+}
diff -Nur cgra_me/benchmarks/polybench/doitgen_unroll/Makefile lisa/cgra_me/benchmarks/polybench/doitgen_unroll/Makefile
--- cgra_me/benchmarks/polybench/doitgen_unroll/Makefile	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/doitgen_unroll/Makefile	2022-02-28 16:37:25.904775549 +0800
@@ -0,0 +1 @@
+include ../../rules.mk
diff -Nur cgra_me/benchmarks/polybench/doitgen_unroll/my_graph_loop.dot lisa/cgra_me/benchmarks/polybench/doitgen_unroll/my_graph_loop.dot
--- cgra_me/benchmarks/polybench/doitgen_unroll/my_graph_loop.dot	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/doitgen_unroll/my_graph_loop.dot	2022-02-28 16:37:25.904775549 +0800
@@ -0,0 +1,62 @@
+digraph G {
+load0[opcode=load];
+const1[opcode=const];
+load2[opcode=load];
+load3[opcode=load];
+load4[opcode=load];
+mul5[opcode=mul];
+const6[opcode=const];
+load7[opcode=load];
+mul8[opcode=mul];
+const9[opcode=const];
+load10[opcode=load];
+load11[opcode=load];
+mul12[opcode=mul];
+add13[opcode=add];
+store14[opcode=store];
+load15[opcode=load];
+add16[opcode=add];
+const17[opcode=const];
+mul18[opcode=mul];
+const19[opcode=const];
+load20[opcode=load];
+mul21[opcode=mul];
+const22[opcode=const];
+load23[opcode=load];
+load24[opcode=load];
+mul25[opcode=mul];
+add26[opcode=add];
+store27[opcode=store];
+load0->load2[operand=0]; //load->load
+load2->load3[operand=0]; //load->load
+load3->load4[operand=0]; //load->load
+load3->store14[operand=1]; //load->store
+load3->load15[operand=0]; //load->load
+load3->store27[operand=1]; //load->store
+load4->add13[operand=1]; //load->add
+load7->mul12[operand=1]; //load->mul
+load10->load11[operand=0]; //load->load
+load11->mul12[operand=0]; //load->mul
+mul12->add13[operand=0]; //mul->add
+add13->store14[operand=0]; //add->store
+load15->add26[operand=1]; //load->add
+add16->mul18[operand=1]; //add->gep_mul
+add16->mul21[operand=1]; //add->gep_mul
+add16->mul5[operand=1]; //add->gep_mul
+add16->mul8[operand=1]; //add->gep_mul
+load20->mul25[operand=1]; //load->mul
+load23->load24[operand=0]; //load->load
+load24->mul25[operand=0]; //load->mul
+mul25->add26[operand=0]; //mul->add
+add26->store27[operand=0]; //add->store
+const1->load0[operand=0]; //const->load
+const6->mul5[operand=0]; //gep_const->gep_mul
+mul5->load7[operand=0]; //gep_mul->load
+const9->mul8[operand=0]; //gep_const->gep_mul
+mul8->load10[operand=0]; //gep_mul->load
+const17->add16[operand=1]; //const->add
+const19->mul18[operand=0]; //gep_const->gep_mul
+mul18->load20[operand=0]; //gep_mul->load
+const22->mul21[operand=0]; //gep_const->gep_mul
+mul21->load23[operand=0]; //gep_mul->load
+}
diff -Nur cgra_me/benchmarks/polybench/gemm/gemm.c lisa/cgra_me/benchmarks/polybench/gemm/gemm.c
--- cgra_me/benchmarks/polybench/gemm/gemm.c	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/gemm/gemm.c	2022-02-28 16:37:25.904775549 +0800
@@ -0,0 +1,36 @@
+#include <stdio.h>
+
+volatile int * N;
+volatile int *a;
+volatile int *b;
+int *c;
+volatile int **A;
+volatile int **B;
+volatile int **C;
+
+
+int main() {
+    int i, j, k;
+    int n = *N;
+    int alpha = 20;
+    int tmp;
+
+    int sum = 0;
+    for (k = 1; k < n-1; k++) {
+     //DFGLoop: loop
+     tmp = alpha * A[i][k];
+     tmp = tmp * B[k][j];
+         C[i][j] += tmp ;
+    }
+
+     /* C := alpha*A*B + beta*C */
+//   for (i = 0; i < _PB_NI; i++)
+//     for (j = 0; j < _PB_NJ; j++)
+//       {
+// 	C[i][j] *= beta;
+// 	for (k = 0; k < _PB_NK; ++k)
+// 	  C[i][j] += alpha * A[i][k] * B[k][j];
+//       }
+
+    return sum;
+}
diff -Nur cgra_me/benchmarks/polybench/gemm/Makefile lisa/cgra_me/benchmarks/polybench/gemm/Makefile
--- cgra_me/benchmarks/polybench/gemm/Makefile	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/gemm/Makefile	2022-02-28 16:37:25.904775549 +0800
@@ -0,0 +1 @@
+include ../../rules.mk
diff -Nur cgra_me/benchmarks/polybench/gemm/my_graph_loop.dot lisa/cgra_me/benchmarks/polybench/gemm/my_graph_loop.dot
--- cgra_me/benchmarks/polybench/gemm/my_graph_loop.dot	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/gemm/my_graph_loop.dot	2022-02-28 16:37:25.904775549 +0800
@@ -0,0 +1,39 @@
+digraph G {
+mul0[opcode=mul];
+const1[opcode=const];
+load2[opcode=load];
+mul3[opcode=mul];
+const4[opcode=const];
+mul5[opcode=mul];
+const6[opcode=const];
+load7[opcode=load];
+load8[opcode=load];
+mul9[opcode=mul];
+load10[opcode=load];
+const11[opcode=const];
+load12[opcode=load];
+load13[opcode=load];
+add14[opcode=add];
+store15[opcode=store];
+add16[opcode=add];
+const17[opcode=const];
+load2->mul3[operand=0]; //load->mul
+mul3->mul9[operand=0]; //mul->mul
+load7->load8[operand=0]; //load->load
+load8->mul9[operand=1]; //load->mul
+mul9->add14[operand=1]; //mul->add
+load10->load12[operand=0]; //load->load
+load12->load13[operand=0]; //load->load
+load12->store15[operand=1]; //load->store
+load13->add14[operand=0]; //load->add
+add14->store15[operand=0]; //add->store
+add16->mul0[operand=1]; //add->gep_mul
+add16->mul5[operand=1]; //add->gep_mul
+const1->mul0[operand=0]; //gep_const->gep_mul
+mul0->load2[operand=0]; //gep_mul->load
+const4->mul3[operand=1]; //const->mul
+const6->mul5[operand=0]; //gep_const->gep_mul
+mul5->load7[operand=0]; //gep_mul->load
+const11->load10[operand=0]; //const->load
+const17->add16[operand=1]; //const->add
+}
diff -Nur cgra_me/benchmarks/polybench/gemm_unroll/gemm.c lisa/cgra_me/benchmarks/polybench/gemm_unroll/gemm.c
--- cgra_me/benchmarks/polybench/gemm_unroll/gemm.c	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/gemm_unroll/gemm.c	2022-02-28 16:37:25.904775549 +0800
@@ -0,0 +1,39 @@
+#include <stdio.h>
+
+volatile int * N;
+volatile int *a;
+volatile int *b;
+int *c;
+volatile int **A;
+volatile int **B;
+volatile int **C;
+
+
+int main() {
+    int i, j, k;
+    int n = *N;
+    int alpha = 20;
+    int tmp;
+
+    int sum = 0;
+    for (k = 1; k < n-1; k++) {
+     //DFGLoop: loop
+     tmp = alpha * A[i][k];
+     tmp = tmp * B[k][j];
+         C[i][j] += tmp ;
+             tmp = alpha * A[i][k+1];
+     tmp = tmp * B[k+1][j];
+         C[i][j] += tmp ;
+    }
+
+     /* C := alpha*A*B + beta*C */
+//   for (i = 0; i < _PB_NI; i++)
+//     for (j = 0; j < _PB_NJ; j++)
+//       {
+// 	C[i][j] *= beta;
+// 	for (k = 0; k < _PB_NK; ++k)
+// 	  C[i][j] += alpha * A[i][k] * B[k][j];
+//       }
+
+    return sum;
+}
diff -Nur cgra_me/benchmarks/polybench/gemm_unroll/Makefile lisa/cgra_me/benchmarks/polybench/gemm_unroll/Makefile
--- cgra_me/benchmarks/polybench/gemm_unroll/Makefile	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/gemm_unroll/Makefile	2022-02-28 16:37:25.904775549 +0800
@@ -0,0 +1 @@
+include ../../rules.mk
diff -Nur cgra_me/benchmarks/polybench/gemm_unroll/my_graph_loop.dot lisa/cgra_me/benchmarks/polybench/gemm_unroll/my_graph_loop.dot
--- cgra_me/benchmarks/polybench/gemm_unroll/my_graph_loop.dot	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/gemm_unroll/my_graph_loop.dot	2022-02-28 16:37:25.904775549 +0800
@@ -0,0 +1,68 @@
+digraph G {
+mul0[opcode=mul];
+const1[opcode=const];
+load2[opcode=load];
+mul3[opcode=mul];
+const4[opcode=const];
+mul5[opcode=mul];
+const6[opcode=const];
+load7[opcode=load];
+load8[opcode=load];
+mul9[opcode=mul];
+load10[opcode=load];
+const11[opcode=const];
+load12[opcode=load];
+load13[opcode=load];
+add14[opcode=add];
+store15[opcode=store];
+add16[opcode=add];
+const17[opcode=const];
+mul18[opcode=mul];
+const19[opcode=const];
+load20[opcode=load];
+mul21[opcode=mul];
+const22[opcode=const];
+mul23[opcode=mul];
+const24[opcode=const];
+load25[opcode=load];
+load26[opcode=load];
+mul27[opcode=mul];
+load28[opcode=load];
+add29[opcode=add];
+store30[opcode=store];
+load2->mul3[operand=0]; //load->mul
+mul3->mul9[operand=0]; //mul->mul
+load7->load8[operand=0]; //load->load
+load8->mul9[operand=1]; //load->mul
+mul9->add14[operand=1]; //mul->add
+load10->load12[operand=0]; //load->load
+load12->load13[operand=0]; //load->load
+load12->store15[operand=1]; //load->store
+load12->load28[operand=0]; //load->load
+load12->store30[operand=1]; //load->store
+load13->add14[operand=0]; //load->add
+add14->store15[operand=0]; //add->store
+add16->mul18[operand=1]; //add->gep_mul
+add16->mul23[operand=1]; //add->gep_mul
+add16->mul0[operand=1]; //add->gep_mul
+add16->mul5[operand=1]; //add->gep_mul
+load20->mul21[operand=0]; //load->mul
+mul21->mul27[operand=0]; //mul->mul
+load25->load26[operand=0]; //load->load
+load26->mul27[operand=1]; //load->mul
+mul27->add29[operand=1]; //mul->add
+load28->add29[operand=0]; //load->add
+add29->store30[operand=0]; //add->store
+const1->mul0[operand=0]; //gep_const->gep_mul
+mul0->load2[operand=0]; //gep_mul->load
+const4->mul3[operand=1]; //const->mul
+const6->mul5[operand=0]; //gep_const->gep_mul
+mul5->load7[operand=0]; //gep_mul->load
+const11->load10[operand=0]; //const->load
+const17->add16[operand=1]; //const->add
+const19->mul18[operand=0]; //gep_const->gep_mul
+mul18->load20[operand=0]; //gep_mul->load
+const22->mul21[operand=1]; //const->mul
+const24->mul23[operand=0]; //gep_const->gep_mul
+mul23->load25[operand=0]; //gep_mul->load
+}
diff -Nur cgra_me/benchmarks/polybench/gemver/gemver.c lisa/cgra_me/benchmarks/polybench/gemver/gemver.c
--- cgra_me/benchmarks/polybench/gemver/gemver.c	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/gemver/gemver.c	2022-02-28 16:37:25.904775549 +0800
@@ -0,0 +1,26 @@
+#include <stdio.h>
+
+volatile int * N;
+volatile int *a;
+volatile int *b;
+volatile int **A;
+volatile int *u1;
+volatile int *v1;
+volatile int *u2;
+volatile int *v2;
+
+int *c;
+
+int main() {
+    int i,j;
+    int n = *N;
+
+    int sum = 0;
+    for (j = 1; j < n-1; j++) {
+    //DFGLoop: loop
+        A[i][j] = A[i][j] + u1[i] * v1[j] + u2[i] * v2[j];
+
+    }
+
+    return sum;
+}
diff -Nur cgra_me/benchmarks/polybench/gemver/Makefile lisa/cgra_me/benchmarks/polybench/gemver/Makefile
--- cgra_me/benchmarks/polybench/gemver/Makefile	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/gemver/Makefile	2022-02-28 16:37:25.904775549 +0800
@@ -0,0 +1 @@
+include ../../rules.mk
diff -Nur cgra_me/benchmarks/polybench/gemver/my_graph_loop.dot lisa/cgra_me/benchmarks/polybench/gemver/my_graph_loop.dot
--- cgra_me/benchmarks/polybench/gemver/my_graph_loop.dot	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/gemver/my_graph_loop.dot	2022-02-28 16:37:25.904775549 +0800
@@ -0,0 +1,48 @@
+digraph G {
+mul0[opcode=mul];
+const1[opcode=const];
+load2[opcode=load];
+load3[opcode=load];
+const4[opcode=const];
+load5[opcode=load];
+mul6[opcode=mul];
+const7[opcode=const];
+load8[opcode=load];
+mul9[opcode=mul];
+add10[opcode=add];
+load11[opcode=load];
+const12[opcode=const];
+load13[opcode=load];
+mul14[opcode=mul];
+const15[opcode=const];
+load16[opcode=load];
+mul17[opcode=mul];
+add18[opcode=add];
+store19[opcode=store];
+add20[opcode=add];
+const21[opcode=const];
+load2->add10[operand=1]; //load->add
+load3->load5[operand=0]; //load->load
+load5->mul9[operand=1]; //load->mul
+load8->mul9[operand=0]; //load->mul
+mul9->add10[operand=0]; //mul->add
+add10->add18[operand=0]; //add->add
+load11->load13[operand=0]; //load->load
+load13->mul17[operand=1]; //load->mul
+load16->mul17[operand=0]; //load->mul
+mul17->add18[operand=1]; //mul->add
+add18->store19[operand=0]; //add->store
+add20->mul0[operand=1]; //add->gep_mul
+add20->mul6[operand=1]; //add->gep_mul
+add20->mul14[operand=1]; //add->gep_mul
+const1->mul0[operand=0]; //gep_const->gep_mul
+mul0->load2[operand=0]; //gep_mul->load
+mul0->store19[operand=1]; //gep_mul->store
+const4->load3[operand=0]; //const->load
+const7->mul6[operand=0]; //gep_const->gep_mul
+mul6->load8[operand=0]; //gep_mul->load
+const12->load11[operand=0]; //const->load
+const15->mul14[operand=0]; //gep_const->gep_mul
+mul14->load16[operand=0]; //gep_mul->load
+const21->add20[operand=1]; //const->add
+}
diff -Nur cgra_me/benchmarks/polybench/gemver_unroll/gemver.c lisa/cgra_me/benchmarks/polybench/gemver_unroll/gemver.c
--- cgra_me/benchmarks/polybench/gemver_unroll/gemver.c	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/gemver_unroll/gemver.c	2022-02-28 16:37:25.904775549 +0800
@@ -0,0 +1,28 @@
+#include <stdio.h>
+
+volatile int * N;
+volatile int *a;
+volatile int *b;
+volatile int **A;
+volatile int *u1;
+volatile int *v1;
+volatile int *u2;
+volatile int *v2;
+
+int *c;
+
+int main() {
+    int i,j;
+    int n = *N;
+
+    int sum = 0;
+    for (j = 1; j < n-1; j++) {
+    //DFGLoop: loop
+        A[i][j] = A[i][j] + u1[i] * v1[j] + u2[i] * v2[j];
+
+        A[i][j+1] = A[i][j+1] + u1[i] * v1[j+1] + u2[i] * v2[j+1];
+
+    }
+
+    return sum;
+}
diff -Nur cgra_me/benchmarks/polybench/gemver_unroll/Makefile lisa/cgra_me/benchmarks/polybench/gemver_unroll/Makefile
--- cgra_me/benchmarks/polybench/gemver_unroll/Makefile	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/gemver_unroll/Makefile	2022-02-28 16:37:25.904775549 +0800
@@ -0,0 +1 @@
+include ../../rules.mk
diff -Nur cgra_me/benchmarks/polybench/gemver_unroll/my_graph_loop.dot lisa/cgra_me/benchmarks/polybench/gemver_unroll/my_graph_loop.dot
--- cgra_me/benchmarks/polybench/gemver_unroll/my_graph_loop.dot	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/gemver_unroll/my_graph_loop.dot	2022-02-28 16:37:25.904775549 +0800
@@ -0,0 +1,85 @@
+digraph G {
+mul0[opcode=mul];
+const1[opcode=const];
+load2[opcode=load];
+load3[opcode=load];
+const4[opcode=const];
+load5[opcode=load];
+mul6[opcode=mul];
+const7[opcode=const];
+load8[opcode=load];
+mul9[opcode=mul];
+add10[opcode=add];
+load11[opcode=load];
+const12[opcode=const];
+load13[opcode=load];
+mul14[opcode=mul];
+const15[opcode=const];
+load16[opcode=load];
+mul17[opcode=mul];
+add18[opcode=add];
+store19[opcode=store];
+add20[opcode=add];
+const21[opcode=const];
+mul22[opcode=mul];
+const23[opcode=const];
+load24[opcode=load];
+load25[opcode=load];
+mul26[opcode=mul];
+const27[opcode=const];
+load28[opcode=load];
+mul29[opcode=mul];
+add30[opcode=add];
+load31[opcode=load];
+mul32[opcode=mul];
+const33[opcode=const];
+load34[opcode=load];
+mul35[opcode=mul];
+add36[opcode=add];
+store37[opcode=store];
+load2->add10[operand=1]; //load->add
+load3->load5[operand=0]; //load->load
+load3->load25[operand=0]; //load->load
+load5->mul9[operand=1]; //load->mul
+load8->mul9[operand=0]; //load->mul
+mul9->add10[operand=0]; //mul->add
+add10->add18[operand=0]; //add->add
+load11->load13[operand=0]; //load->load
+load11->load31[operand=0]; //load->load
+load13->mul17[operand=1]; //load->mul
+load16->mul17[operand=0]; //load->mul
+mul17->add18[operand=1]; //mul->add
+add18->store19[operand=0]; //add->store
+add20->mul22[operand=1]; //add->gep_mul
+add20->mul26[operand=1]; //add->gep_mul
+add20->mul32[operand=1]; //add->gep_mul
+add20->mul0[operand=1]; //add->gep_mul
+add20->mul6[operand=1]; //add->gep_mul
+add20->mul14[operand=1]; //add->gep_mul
+load24->add30[operand=1]; //load->add
+load25->mul29[operand=1]; //load->mul
+load28->mul29[operand=0]; //load->mul
+mul29->add30[operand=0]; //mul->add
+add30->add36[operand=0]; //add->add
+load31->mul35[operand=1]; //load->mul
+load34->mul35[operand=0]; //load->mul
+mul35->add36[operand=1]; //mul->add
+add36->store37[operand=0]; //add->store
+const1->mul0[operand=0]; //gep_const->gep_mul
+mul0->load2[operand=0]; //gep_mul->load
+mul0->store19[operand=1]; //gep_mul->store
+const4->load3[operand=0]; //const->load
+const7->mul6[operand=0]; //gep_const->gep_mul
+mul6->load8[operand=0]; //gep_mul->load
+const12->load11[operand=0]; //const->load
+const15->mul14[operand=0]; //gep_const->gep_mul
+mul14->load16[operand=0]; //gep_mul->load
+const21->add20[operand=1]; //const->add
+const23->mul22[operand=0]; //gep_const->gep_mul
+mul22->load24[operand=0]; //gep_mul->load
+mul22->store37[operand=1]; //gep_mul->store
+const27->mul26[operand=0]; //gep_const->gep_mul
+mul26->load28[operand=0]; //gep_mul->load
+const33->mul32[operand=0]; //gep_const->gep_mul
+mul32->load34[operand=0]; //gep_mul->load
+}
diff -Nur cgra_me/benchmarks/polybench/gesummv/gesummv.c lisa/cgra_me/benchmarks/polybench/gesummv/gesummv.c
--- cgra_me/benchmarks/polybench/gesummv/gesummv.c	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/gesummv/gesummv.c	2022-02-28 16:37:25.904775549 +0800
@@ -0,0 +1,24 @@
+#include <stdio.h>
+
+volatile int * N;
+volatile int *a;
+volatile int *b;
+int *c;
+int **A;
+int *tmp;
+int *x;
+int *y;
+int **B;
+int main() {
+    int i,j;
+    int n = *N;
+
+    int sum = 0;
+    for (j = 1; j < n-1; j++) {
+    //DFGLoop: loop
+        tmp[i] = A[i][j] * x[j] + tmp[i];
+	  y[i] = B[i][j] * x[j] + y[i];
+    }
+
+    return sum;
+}
diff -Nur cgra_me/benchmarks/polybench/gesummv/Makefile lisa/cgra_me/benchmarks/polybench/gesummv/Makefile
--- cgra_me/benchmarks/polybench/gesummv/Makefile	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/gesummv/Makefile	2022-02-28 16:37:25.904775549 +0800
@@ -0,0 +1 @@
+include ../../rules.mk
diff -Nur cgra_me/benchmarks/polybench/gesummv/my_graph_loop.dot lisa/cgra_me/benchmarks/polybench/gesummv/my_graph_loop.dot
--- cgra_me/benchmarks/polybench/gesummv/my_graph_loop.dot	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/gesummv/my_graph_loop.dot	2022-02-28 16:37:25.904775549 +0800
@@ -0,0 +1,53 @@
+digraph G {
+mul0[opcode=mul];
+const1[opcode=const];
+load2[opcode=load];
+mul3[opcode=mul];
+const4[opcode=const];
+load5[opcode=load];
+mul6[opcode=mul];
+load7[opcode=load];
+const8[opcode=const];
+load9[opcode=load];
+add10[opcode=add];
+store11[opcode=store];
+mul12[opcode=mul];
+const13[opcode=const];
+load14[opcode=load];
+load15[opcode=load];
+mul16[opcode=mul];
+load17[opcode=load];
+const18[opcode=const];
+load19[opcode=load];
+add20[opcode=add];
+store21[opcode=store];
+add22[opcode=add];
+const23[opcode=const];
+load2->mul6[operand=1]; //load->mul
+load5->mul6[operand=0]; //load->mul
+mul6->add10[operand=1]; //mul->add
+load7->load9[operand=0]; //load->load
+load7->store11[operand=1]; //load->store
+load9->add10[operand=0]; //load->add
+add10->store11[operand=0]; //add->store
+load14->mul16[operand=1]; //load->mul
+load15->mul16[operand=0]; //load->mul
+mul16->add20[operand=1]; //mul->add
+load17->load19[operand=0]; //load->load
+load17->store21[operand=1]; //load->store
+load19->add20[operand=0]; //load->add
+add20->store21[operand=0]; //add->store
+add22->mul0[operand=1]; //add->gep_mul
+add22->mul3[operand=1]; //add->gep_mul
+add22->mul12[operand=1]; //add->gep_mul
+const1->mul0[operand=0]; //gep_const->gep_mul
+mul0->load2[operand=0]; //gep_mul->load
+const4->mul3[operand=0]; //gep_const->gep_mul
+mul3->load5[operand=0]; //gep_mul->load
+mul3->load15[operand=0]; //gep_mul->load
+const8->load7[operand=0]; //const->load
+const13->mul12[operand=0]; //gep_const->gep_mul
+mul12->load14[operand=0]; //gep_mul->load
+const18->load17[operand=0]; //const->load
+const23->add22[operand=0]; //const->add
+}
diff -Nur cgra_me/benchmarks/polybench/gesummv_unroll/gesummv.c lisa/cgra_me/benchmarks/polybench/gesummv_unroll/gesummv.c
--- cgra_me/benchmarks/polybench/gesummv_unroll/gesummv.c	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/gesummv_unroll/gesummv.c	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1,27 @@
+#include <stdio.h>
+
+volatile int * N;
+volatile int *a;
+volatile int *b;
+int *c;
+int **A;
+int *tmp;
+int *x;
+int *y;
+int **B;
+int main() {
+    int i,j;
+    int n = *N;
+
+    int sum = 0;
+    for (j = 1; j < n-1; j++) {
+    //DFGLoop: loop
+        tmp[i] = A[i][j] * x[j] + tmp[i];
+	  y[i] = B[i][j] * x[j] + y[i];
+
+       tmp[i] = A[i][j+1] * x[j+1] + tmp[i];
+	  y[i] = B[i][j+1] * x[j+1] + y[i];
+    }
+
+    return sum;
+}
diff -Nur cgra_me/benchmarks/polybench/gesummv_unroll/Makefile lisa/cgra_me/benchmarks/polybench/gesummv_unroll/Makefile
--- cgra_me/benchmarks/polybench/gesummv_unroll/Makefile	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/gesummv_unroll/Makefile	2022-02-28 16:37:25.904775549 +0800
@@ -0,0 +1 @@
+include ../../rules.mk
diff -Nur cgra_me/benchmarks/polybench/gesummv_unroll/my_graph_loop.dot lisa/cgra_me/benchmarks/polybench/gesummv_unroll/my_graph_loop.dot
--- cgra_me/benchmarks/polybench/gesummv_unroll/my_graph_loop.dot	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/gesummv_unroll/my_graph_loop.dot	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1,95 @@
+digraph G {
+mul0[opcode=mul];
+const1[opcode=const];
+load2[opcode=load];
+mul3[opcode=mul];
+const4[opcode=const];
+load5[opcode=load];
+mul6[opcode=mul];
+load7[opcode=load];
+const8[opcode=const];
+load9[opcode=load];
+add10[opcode=add];
+store11[opcode=store];
+mul12[opcode=mul];
+const13[opcode=const];
+load14[opcode=load];
+load15[opcode=load];
+mul16[opcode=mul];
+load17[opcode=load];
+const18[opcode=const];
+load19[opcode=load];
+add20[opcode=add];
+store21[opcode=store];
+add22[opcode=add];
+const23[opcode=const];
+mul24[opcode=mul];
+const25[opcode=const];
+load26[opcode=load];
+mul27[opcode=mul];
+const28[opcode=const];
+load29[opcode=load];
+mul30[opcode=mul];
+load31[opcode=load];
+add32[opcode=add];
+store33[opcode=store];
+mul34[opcode=mul];
+const35[opcode=const];
+load36[opcode=load];
+load37[opcode=load];
+mul38[opcode=mul];
+load39[opcode=load];
+add40[opcode=add];
+store41[opcode=store];
+load2->mul6[operand=1]; //load->mul
+load5->mul6[operand=0]; //load->mul
+mul6->add10[operand=1]; //mul->add
+load7->load9[operand=0]; //load->load
+load7->store11[operand=1]; //load->store
+load7->load31[operand=0]; //load->load
+load7->store33[operand=1]; //load->store
+load9->add10[operand=0]; //load->add
+add10->store11[operand=0]; //add->store
+load14->mul16[operand=1]; //load->mul
+load15->mul16[operand=0]; //load->mul
+mul16->add20[operand=1]; //mul->add
+load17->load19[operand=0]; //load->load
+load17->store21[operand=1]; //load->store
+load17->load39[operand=0]; //load->load
+load17->store41[operand=1]; //load->store
+load19->add20[operand=0]; //load->add
+add20->store21[operand=0]; //add->store
+add22->mul24[operand=1]; //add->gep_mul
+add22->mul27[operand=1]; //add->gep_mul
+add22->mul34[operand=1]; //add->gep_mul
+add22->mul0[operand=1]; //add->gep_mul
+add22->mul3[operand=1]; //add->gep_mul
+add22->mul12[operand=1]; //add->gep_mul
+load26->mul30[operand=1]; //load->mul
+load29->mul30[operand=0]; //load->mul
+mul30->add32[operand=0]; //mul->add
+load31->add32[operand=1]; //load->add
+add32->store33[operand=0]; //add->store
+load36->mul38[operand=1]; //load->mul
+load37->mul38[operand=0]; //load->mul
+mul38->add40[operand=0]; //mul->add
+load39->add40[operand=1]; //load->add
+add40->store41[operand=0]; //add->store
+const1->mul0[operand=0]; //gep_const->gep_mul
+mul0->load2[operand=0]; //gep_mul->load
+const4->mul3[operand=0]; //gep_const->gep_mul
+mul3->load5[operand=0]; //gep_mul->load
+mul3->load15[operand=0]; //gep_mul->load
+const8->load7[operand=0]; //const->load
+const13->mul12[operand=0]; //gep_const->gep_mul
+mul12->load14[operand=0]; //gep_mul->load
+const18->load17[operand=0]; //const->load
+const23->add22[operand=1]; //const->add
+const25->mul24[operand=0]; //gep_const->gep_mul
+mul24->load26[operand=0]; //gep_mul->load
+const28->mul27[operand=0]; //gep_const->gep_mul
+mul27->load29[operand=0]; //gep_mul->load
+mul27->load37[operand=0]; //gep_mul->load
+const35->mul34[operand=0]; //gep_const->gep_mul
+mul34->load36[operand=0]; //gep_mul->load
+}
diff -Nur cgra_me/benchmarks/polybench/mvt/Makefile lisa/cgra_me/benchmarks/polybench/mvt/Makefile
--- cgra_me/benchmarks/polybench/mvt/Makefile	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/mvt/Makefile	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1 @@
+include ../../rules.mk
diff -Nur cgra_me/benchmarks/polybench/mvt/mvt.c lisa/cgra_me/benchmarks/polybench/mvt/mvt.c
--- cgra_me/benchmarks/polybench/mvt/mvt.c	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/mvt/mvt.c	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1,22 @@
+#include <stdio.h>
+
+volatile int * N;
+volatile int *a;
+volatile int *b;
+int *c;
+int *x2;
+int **A;
+int *y_2;
+
+int main() {
+    int i,j;
+    int n = *N;
+
+    int sum = 0;
+    for (j = 1; j < n-1; j++) {
+    //DFGLoop: loop
+        x2[i] = x2[i] + A[j][i] * y_2[j];
+    }
+
+    return sum;
+}
diff -Nur cgra_me/benchmarks/polybench/mvt/my_graph_loop.dot lisa/cgra_me/benchmarks/polybench/mvt/my_graph_loop.dot
--- cgra_me/benchmarks/polybench/mvt/my_graph_loop.dot	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/mvt/my_graph_loop.dot	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1,33 @@
+digraph G {
+load0[opcode=load];
+const1[opcode=const];
+load2[opcode=load];
+mul3[opcode=mul];
+const4[opcode=const];
+load5[opcode=load];
+load6[opcode=load];
+mul7[opcode=mul];
+const8[opcode=const];
+load9[opcode=load];
+mul10[opcode=mul];
+add11[opcode=add];
+store12[opcode=store];
+add13[opcode=add];
+const14[opcode=const];
+load0->load2[operand=0]; //load->load
+load0->store12[operand=1]; //load->store
+load2->add11[operand=1]; //load->add
+load5->load6[operand=0]; //load->load
+load6->mul10[operand=1]; //load->mul
+load9->mul10[operand=0]; //load->mul
+mul10->add11[operand=0]; //mul->add
+add11->store12[operand=0]; //add->store
+add13->mul3[operand=1]; //add->gep_mul
+add13->mul7[operand=1]; //add->gep_mul
+const1->load0[operand=0]; //const->load
+const4->mul3[operand=0]; //gep_const->gep_mul
+mul3->load5[operand=0]; //gep_mul->load
+const8->mul7[operand=0]; //gep_const->gep_mul
+mul7->load9[operand=0]; //gep_mul->load
+const14->add13[operand=0]; //const->add
+}
diff -Nur cgra_me/benchmarks/polybench/mvt_unroll/Makefile lisa/cgra_me/benchmarks/polybench/mvt_unroll/Makefile
--- cgra_me/benchmarks/polybench/mvt_unroll/Makefile	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/mvt_unroll/Makefile	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1 @@
+include ../../rules.mk
diff -Nur cgra_me/benchmarks/polybench/mvt_unroll/mvt.c lisa/cgra_me/benchmarks/polybench/mvt_unroll/mvt.c
--- cgra_me/benchmarks/polybench/mvt_unroll/mvt.c	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/mvt_unroll/mvt.c	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1,23 @@
+#include <stdio.h>
+
+volatile int * N;
+volatile int *a;
+volatile int *b;
+int *c;
+int *x2;
+int **A;
+int *y_2;
+
+int main() {
+    int i,j;
+    int n = *N;
+
+    int sum = 0;
+    for (j = 1; j < n-1; j++) {
+    //DFGLoop: loop
+        x2[i] = x2[i] + A[j][i] * y_2[j];
+        x2[i] = x2[i] + A[j+1][i] * y_2[j+1];
+    }
+
+    return sum;
+}
diff -Nur cgra_me/benchmarks/polybench/mvt_unroll/my_graph_loop.dot lisa/cgra_me/benchmarks/polybench/mvt_unroll/my_graph_loop.dot
--- cgra_me/benchmarks/polybench/mvt_unroll/my_graph_loop.dot	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/mvt_unroll/my_graph_loop.dot	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1,56 @@
+digraph G {
+load0[opcode=load];
+const1[opcode=const];
+load2[opcode=load];
+mul3[opcode=mul];
+const4[opcode=const];
+load5[opcode=load];
+load6[opcode=load];
+mul7[opcode=mul];
+const8[opcode=const];
+load9[opcode=load];
+mul10[opcode=mul];
+add11[opcode=add];
+store12[opcode=store];
+add13[opcode=add];
+const14[opcode=const];
+mul15[opcode=mul];
+const16[opcode=const];
+load17[opcode=load];
+load18[opcode=load];
+mul19[opcode=mul];
+const20[opcode=const];
+load21[opcode=load];
+mul22[opcode=mul];
+add23[opcode=add];
+store24[opcode=store];
+load0->load2[operand=0]; //load->load
+load0->store12[operand=1]; //load->store
+load0->store24[operand=1]; //load->store
+load2->add11[operand=1]; //load->add
+load5->load6[operand=0]; //load->load
+load6->mul10[operand=1]; //load->mul
+load9->mul10[operand=0]; //load->mul
+mul10->add11[operand=0]; //mul->add
+add11->store12[operand=0]; //add->store
+add11->add23[operand=1]; //add->add
+add13->mul15[operand=1]; //add->gep_mul
+add13->mul19[operand=1]; //add->gep_mul
+add13->mul3[operand=1]; //add->gep_mul
+add13->mul7[operand=1]; //add->gep_mul
+load17->load18[operand=0]; //load->load
+load18->mul22[operand=1]; //load->mul
+load21->mul22[operand=0]; //load->mul
+mul22->add23[operand=0]; //mul->add
+add23->store24[operand=0]; //add->store
+const1->load0[operand=0]; //const->load
+const4->mul3[operand=0]; //gep_const->gep_mul
+mul3->load5[operand=0]; //gep_mul->load
+const8->mul7[operand=0]; //gep_const->gep_mul
+mul7->load9[operand=0]; //gep_mul->load
+const14->add13[operand=1]; //const->add
+const16->mul15[operand=0]; //gep_const->gep_mul
+mul15->load17[operand=0]; //gep_mul->load
+const20->mul19[operand=0]; //gep_const->gep_mul
+mul19->load21[operand=0]; //gep_mul->load
+}
diff -Nur cgra_me/benchmarks/polybench/symm/Makefile lisa/cgra_me/benchmarks/polybench/symm/Makefile
--- cgra_me/benchmarks/polybench/symm/Makefile	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/symm/Makefile	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1 @@
+include ../../rules.mk
diff -Nur cgra_me/benchmarks/polybench/symm/my_graph_loop.dot lisa/cgra_me/benchmarks/polybench/symm/my_graph_loop.dot
--- cgra_me/benchmarks/polybench/symm/my_graph_loop.dot	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/symm/my_graph_loop.dot	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1,37 @@
+digraph G {
+mul0[opcode=mul];
+const1[opcode=const];
+load2[opcode=load];
+load3[opcode=load];
+load4[opcode=load];
+const5[opcode=const];
+load6[opcode=load];
+load7[opcode=load];
+mul8[opcode=mul];
+mul9[opcode=mul];
+const10[opcode=const];
+load11[opcode=load];
+load12[opcode=load];
+add13[opcode=add];
+store14[opcode=store];
+add15[opcode=add];
+const16[opcode=const];
+load2->load3[operand=0]; //load->load
+load3->mul8[operand=1]; //load->mul
+load4->load6[operand=0]; //load->load
+load6->load7[operand=0]; //load->load
+load7->mul8[operand=0]; //load->mul
+mul8->add13[operand=1]; //mul->add
+load11->load12[operand=0]; //load->load
+load11->store14[operand=1]; //load->store
+load12->add13[operand=0]; //load->add
+add13->store14[operand=0]; //add->store
+add15->mul0[operand=1]; //add->gep_mul
+add15->mul9[operand=1]; //add->gep_mul
+const1->mul0[operand=0]; //gep_const->gep_mul
+mul0->load2[operand=0]; //gep_mul->load
+const5->load4[operand=0]; //const->load
+const10->mul9[operand=0]; //gep_const->gep_mul
+mul9->load11[operand=0]; //gep_mul->load
+const16->add15[operand=0]; //const->add
+}
diff -Nur cgra_me/benchmarks/polybench/symm/symm.c lisa/cgra_me/benchmarks/polybench/symm/symm.c
--- cgra_me/benchmarks/polybench/symm/symm.c	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/symm/symm.c	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1,22 @@
+#include <stdio.h>
+
+volatile int * N;
+volatile int *a;
+volatile int *b;
+int **A;
+int **B;
+int **C;
+
+int main() {
+    int i, j, k, alpha = 1, acc = 100;
+    int n = *N;
+
+    int sum = 0;
+    for (k = 1; k < n-1; k++) {
+    //DFGLoop: loop
+         C[k][j] += alpha * A[k][i] * B[i][j];
+	    acc += B[k][j] * A[k][i];
+    }
+
+    return sum;
+}
diff -Nur cgra_me/benchmarks/polybench/symm_unroll/Makefile lisa/cgra_me/benchmarks/polybench/symm_unroll/Makefile
--- cgra_me/benchmarks/polybench/symm_unroll/Makefile	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/symm_unroll/Makefile	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1 @@
+include ../../rules.mk
diff -Nur cgra_me/benchmarks/polybench/symm_unroll/my_graph_loop.dot lisa/cgra_me/benchmarks/polybench/symm_unroll/my_graph_loop.dot
--- cgra_me/benchmarks/polybench/symm_unroll/my_graph_loop.dot	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/symm_unroll/my_graph_loop.dot	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1,64 @@
+digraph G {
+mul0[opcode=mul];
+const1[opcode=const];
+load2[opcode=load];
+load3[opcode=load];
+load4[opcode=load];
+const5[opcode=const];
+load6[opcode=load];
+load7[opcode=load];
+mul8[opcode=mul];
+mul9[opcode=mul];
+const10[opcode=const];
+load11[opcode=load];
+load12[opcode=load];
+add13[opcode=add];
+store14[opcode=store];
+add15[opcode=add];
+const16[opcode=const];
+mul17[opcode=mul];
+const18[opcode=const];
+load19[opcode=load];
+load20[opcode=load];
+load21[opcode=load];
+mul22[opcode=mul];
+mul23[opcode=mul];
+const24[opcode=const];
+load25[opcode=load];
+load26[opcode=load];
+add27[opcode=add];
+store28[opcode=store];
+load2->load3[operand=0]; //load->load
+load3->mul8[operand=1]; //load->mul
+load4->load6[operand=0]; //load->load
+load6->load7[operand=0]; //load->load
+load6->load21[operand=0]; //load->load
+load7->mul8[operand=0]; //load->mul
+mul8->add13[operand=1]; //mul->add
+load11->load12[operand=0]; //load->load
+load11->store14[operand=1]; //load->store
+load12->add13[operand=0]; //load->add
+add13->store14[operand=0]; //add->store
+add15->mul17[operand=1]; //add->gep_mul
+add15->mul23[operand=1]; //add->gep_mul
+add15->mul0[operand=1]; //add->gep_mul
+add15->mul9[operand=1]; //add->gep_mul
+load19->load20[operand=0]; //load->load
+load20->mul22[operand=1]; //load->mul
+load21->mul22[operand=0]; //load->mul
+mul22->add27[operand=1]; //mul->add
+load25->load26[operand=0]; //load->load
+load25->store28[operand=1]; //load->store
+load26->add27[operand=0]; //load->add
+add27->store28[operand=0]; //add->store
+const1->mul0[operand=0]; //gep_const->gep_mul
+mul0->load2[operand=0]; //gep_mul->load
+const5->load4[operand=0]; //const->load
+const10->mul9[operand=0]; //gep_const->gep_mul
+mul9->load11[operand=0]; //gep_mul->load
+const16->add15[operand=1]; //const->add
+const18->mul17[operand=0]; //gep_const->gep_mul
+mul17->load19[operand=0]; //gep_mul->load
+const24->mul23[operand=0]; //gep_const->gep_mul
+mul23->load25[operand=0]; //gep_mul->load
+}
diff -Nur cgra_me/benchmarks/polybench/symm_unroll/symm.c lisa/cgra_me/benchmarks/polybench/symm_unroll/symm.c
--- cgra_me/benchmarks/polybench/symm_unroll/symm.c	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/symm_unroll/symm.c	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1,25 @@
+#include <stdio.h>
+
+volatile int * N;
+volatile int *a;
+volatile int *b;
+int **A;
+int **B;
+int **C;
+
+int main() {
+    int i, j, k, alpha = 1, acc = 100;
+    int n = *N;
+
+    int sum = 0;
+    for (k = 1; k < n-1; k++) {
+    //DFGLoop: loop
+         C[k][j] += alpha * A[k][i] * B[i][j];
+	    acc += B[k][j] * A[k][i];
+
+         C[k+1][j] += alpha * A[k+1][i] * B[i][j];
+	    acc += B[k+1][j] * A[k+1][i];
+    }
+
+    return sum;
+}
diff -Nur cgra_me/benchmarks/polybench/syr2k/Makefile lisa/cgra_me/benchmarks/polybench/syr2k/Makefile
--- cgra_me/benchmarks/polybench/syr2k/Makefile	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/syr2k/Makefile	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1 @@
+include ../../rules.mk
diff -Nur cgra_me/benchmarks/polybench/syr2k/syr2k.c lisa/cgra_me/benchmarks/polybench/syr2k/syr2k.c
--- cgra_me/benchmarks/polybench/syr2k/syr2k.c	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/syr2k/syr2k.c	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1,22 @@
+#include <stdio.h>
+
+volatile int * N;
+volatile int *a;
+volatile int *b;
+int *c;
+int **A;
+int **B;
+int **C;
+int main() {
+    int i, j, k, alpha = 2;
+    int n = *N;
+
+    int sum = 0;
+    for (k = 1; k< n-1; k++) {
+    //DFGLoop: loop
+       C[i][j] += alpha * A[i][k] * B[j][k];
+	  C[i][j] += alpha * B[i][k] * A[j][k];
+    }
+
+    return sum;
+}
diff -Nur cgra_me/benchmarks/polybench/syr2k_unroll/Makefile lisa/cgra_me/benchmarks/polybench/syr2k_unroll/Makefile
--- cgra_me/benchmarks/polybench/syr2k_unroll/Makefile	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/syr2k_unroll/Makefile	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1 @@
+include ../../rules.mk
diff -Nur cgra_me/benchmarks/polybench/syr2k_unroll/syr2k.c lisa/cgra_me/benchmarks/polybench/syr2k_unroll/syr2k.c
--- cgra_me/benchmarks/polybench/syr2k_unroll/syr2k.c	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/syr2k_unroll/syr2k.c	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1,25 @@
+#include <stdio.h>
+
+volatile int * N;
+volatile int *a;
+volatile int *b;
+int *c;
+int **A;
+int **B;
+int **C;
+int main() {
+    int i, j, k, alpha = 2;
+    int n = *N;
+
+    int sum = 0;
+    for (k = 1; k< n-1; k++) {
+    //DFGLoop: loop
+       C[i][j] += alpha * A[i][k] * B[j][k];
+	  C[i][j] += alpha * B[i][k] * A[j][k];
+
+      C[i][j] += alpha * A[i][k+1] * B[j][k+1];
+	  C[i][j] += alpha * B[i][k+1] * A[j][k+1];
+    }
+
+    return sum;
+}
diff -Nur cgra_me/benchmarks/polybench/syrk/Makefile lisa/cgra_me/benchmarks/polybench/syrk/Makefile
--- cgra_me/benchmarks/polybench/syrk/Makefile	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/syrk/Makefile	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1 @@
+include ../../rules.mk
diff -Nur cgra_me/benchmarks/polybench/syrk/my_graph_loop.dot lisa/cgra_me/benchmarks/polybench/syrk/my_graph_loop.dot
--- cgra_me/benchmarks/polybench/syrk/my_graph_loop.dot	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/syrk/my_graph_loop.dot	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1,31 @@
+digraph G {
+mul0[opcode=mul];
+const1[opcode=const];
+load2[opcode=load];
+mul3[opcode=mul];
+const4[opcode=const];
+mul5[opcode=mul];
+load6[opcode=load];
+const7[opcode=const];
+load8[opcode=load];
+load9[opcode=load];
+add10[opcode=add];
+store11[opcode=store];
+add12[opcode=add];
+const13[opcode=const];
+load2->mul3[operand=0]; //load->mul
+load2->mul5[operand=1]; //load->mul
+mul3->mul5[operand=0]; //mul->mul
+mul5->add10[operand=1]; //mul->add
+load6->load8[operand=0]; //load->load
+load8->load9[operand=0]; //load->load
+load8->store11[operand=1]; //load->store
+load9->add10[operand=0]; //load->add
+add10->store11[operand=0]; //add->store
+add12->mul0[operand=1]; //add->gep_mul
+const1->mul0[operand=0]; //gep_const->gep_mul
+mul0->load2[operand=0]; //gep_mul->load
+const4->mul3[operand=1]; //const->mul
+const7->load6[operand=0]; //const->load
+const13->add12[operand=0]; //const->add
+}
diff -Nur cgra_me/benchmarks/polybench/syrk/syrk.c lisa/cgra_me/benchmarks/polybench/syrk/syrk.c
--- cgra_me/benchmarks/polybench/syrk/syrk.c	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/syrk/syrk.c	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1,20 @@
+#include <stdio.h>
+
+volatile int * N;
+volatile int *a;
+volatile int *b;
+int *c;
+int **A;
+int **C;
+int main() {
+    int i, j ,k, alpha=10;
+    int n = *N;
+
+    int sum = 0;
+    for (k = 1; k < n-1; k++) {
+    //DFGLoop: loop
+        C[i][j] += alpha * A[i][k] * A[j][k];
+    }
+
+    return sum;
+}
diff -Nur cgra_me/benchmarks/polybench/syrk_unroll/Makefile lisa/cgra_me/benchmarks/polybench/syrk_unroll/Makefile
--- cgra_me/benchmarks/polybench/syrk_unroll/Makefile	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/syrk_unroll/Makefile	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1 @@
+include ../../rules.mk
diff -Nur cgra_me/benchmarks/polybench/syrk_unroll/my_graph_loop.dot lisa/cgra_me/benchmarks/polybench/syrk_unroll/my_graph_loop.dot
--- cgra_me/benchmarks/polybench/syrk_unroll/my_graph_loop.dot	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/syrk_unroll/my_graph_loop.dot	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1,50 @@
+digraph G {
+mul0[opcode=mul];
+const1[opcode=const];
+load2[opcode=load];
+mul3[opcode=mul];
+const4[opcode=const];
+mul5[opcode=mul];
+load6[opcode=load];
+const7[opcode=const];
+load8[opcode=load];
+load9[opcode=load];
+add10[opcode=add];
+store11[opcode=store];
+add12[opcode=add];
+const13[opcode=const];
+mul14[opcode=mul];
+const15[opcode=const];
+load16[opcode=load];
+mul17[opcode=mul];
+const18[opcode=const];
+mul19[opcode=mul];
+add20[opcode=add];
+store21[opcode=store];
+load2->mul3[operand=0]; //load->mul
+load2->mul5[operand=1]; //load->mul
+mul3->mul5[operand=0]; //mul->mul
+mul5->add10[operand=1]; //mul->add
+load6->load8[operand=0]; //load->load
+load8->load9[operand=0]; //load->load
+load8->store11[operand=1]; //load->store
+load8->store21[operand=1]; //load->store
+load9->add10[operand=0]; //load->add
+add10->store11[operand=0]; //add->store
+add10->add20[operand=1]; //add->add
+add12->mul14[operand=1]; //add->gep_mul
+add12->mul0[operand=1]; //add->gep_mul
+load16->mul17[operand=0]; //load->mul
+load16->mul19[operand=1]; //load->mul
+mul17->mul19[operand=0]; //mul->mul
+mul19->add20[operand=0]; //mul->add
+add20->store21[operand=0]; //add->store
+const1->mul0[operand=0]; //gep_const->gep_mul
+mul0->load2[operand=0]; //gep_mul->load
+const4->mul3[operand=1]; //const->mul
+const7->load6[operand=0]; //const->load
+const13->add12[operand=1]; //const->add
+const15->mul14[operand=0]; //gep_const->gep_mul
+mul14->load16[operand=0]; //gep_mul->load
+const18->mul17[operand=1]; //const->mul
+}
diff -Nur cgra_me/benchmarks/polybench/syrk_unroll/syrk.c lisa/cgra_me/benchmarks/polybench/syrk_unroll/syrk.c
--- cgra_me/benchmarks/polybench/syrk_unroll/syrk.c	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/syrk_unroll/syrk.c	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1,22 @@
+#include <stdio.h>
+
+volatile int * N;
+volatile int *a;
+volatile int *b;
+int *c;
+int **A;
+int **C;
+int main() {
+    int i, j ,k, alpha=10;
+    int n = *N;
+
+    int sum = 0;
+    for (k = 1; k < n-1; k++) {
+    //DFGLoop: loop
+        C[i][j] += alpha * A[i][k] * A[j][k];
+            C[i][j] += alpha * A[i][k+1] * A[j][k+1];
+
+    }
+
+    return sum;
+}
diff -Nur cgra_me/benchmarks/polybench/trmm/2mm/2mm.c lisa/cgra_me/benchmarks/polybench/trmm/2mm/2mm.c
--- cgra_me/benchmarks/polybench/trmm/2mm/2mm.c	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/trmm/2mm/2mm.c	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1,36 @@
+#include <stdio.h>
+
+volatile int * N;
+volatile int *a;
+volatile int *b;
+int *c;
+int **tmp;
+volatile int **A;
+volatile int **B;
+
+int main() {
+    int i;
+    int j;
+    int k;
+    int alpha = 10;
+    int n = *N;
+
+    int sum = 0;
+
+ 
+    for (k = 1; k < n-1; ++k){
+        //DFGLoop: loop
+        sum += alpha * A[i][k] * B[k][j];
+
+        sum += A[i][k];
+    }
+
+    // for (i = 1; i < n-1; i++) {
+    
+    //     c[i] *= a[i+1] + b[i-1];
+    //     sum += c[i];
+    // }
+
+
+    return sum;
+}
diff -Nur cgra_me/benchmarks/polybench/trmm/2mm/Makefile lisa/cgra_me/benchmarks/polybench/trmm/2mm/Makefile
--- cgra_me/benchmarks/polybench/trmm/2mm/Makefile	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/trmm/2mm/Makefile	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1 @@
+include ../../rules.mk
diff -Nur cgra_me/benchmarks/polybench/trmm/atax/atax.c lisa/cgra_me/benchmarks/polybench/trmm/atax/atax.c
--- cgra_me/benchmarks/polybench/trmm/atax/atax.c	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/trmm/atax/atax.c	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1,34 @@
+#include <stdio.h>
+
+volatile int * N;
+volatile int **A;
+volatile int *y;
+volatile int *tmp;
+int *c;
+
+int main() {
+    int i;
+    int j;
+    int n = *N;
+
+    int sum = 0;
+    for (j = 1; j < n-1; j++) {
+    //DFGLoop: loop
+        y[j] = y[j] + A[i][j] * tmp[i];
+    }
+
+//     #pragma scop
+//   for (i = 0; i < _PB_NY; i++)
+//     y[i] = 0;
+//   for (i = 0; i < _PB_NX; i++)
+//     {
+//       tmp[i] = 0;
+//       for (j = 0; j < _PB_NY; j++)
+// 	tmp[i] = tmp[i] + A[i][j] * x[j];
+//       for (j = 0; j < _PB_NY; j++)
+// 	y[j] = y[j] + A[i][j] * tmp[i];
+//     }
+// #pragma endscop
+
+    return sum;
+}
diff -Nur cgra_me/benchmarks/polybench/trmm/atax/Makefile lisa/cgra_me/benchmarks/polybench/trmm/atax/Makefile
--- cgra_me/benchmarks/polybench/trmm/atax/Makefile	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/trmm/atax/Makefile	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1 @@
+include ../../rules.mk
diff -Nur cgra_me/benchmarks/polybench/trmm/bicg/bicg.c lisa/cgra_me/benchmarks/polybench/trmm/bicg/bicg.c
--- cgra_me/benchmarks/polybench/trmm/bicg/bicg.c	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/trmm/bicg/bicg.c	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1,42 @@
+#include <stdio.h>
+
+volatile int * N;
+volatile int **A;
+volatile int *p;
+volatile int *r;
+volatile int *s;
+volatile int *q;
+
+
+int *c;
+
+int main() {
+    int i;
+    int j;
+    int n = *N;
+
+    int sum = 0;
+    for (j = 1; j < n-1; j++) {
+    //DFGLoop: loop
+        s[j] = s[j] + r[i] * A[i][j];
+	  q[i] = q[i] + A[i][j] * p[j];
+    }
+
+
+// #pragma scop
+//   for (i = 0; i < _PB_NY; i++)
+//     s[i] = 0;
+//   for (i = 0; i < _PB_NX; i++)
+//     {
+//       q[i] = 0;
+//       for (j = 0; j < _PB_NY; j++)
+// 	{
+// 	  s[j] = s[j] + r[i] * A[i][j];
+// 	  q[i] = q[i] + A[i][j] * p[j];
+// 	}
+//     }
+// #pragma endscop
+
+
+    return sum;
+}
diff -Nur cgra_me/benchmarks/polybench/trmm/bicg/Makefile lisa/cgra_me/benchmarks/polybench/trmm/bicg/Makefile
--- cgra_me/benchmarks/polybench/trmm/bicg/Makefile	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/trmm/bicg/Makefile	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1 @@
+include ../../rules.mk
diff -Nur cgra_me/benchmarks/polybench/trmm/cholesky/cholesky.c lisa/cgra_me/benchmarks/polybench/trmm/cholesky/cholesky.c
--- cgra_me/benchmarks/polybench/trmm/cholesky/cholesky.c	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/trmm/cholesky/cholesky.c	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1,44 @@
+#include <stdio.h>
+
+volatile int *N;
+volatile int *a;
+volatile int *b;
+volatile int **A;
+volatile int *p;
+
+int *c;
+
+int main()
+{
+    int i;
+    int n = *N;
+    int _PB_N, x = 1000, j, k;
+
+    int sum = 0;
+    x = 100;
+    A[0][0] = 1;
+    for (k = 1; k < n - 1; k++)
+    {
+        //DFGLoop: loop
+        x = x - A[j][k] * A[i][k];
+    }
+
+    for (i = 0; i < _PB_N; ++i)
+    {
+        x = A[i][i];
+        for (j = 0; j <= i - 1; ++j)
+            x = x - A[i][j] * A[i][j];
+        p[i] = x;
+        for (j = i + 1; j < _PB_N; ++j)
+        {
+            x = A[i][j];
+            for (k = 0; k <= i - 1; ++k)
+            {
+                x = x - A[j][k] * A[i][k];
+            }
+            A[j][i] = x * p[i];
+        }
+    }
+
+    return x;
+}
diff -Nur cgra_me/benchmarks/polybench/trmm/cholesky/Makefile lisa/cgra_me/benchmarks/polybench/trmm/cholesky/Makefile
--- cgra_me/benchmarks/polybench/trmm/cholesky/Makefile	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/trmm/cholesky/Makefile	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1 @@
+include ../../rules.mk
diff -Nur cgra_me/benchmarks/polybench/trmm/doitgen/doitgen.c lisa/cgra_me/benchmarks/polybench/trmm/doitgen/doitgen.c
--- cgra_me/benchmarks/polybench/trmm/doitgen/doitgen.c	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/trmm/doitgen/doitgen.c	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1,39 @@
+#include <stdio.h>
+
+volatile int * N;
+volatile int *a;
+volatile int *b;
+volatile int ***sum;
+volatile int ***A;
+volatile int **C4;
+
+int *c;
+
+int main() {
+    int i;
+    int n = *N;
+    int r;
+    int  p, q, s;
+    int _PB_NR, _PB_NQ, _PB_NP;
+
+    // int sum = 0;
+    for (s = 1; s < n-1; s++) {
+    //DFGLoop: loop
+         sum[r][q][p] = sum[r][q][p] + A[r][q][s] * C4[s][p];
+    }
+
+//     #pragma scop
+//   for (r = 0; r < _PB_NR; r++)
+//     for (q = 0; q < _PB_NQ; q++)  {
+//       for (p = 0; p < _PB_NP; p++)  {
+// 	sum[r][q][p] = 0;
+// 	for (s = 0; s < _PB_NP; s++)
+// 	  sum[r][q][p] = sum[r][q][p] + A[r][q][s] * C4[s][p];
+//       }
+//       for (p = 0; p < _PB_NR; p++)
+// 	A[r][q][p] = sum[r][q][p];
+//     }
+// #pragma endscop
+
+    return 0;
+}
diff -Nur cgra_me/benchmarks/polybench/trmm/doitgen/Makefile lisa/cgra_me/benchmarks/polybench/trmm/doitgen/Makefile
--- cgra_me/benchmarks/polybench/trmm/doitgen/Makefile	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/trmm/doitgen/Makefile	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1 @@
+include ../../rules.mk
diff -Nur cgra_me/benchmarks/polybench/trmm/gemm/gemm.c lisa/cgra_me/benchmarks/polybench/trmm/gemm/gemm.c
--- cgra_me/benchmarks/polybench/trmm/gemm/gemm.c	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/trmm/gemm/gemm.c	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1,36 @@
+#include <stdio.h>
+
+volatile int * N;
+volatile int *a;
+volatile int *b;
+int *c;
+volatile int **A;
+volatile int **B;
+volatile int **C;
+
+
+int main() {
+    int i, j, k;
+    int n = *N;
+    int alpha = 20;
+    int tmp;
+
+    int sum = 0;
+    for (k = 1; k < n-1; k++) {
+     //DFGLoop: loop
+     tmp = alpha * A[i][k];
+     tmp = tmp * B[k][j];
+         C[i][j] += tmp ;
+    }
+
+     /* C := alpha*A*B + beta*C */
+//   for (i = 0; i < _PB_NI; i++)
+//     for (j = 0; j < _PB_NJ; j++)
+//       {
+// 	C[i][j] *= beta;
+// 	for (k = 0; k < _PB_NK; ++k)
+// 	  C[i][j] += alpha * A[i][k] * B[k][j];
+//       }
+
+    return sum;
+}
diff -Nur cgra_me/benchmarks/polybench/trmm/gemm/Makefile lisa/cgra_me/benchmarks/polybench/trmm/gemm/Makefile
--- cgra_me/benchmarks/polybench/trmm/gemm/Makefile	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/trmm/gemm/Makefile	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1 @@
+include ../../rules.mk
diff -Nur cgra_me/benchmarks/polybench/trmm/gemver/gemver.c lisa/cgra_me/benchmarks/polybench/trmm/gemver/gemver.c
--- cgra_me/benchmarks/polybench/trmm/gemver/gemver.c	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/trmm/gemver/gemver.c	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1,26 @@
+#include <stdio.h>
+
+volatile int * N;
+volatile int *a;
+volatile int *b;
+volatile int **A;
+volatile int *u1;
+volatile int *v1;
+volatile int *u2;
+volatile int *v2;
+
+int *c;
+
+int main() {
+    int i,j;
+    int n = *N;
+
+    int sum = 0;
+    for (j = 1; j < n-1; j++) {
+    //DFGLoop: loop
+        A[i][j] = A[i][j] + u1[i] * v1[j] + u2[i] * v2[j];
+
+    }
+
+    return sum;
+}
diff -Nur cgra_me/benchmarks/polybench/trmm/gemver/Makefile lisa/cgra_me/benchmarks/polybench/trmm/gemver/Makefile
--- cgra_me/benchmarks/polybench/trmm/gemver/Makefile	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/trmm/gemver/Makefile	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1 @@
+include ../../rules.mk
diff -Nur cgra_me/benchmarks/polybench/trmm/gesummv/gesummv.c lisa/cgra_me/benchmarks/polybench/trmm/gesummv/gesummv.c
--- cgra_me/benchmarks/polybench/trmm/gesummv/gesummv.c	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/trmm/gesummv/gesummv.c	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1,24 @@
+#include <stdio.h>
+
+volatile int * N;
+volatile int *a;
+volatile int *b;
+int *c;
+int **A;
+int *tmp;
+int *x;
+int *y;
+int **B;
+int main() {
+    int i,j;
+    int n = *N;
+
+    int sum = 0;
+    for (j = 1; j < n-1; j++) {
+    //DFGLoop: loop
+        tmp[i] = A[i][j] * x[j] + tmp[i];
+	  y[i] = B[i][j] * x[j] + y[i];
+    }
+
+    return sum;
+}
diff -Nur cgra_me/benchmarks/polybench/trmm/gesummv/Makefile lisa/cgra_me/benchmarks/polybench/trmm/gesummv/Makefile
--- cgra_me/benchmarks/polybench/trmm/gesummv/Makefile	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/trmm/gesummv/Makefile	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1 @@
+include ../../rules.mk
diff -Nur cgra_me/benchmarks/polybench/trmm/Makefile lisa/cgra_me/benchmarks/polybench/trmm/Makefile
--- cgra_me/benchmarks/polybench/trmm/Makefile	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/trmm/Makefile	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1 @@
+include ../../rules.mk
diff -Nur cgra_me/benchmarks/polybench/trmm/mvt/Makefile lisa/cgra_me/benchmarks/polybench/trmm/mvt/Makefile
--- cgra_me/benchmarks/polybench/trmm/mvt/Makefile	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/trmm/mvt/Makefile	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1 @@
+include ../../rules.mk
diff -Nur cgra_me/benchmarks/polybench/trmm/mvt/mvt.c lisa/cgra_me/benchmarks/polybench/trmm/mvt/mvt.c
--- cgra_me/benchmarks/polybench/trmm/mvt/mvt.c	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/trmm/mvt/mvt.c	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1,22 @@
+#include <stdio.h>
+
+volatile int * N;
+volatile int *a;
+volatile int *b;
+int *c;
+int *x2;
+int **A;
+int *y_2;
+
+int main() {
+    int i,j;
+    int n = *N;
+
+    int sum = 0;
+    for (j = 1; j < n-1; j++) {
+    //DFGLoop: loop
+        x2[i] = x2[i] + A[j][i] * y_2[j];
+    }
+
+    return sum;
+}
diff -Nur cgra_me/benchmarks/polybench/trmm/my_graph_loop.dot lisa/cgra_me/benchmarks/polybench/trmm/my_graph_loop.dot
--- cgra_me/benchmarks/polybench/trmm/my_graph_loop.dot	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/trmm/my_graph_loop.dot	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1,41 @@
+digraph G {
+mul0[opcode=mul];
+const1[opcode=const];
+load2[opcode=load];
+load3[opcode=load];
+mul4[opcode=mul];
+const5[opcode=const];
+load6[opcode=load];
+const7[opcode=const];
+load8[opcode=load];
+load9[opcode=load];
+mul10[opcode=mul];
+mul11[opcode=mul];
+const12[opcode=const];
+load13[opcode=load];
+load14[opcode=load];
+add15[opcode=add];
+store16[opcode=store];
+add17[opcode=add];
+const18[opcode=const];
+load2->load3[operand=0]; //load->load
+load3->mul4[operand=0]; //load->mul
+mul4->mul10[operand=0]; //mul->mul
+load6->load8[operand=0]; //load->load
+load8->load9[operand=0]; //load->load
+load9->mul10[operand=1]; //load->mul
+mul10->add15[operand=1]; //mul->add
+load13->load14[operand=0]; //load->load
+load13->store16[operand=1]; //load->store
+load14->add15[operand=0]; //load->add
+add15->store16[operand=0]; //add->store
+add17->mul0[operand=1]; //add->gep_mul
+add17->mul11[operand=1]; //add->gep_mul
+const1->mul0[operand=0]; //gep_const->gep_mul
+mul0->load2[operand=0]; //gep_mul->load
+const5->mul4[operand=1]; //const->mul
+const7->load6[operand=0]; //const->load
+const12->mul11[operand=0]; //gep_const->gep_mul
+mul11->load13[operand=0]; //gep_mul->load
+const18->add17[operand=0]; //const->add
+}
diff -Nur cgra_me/benchmarks/polybench/trmm/symm/Makefile lisa/cgra_me/benchmarks/polybench/trmm/symm/Makefile
--- cgra_me/benchmarks/polybench/trmm/symm/Makefile	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/trmm/symm/Makefile	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1 @@
+include ../../rules.mk
diff -Nur cgra_me/benchmarks/polybench/trmm/symm/symm.c lisa/cgra_me/benchmarks/polybench/trmm/symm/symm.c
--- cgra_me/benchmarks/polybench/trmm/symm/symm.c	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/trmm/symm/symm.c	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1,22 @@
+#include <stdio.h>
+
+volatile int * N;
+volatile int *a;
+volatile int *b;
+int **A;
+int **B;
+int **C;
+
+int main() {
+    int i, j, k, alpha = 1, acc = 100;
+    int n = *N;
+
+    int sum = 0;
+    for (k = 1; k < n-1; k++) {
+    //DFGLoop: loop
+         C[k][j] += alpha * A[k][i] * B[i][j];
+	    acc += B[k][j] * A[k][i];
+    }
+
+    return sum;
+}
diff -Nur cgra_me/benchmarks/polybench/trmm/syr2k/Makefile lisa/cgra_me/benchmarks/polybench/trmm/syr2k/Makefile
--- cgra_me/benchmarks/polybench/trmm/syr2k/Makefile	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/trmm/syr2k/Makefile	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1 @@
+include ../../rules.mk
diff -Nur cgra_me/benchmarks/polybench/trmm/syr2k/syr2k.c lisa/cgra_me/benchmarks/polybench/trmm/syr2k/syr2k.c
--- cgra_me/benchmarks/polybench/trmm/syr2k/syr2k.c	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/trmm/syr2k/syr2k.c	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1,22 @@
+#include <stdio.h>
+
+volatile int * N;
+volatile int *a;
+volatile int *b;
+int *c;
+int **A;
+int **B;
+int **C;
+int main() {
+    int i, j, k, alpha = 2;
+    int n = *N;
+
+    int sum = 0;
+    for (k = 1; k< n-1; k++) {
+    //DFGLoop: loop
+       C[i][j] += alpha * A[i][k] * B[j][k];
+	  C[i][j] += alpha * B[i][k] * A[j][k];
+    }
+
+    return sum;
+}
diff -Nur cgra_me/benchmarks/polybench/trmm/syrk/Makefile lisa/cgra_me/benchmarks/polybench/trmm/syrk/Makefile
--- cgra_me/benchmarks/polybench/trmm/syrk/Makefile	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/trmm/syrk/Makefile	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1 @@
+include ../../rules.mk
diff -Nur cgra_me/benchmarks/polybench/trmm/syrk/syrk.c lisa/cgra_me/benchmarks/polybench/trmm/syrk/syrk.c
--- cgra_me/benchmarks/polybench/trmm/syrk/syrk.c	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/trmm/syrk/syrk.c	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1,20 @@
+#include <stdio.h>
+
+volatile int * N;
+volatile int *a;
+volatile int *b;
+int *c;
+int **A;
+int **C;
+int main() {
+    int i, j ,k, alpha=10;
+    int n = *N;
+
+    int sum = 0;
+    for (k = 1; k < n-1; k++) {
+    //DFGLoop: loop
+        C[i][j] += alpha * A[i][k] * A[j][k];
+    }
+
+    return sum;
+}
diff -Nur cgra_me/benchmarks/polybench/trmm/trmm.c lisa/cgra_me/benchmarks/polybench/trmm/trmm.c
--- cgra_me/benchmarks/polybench/trmm/trmm.c	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/trmm/trmm.c	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1,22 @@
+#include <stdio.h>
+
+volatile int * N;
+volatile int *a;
+volatile int *b;
+int *c;
+int **B;
+int **A;
+
+
+int main() {
+    int i, j, k, alpha = 5;
+    int n = *N;
+
+    int sum = 0;
+    for (i = 1; i < n-1; i++) {
+    //DFGLoop: loop
+        B[i][j] += alpha * A[i][k] * B[j][k];
+    }
+
+    return sum;
+}
diff -Nur cgra_me/benchmarks/polybench/trmm_unroll/Makefile lisa/cgra_me/benchmarks/polybench/trmm_unroll/Makefile
--- cgra_me/benchmarks/polybench/trmm_unroll/Makefile	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/trmm_unroll/Makefile	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1 @@
+include ../../rules.mk
diff -Nur cgra_me/benchmarks/polybench/trmm_unroll/my_graph_loop.dot lisa/cgra_me/benchmarks/polybench/trmm_unroll/my_graph_loop.dot
--- cgra_me/benchmarks/polybench/trmm_unroll/my_graph_loop.dot	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/trmm_unroll/my_graph_loop.dot	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1,72 @@
+digraph G {
+mul0[opcode=mul];
+const1[opcode=const];
+load2[opcode=load];
+load3[opcode=load];
+mul4[opcode=mul];
+const5[opcode=const];
+load6[opcode=load];
+const7[opcode=const];
+load8[opcode=load];
+load9[opcode=load];
+mul10[opcode=mul];
+mul11[opcode=mul];
+const12[opcode=const];
+load13[opcode=load];
+load14[opcode=load];
+add15[opcode=add];
+store16[opcode=store];
+add17[opcode=add];
+const18[opcode=const];
+mul19[opcode=mul];
+const20[opcode=const];
+load21[opcode=load];
+load22[opcode=load];
+mul23[opcode=mul];
+const24[opcode=const];
+load25[opcode=load];
+mul26[opcode=mul];
+mul27[opcode=mul];
+const28[opcode=const];
+load29[opcode=load];
+load30[opcode=load];
+add31[opcode=add];
+store32[opcode=store];
+load2->load3[operand=0]; //load->load
+load3->mul4[operand=0]; //load->mul
+mul4->mul10[operand=0]; //mul->mul
+load6->load8[operand=0]; //load->load
+load8->load9[operand=0]; //load->load
+load8->load25[operand=0]; //load->load
+load9->mul10[operand=1]; //load->mul
+mul10->add15[operand=1]; //mul->add
+load13->load14[operand=0]; //load->load
+load13->store16[operand=1]; //load->store
+load14->add15[operand=0]; //load->add
+add15->store16[operand=0]; //add->store
+add17->mul19[operand=1]; //add->gep_mul
+add17->mul27[operand=1]; //add->gep_mul
+add17->mul0[operand=1]; //add->gep_mul
+add17->mul11[operand=1]; //add->gep_mul
+load21->load22[operand=0]; //load->load
+load22->mul23[operand=0]; //load->mul
+mul23->mul26[operand=0]; //mul->mul
+load25->mul26[operand=1]; //load->mul
+mul26->add31[operand=1]; //mul->add
+load29->load30[operand=0]; //load->load
+load29->store32[operand=1]; //load->store
+load30->add31[operand=0]; //load->add
+add31->store32[operand=0]; //add->store
+const1->mul0[operand=0]; //gep_const->gep_mul
+mul0->load2[operand=0]; //gep_mul->load
+const5->mul4[operand=1]; //const->mul
+const7->load6[operand=0]; //const->load
+const12->mul11[operand=0]; //gep_const->gep_mul
+mul11->load13[operand=0]; //gep_mul->load
+const18->add17[operand=1]; //const->add
+const20->mul19[operand=0]; //gep_const->gep_mul
+mul19->load21[operand=0]; //gep_mul->load
+const24->mul23[operand=1]; //const->mul
+const28->mul27[operand=0]; //gep_const->gep_mul
+mul27->load29[operand=0]; //gep_mul->load
+}
diff -Nur cgra_me/benchmarks/polybench/trmm_unroll/trmm.c lisa/cgra_me/benchmarks/polybench/trmm_unroll/trmm.c
--- cgra_me/benchmarks/polybench/trmm_unroll/trmm.c	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/benchmarks/polybench/trmm_unroll/trmm.c	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1,24 @@
+#include <stdio.h>
+
+volatile int * N;
+volatile int *a;
+volatile int *b;
+int *c;
+int **B;
+int **A;
+
+
+int main() {
+    int i, j, k, alpha = 5;
+    int n = *N;
+
+    int sum = 0;
+    for (i = 1; i < n-1; i++) {
+    //DFGLoop: loop
+        B[i][j] += alpha * A[i][k] * B[j][k];
+        B[i+1][j] += alpha * A[i+1][k] * B[j][k];
+
+    }
+
+    return sum;
+}
diff -Nur cgra_me/call_gnn.sh lisa/cgra_me/call_gnn.sh
--- cgra_me/call_gnn.sh	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/call_gnn.sh	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1,4 @@
+cd ${LISA_DIR}/lisa_gnn/lisa_gnn_model
+# conda init bash
+# conda activate lisa
+python gnn_inference.py $1 $2 
diff -Nur cgra_me/cgrame_env lisa/cgra_me/cgrame_env
--- cgra_me/cgrame_env	2018-05-09 09:34:57.000000000 +0800
+++ lisa/cgra_me/cgrame_env	2022-02-28 16:37:25.908775556 +0800
@@ -17,6 +17,7 @@
 fi
 
 export CGRA_ME_ROOTDIR="$(readlink --canonicalize "$PWD")/";
+export LISA_DIR="$(dirname "$CGRA_ME_ROOTDIR")";
 export CGRA_ME_BINDIR="$CGRA_ME_ROOTDIR/build/bin/";
 export CGRA_ME_LIBDIR="$CGRA_ME_ROOTDIR/build/lib/";
 export CGRA_ME_SCRIPTSDIR="$CGRA_ME_ROOTDIR/build/script/";
@@ -27,6 +28,7 @@
 
 export CGRA_MAPPER="cgrame"
 
+echo "lisa: $LISA_DIR"
 echo "Entering $SHELL_EXE with setup environment. CGRA_ME_ROOTDIR=$CGRA_ME_ROOTDIR";
 $SHELL_EXE
 echo "Exiting environment. Old CGRA_ME_ROOTDIR=$CGRA_ME_ROOTDIR";
diff -Nur cgra_me/figs/.gitignore lisa/cgra_me/figs/.gitignore
--- cgra_me/figs/.gitignore	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/figs/.gitignore	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1,4 @@
+# Ignore everything in this directory
+*
+# Except this file
+!.gitignore
diff -Nur cgra_me/get_compilation_time.py lisa/cgra_me/get_compilation_time.py
--- cgra_me/get_compilation_time.py	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/get_compilation_time.py	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1,169 @@
+import os, sys
+import numpy as np
+import matplotlib.pyplot as plt
+
+stat_file_name = "result.txt"
+if len(sys.argv) >1:
+  stat_file_name = sys.argv[1]
+
+file1 = open(stat_file_name, 'r')
+Lines = file1.readlines()
+raw_stat = {}
+
+# methods  = [ "ILP",  "SA","t-LISA", "LISA", "gnn-LISA"]
+methods  = [ "MII", "ILP",  "SA",   "LISA"]
+# methods  = ["MII", "ILP",  "SA",  "LISA"]
+colors = ['b', 'r', 'g', 'c', 'm', 'y', 'k']
+methods_index  = {}
+
+index = 0
+for method in methods:
+  methods_index[method] = index
+  index += 1
+
+drawing_method_name = {}
+drawing_method_name["ILP"] = 0
+drawing_method_name["SA"] = 1
+drawing_method_name["LISA"] =  2
+
+def generate_latex_data(filename, dfgs, data):
+  print("dfgs",dfgs)
+
+  print("data", data)
+  output_filename = filename + ".txt"
+  data_file = open(output_filename, "w")
+  data_file.write("Benchmark")
+
+  for method in methods_index.keys():
+    if method in drawing_method_name.keys():
+      data_file.write("\t" + method)
+  data_file.write("\n")
+  for i in range(len(dfgs)):
+    data_file.write("{\em " +dfgs[i]+"}")
+    for method in methods_index.keys():
+      if method in drawing_method_name.keys():
+        method_index = methods_index[method]
+
+        data_file.write("\t" + str(data[method_index][i]))
+    data_file.write("\n")
+
+
+  
+
+def draw_graph(filename, dfgs, data):
+  plt.rcParams.update({'font.size': 16})
+  print("filename", filename)
+  bar_width = 0.1
+  plt.figure(figsize=(20,10))
+  index_start = np.arange(len(dfgs)) 
+  print("dfgs",dfgs)
+  print("data", data)
+  for method in methods_index.keys():
+    if method in drawing_method_name.keys():
+      method_index = methods_index[method]
+      draw_index = drawing_method_name[method]
+      plt.bar(index_start + draw_index * bar_width, height=data[method_index], width=bar_width, color=colors[draw_index], label=method)
+
+
+  plt.legend() 
+  plt.xticks(index_start + bar_width/2, dfgs) 
+  plt.ylabel('II')  
+  plt.title('performance')
+  plt.show()
+  output_filename = filename+'.png'
+  if os.path.isfile(output_filename):
+   os.remove(output_filename)
+  plt.savefig(output_filename, dpi=200)
+  plt.clf()
+
+
+
+
+for line in Lines:
+  if line.startswith('#'):
+    continue
+  data = line.split()
+  if len(data) < 4:
+    continue
+  # print(data)
+  method = data[2]
+  MII_ = data[3]
+  II_ = data[4]
+  compilation_time = data[5]
+
+  arch_name = data[0]
+  dfg_name = data[1]
+  if arch_name not in raw_stat.keys():
+    raw_stat[arch_name] = {}
+
+  if data[1] not in raw_stat[data[0]]:
+    raw_stat[arch_name][dfg_name] = {}
+  raw_stat[arch_name][dfg_name][method] = int(compilation_time)
+  # print(dfg_name, method,compilation_time)
+ 
+  
+for arch_name, each_arch_stat in raw_stat.items():
+  data = []
+  arch_filename = arch_name[arch_name.rfind("/")+1:-4]
+  unroll_dfg  =0
+  no_unroll_dfg = 0
+  for dfg_name, perf in each_arch_stat.items():
+    if "unroll" in dfg_name:
+      unroll_dfg += 1
+    else :
+      no_unroll_dfg += 1
+
+  for i in range(0, len(methods_index)):
+    temp = [0] * no_unroll_dfg
+    data.append(temp)
+  dfgs = []
+  dfg_index = 0
+  
+  for dfg_name, perf in each_arch_stat.items():
+    dfg_name  = dfg_name[0:dfg_name.rfind('/')]
+    dfg_name = dfg_name[dfg_name.rfind('/')+1:]
+    if "unroll" in dfg_name:
+      continue
+    dfgs.append(dfg_name)
+    for method_,compilation_time in perf.items():
+     
+
+      if method_ not in methods_index.keys():
+        print(method_)
+        # data[method_index["LISA"]][dfg_index] = II 
+        assert(False)
+      else:
+        # print(method_, compilation_time)
+        data[methods_index[method_]][dfg_index] = compilation_time
+    dfg_index = dfg_index + 1
+  arch_filename = arch_name[arch_name.rfind("/")+1:-4]
+  arch_filename = arch_filename.replace("arch-homo-orth_", "")
+
+  draw_graph("figs/compilation_time/"+arch_filename,dfgs, data)
+  generate_latex_data("figs/compilation_time/"+arch_filename,dfgs, data)
+  dfgs = []
+  dfg_index = 0
+  data = []
+ 
+  for i in range(0, len(methods_index)):
+    temp = [0] * unroll_dfg
+    data.append(temp)
+  
+  for dfg_name, perf in each_arch_stat.items():
+    dfg_name  = dfg_name[0:dfg_name.rfind('/')]
+    dfg_name = dfg_name[dfg_name.rfind('/')+1:]
+    if "unroll" not in dfg_name:
+      continue
+
+    dfgs.append(dfg_name)
+    for method_,compilation_time in perf.items():
+     
+      if method_ not in methods_index.keys():
+        print(method_)
+        # data[method_index["LISA"]][dfg_index] = compilation_time 
+        assert(False)
+      else:
+        data[methods_index[method_]][dfg_index] = compilation_time 
+    dfg_index = dfg_index + 1
+  draw_graph("figs/compilation_time/"+arch_filename+"_unroll",dfgs, data)
+  generate_latex_data("figs/compilation_time/"+arch_filename+"_unroll",dfgs, data)
\ No newline at end of file
diff -Nur cgra_me/get_stat.py lisa/cgra_me/get_stat.py
--- cgra_me/get_stat.py	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/get_stat.py	2022-02-28 16:37:25.908775556 +0800
@@ -0,0 +1,178 @@
+import os, sys
+import numpy as np
+import matplotlib.pyplot as plt
+
+stat_file_name = "result.txt"
+if len(sys.argv) >1:
+  stat_file_name = sys.argv[1]
+
+
+output_filename_prefix = "figs/"
+if "routing_priority" in stat_file_name:
+  output_filename_prefix = "figs/routing_priority/"
+file1 = open(stat_file_name, 'r')
+Lines = file1.readlines()
+raw_stat = {}
+
+# methods  = [ "ILP",  "SA","t-LISA", "LISA", "gnn-LISA"]
+methods  = [ "MII", "ILP",  "SA",   "LISA"]
+# methods  = ["MII", "ILP",  "SA",  "LISA"]
+colors = ['b', 'r', 'g', 'c', 'm', 'y', 'k']
+methods_index  = {}
+
+index = 0
+for method in methods:
+  methods_index[method] = index
+  index += 1
+
+drawing_method_name = {}
+drawing_method_name["ILP"] = 0
+drawing_method_name["SA"] = 1
+drawing_method_name["LISA"] =  2
+
+def generate_latex_data(filename, dfgs, data):
+  print("dfgs",dfgs)
+
+  print("data", data)
+  output_filename = filename + ".txt"
+  data_file = open(output_filename, "w")
+  data_file.write("Benchmark")
+
+  for method in methods_index.keys():
+    if method in drawing_method_name.keys():
+      data_file.write("\t" + method)
+  data_file.write("\n")
+  for i in range(len(dfgs)):
+    data_file.write("{\em " +dfgs[i]+"}")
+    for method in methods_index.keys():
+      if method in drawing_method_name.keys():
+        method_index = methods_index[method]
+
+        data_file.write("\t" + str(data[method_index][i]))
+    data_file.write("\n")
+
+
+  
+
+def draw_graph(filename, dfgs, data):
+  plt.rcParams.update({'font.size': 16})
+  print("filename", filename)
+  bar_width = 0.1
+  plt.figure(figsize=(20,10))
+  index_start = np.arange(len(dfgs)) 
+  print("dfgs",dfgs)
+  print("data", data)
+  for method in methods_index.keys():
+    if method in drawing_method_name.keys():
+      method_index = methods_index[method]
+      draw_index = drawing_method_name[method]
+      plt.bar(index_start + draw_index * bar_width, height=data[method_index], width=bar_width, color=colors[draw_index], label=method)
+
+
+  plt.legend() 
+  plt.xticks(index_start + bar_width/2, dfgs) 
+  plt.ylabel('II')  
+  plt.title('performance')
+  plt.show()
+  output_filename = filename+'.png'
+  if os.path.isfile(output_filename):
+   os.remove(output_filename)
+  plt.savefig(output_filename, dpi=200)
+  plt.clf()
+
+
+
+
+for line in Lines:
+  if line.startswith('#'):
+    continue
+  data = line.split()
+  if len(data) < 4:
+    continue
+  # print(data)
+  method = data[2]
+  MII_ = data[3]
+  II_ = data[4]
+  if II_ == 25:
+    II_ = 0
+  arch_name = data[0]
+  dfg_name = data[1]
+  if arch_name not in raw_stat.keys():
+    raw_stat[arch_name] = {}
+
+  if data[1] not in raw_stat[data[0]]:
+    raw_stat[arch_name][dfg_name] = {}
+  raw_stat[arch_name][dfg_name][method] = int(II_)
+  raw_stat[arch_name][dfg_name]["MII"] = int(MII_)
+  
+for arch_name, each_arch_stat in raw_stat.items():
+  data = []
+  arch_filename = arch_name[arch_name.rfind("/")+1:-4]
+  unroll_dfg  =0
+  no_unroll_dfg = 0
+  for dfg_name, perf in each_arch_stat.items():
+    if "unroll" in dfg_name:
+      unroll_dfg += 1
+    else :
+      no_unroll_dfg += 1
+
+  for i in range(0, len(methods_index)):
+    temp = [0] * no_unroll_dfg
+    data.append(temp)
+  dfgs = []
+  dfg_index = 0
+  
+  for dfg_name, perf in each_arch_stat.items():
+    dfg_name  = dfg_name[0:dfg_name.rfind('/')]
+    dfg_name = dfg_name[dfg_name.rfind('/')+1:]
+    if "unroll" in dfg_name:
+      continue
+    dfgs.append(dfg_name)
+    for method_,II in perf.items():
+      if II == 25:
+        II = 0
+      if "systolic" in arch_filename and II == 2:
+        II =0
+
+      if method_ not in methods_index.keys():
+        print(method_)
+        # data[method_index["LISA"]][dfg_index] = II 
+        # assert(False)
+      else:
+        data[methods_index[method_]][dfg_index] = II 
+    dfg_index = dfg_index + 1
+  arch_filename = arch_name[arch_name.rfind("/")+1:-4]
+  arch_filename = arch_filename.replace("arch-homo-orth_", "")
+
+  draw_graph(output_filename_prefix+arch_filename,dfgs, data)
+  generate_latex_data(output_filename_prefix+arch_filename,dfgs, data)
+  dfgs = []
+  dfg_index = 0
+  data = []
+ 
+  for i in range(0, len(methods_index)):
+    temp = [0] * unroll_dfg
+    data.append(temp)
+  
+  for dfg_name, perf in each_arch_stat.items():
+    dfg_name  = dfg_name[0:dfg_name.rfind('/')]
+    dfg_name = dfg_name[dfg_name.rfind('/')+1:]
+    if "unroll" not in dfg_name:
+      continue
+
+    dfgs.append(dfg_name)
+    for method_,II in perf.items():
+      if II == 25:
+        II = 0
+      if "systolic" in arch_filename and II == 2:
+        II =0
+
+      if method_ not in methods_index.keys():
+        print(method_)
+        # data[method_index["LISA"]][dfg_index] = II 
+        # assert(False)
+      else:
+        data[methods_index[method_]][dfg_index] = II 
+    dfg_index = dfg_index + 1
+  draw_graph(output_filename_prefix+arch_filename+"_unroll",dfgs, data)
+  generate_latex_data(output_filename_prefix+arch_filename+"_unroll",dfgs, data)
\ No newline at end of file
diff -Nur cgra_me/.git/config lisa/cgra_me/.git/config
--- cgra_me/.git/config	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/.git/config	2022-02-28 16:37:25.868775474 +0800
@@ -0,0 +1,11 @@
+[core]
+	repositoryformatversion = 0
+	filemode = true
+	bare = false
+	logallrefupdates = true
+[remote "origin"]
+	url = https://github.com/zhaoying-LI/cgra_me.git
+	fetch = +refs/heads/*:refs/remotes/origin/*
+[branch "master"]
+	remote = origin
+	merge = refs/heads/master
diff -Nur cgra_me/.git/description lisa/cgra_me/.git/description
--- cgra_me/.git/description	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/.git/description	2022-02-28 16:37:23.636770869 +0800
@@ -0,0 +1 @@
+Unnamed repository; edit this file 'description' to name the repository.
diff -Nur cgra_me/.git/HEAD lisa/cgra_me/.git/HEAD
--- cgra_me/.git/HEAD	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/.git/HEAD	2022-02-28 16:37:25.864775466 +0800
@@ -0,0 +1 @@
+ref: refs/heads/master
diff -Nur cgra_me/.git/hooks/applypatch-msg.sample lisa/cgra_me/.git/hooks/applypatch-msg.sample
--- cgra_me/.git/hooks/applypatch-msg.sample	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/.git/hooks/applypatch-msg.sample	2022-02-28 16:37:23.636770869 +0800
@@ -0,0 +1,15 @@
+#!/bin/sh
+#
+# An example hook script to check the commit log message taken by
+# applypatch from an e-mail message.
+#
+# The hook should exit with non-zero status after issuing an
+# appropriate message if it wants to stop the commit.  The hook is
+# allowed to edit the commit message file.
+#
+# To enable this hook, rename this file to "applypatch-msg".
+
+. git-sh-setup
+commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
+test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
+:
diff -Nur cgra_me/.git/hooks/commit-msg.sample lisa/cgra_me/.git/hooks/commit-msg.sample
--- cgra_me/.git/hooks/commit-msg.sample	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/.git/hooks/commit-msg.sample	2022-02-28 16:37:23.636770869 +0800
@@ -0,0 +1,24 @@
+#!/bin/sh
+#
+# An example hook script to check the commit log message.
+# Called by "git commit" with one argument, the name of the file
+# that has the commit message.  The hook should exit with non-zero
+# status after issuing an appropriate message if it wants to stop the
+# commit.  The hook is allowed to edit the commit message file.
+#
+# To enable this hook, rename this file to "commit-msg".
+
+# Uncomment the below to add a Signed-off-by line to the message.
+# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
+# hook is more suited to it.
+#
+# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
+
+# This example catches duplicate Signed-off-by lines.
+
+test "" = "$(grep '^Signed-off-by: ' "$1" |
+	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
+	echo >&2 Duplicate Signed-off-by lines.
+	exit 1
+}
diff -Nur cgra_me/.git/hooks/fsmonitor-watchman.sample lisa/cgra_me/.git/hooks/fsmonitor-watchman.sample
--- cgra_me/.git/hooks/fsmonitor-watchman.sample	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/.git/hooks/fsmonitor-watchman.sample	2022-02-28 16:37:23.636770869 +0800
@@ -0,0 +1,173 @@
+#!/usr/bin/perl
+
+use strict;
+use warnings;
+use IPC::Open2;
+
+# An example hook script to integrate Watchman
+# (https://facebook.github.io/watchman/) with git to speed up detecting
+# new and modified files.
+#
+# The hook is passed a version (currently 2) and last update token
+# formatted as a string and outputs to stdout a new update token and
+# all files that have been modified since the update token. Paths must
+# be relative to the root of the working tree and separated by a single NUL.
+#
+# To enable this hook, rename this file to "query-watchman" and set
+# 'git config core.fsmonitor .git/hooks/query-watchman'
+#
+my ($version, $last_update_token) = @ARGV;
+
+# Uncomment for debugging
+# print STDERR "$0 $version $last_update_token\n";
+
+# Check the hook interface version
+if ($version ne 2) {
+	die "Unsupported query-fsmonitor hook version '$version'.\n" .
+	    "Falling back to scanning...\n";
+}
+
+my $git_work_tree = get_working_dir();
+
+my $retry = 1;
+
+my $json_pkg;
+eval {
+	require JSON::XS;
+	$json_pkg = "JSON::XS";
+	1;
+} or do {
+	require JSON::PP;
+	$json_pkg = "JSON::PP";
+};
+
+launch_watchman();
+
+sub launch_watchman {
+	my $o = watchman_query();
+	if (is_work_tree_watched($o)) {
+		output_result($o->{clock}, @{$o->{files}});
+	}
+}
+
+sub output_result {
+	my ($clockid, @files) = @_;
+
+	# Uncomment for debugging watchman output
+	# open (my $fh, ">", ".git/watchman-output.out");
+	# binmode $fh, ":utf8";
+	# print $fh "$clockid\n@files\n";
+	# close $fh;
+
+	binmode STDOUT, ":utf8";
+	print $clockid;
+	print "\0";
+	local $, = "\0";
+	print @files;
+}
+
+sub watchman_clock {
+	my $response = qx/watchman clock "$git_work_tree"/;
+	die "Failed to get clock id on '$git_work_tree'.\n" .
+		"Falling back to scanning...\n" if $? != 0;
+
+	return $json_pkg->new->utf8->decode($response);
+}
+
+sub watchman_query {
+	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
+	or die "open2() failed: $!\n" .
+	"Falling back to scanning...\n";
+
+	# In the query expression below we're asking for names of files that
+	# changed since $last_update_token but not from the .git folder.
+	#
+	# To accomplish this, we're using the "since" generator to use the
+	# recency index to select candidate nodes and "fields" to limit the
+	# output to file names only. Then we're using the "expression" term to
+	# further constrain the results.
+	if (substr($last_update_token, 0, 1) eq "c") {
+		$last_update_token = "\"$last_update_token\"";
+	}
+	my $query = <<"	END";
+		["query", "$git_work_tree", {
+			"since": $last_update_token,
+			"fields": ["name"],
+			"expression": ["not", ["dirname", ".git"]]
+		}]
+	END
+
+	# Uncomment for debugging the watchman query
+	# open (my $fh, ">", ".git/watchman-query.json");
+	# print $fh $query;
+	# close $fh;
+
+	print CHLD_IN $query;
+	close CHLD_IN;
+	my $response = do {local $/; <CHLD_OUT>};
+
+	# Uncomment for debugging the watch response
+	# open ($fh, ">", ".git/watchman-response.json");
+	# print $fh $response;
+	# close $fh;
+
+	die "Watchman: command returned no output.\n" .
+	"Falling back to scanning...\n" if $response eq "";
+	die "Watchman: command returned invalid output: $response\n" .
+	"Falling back to scanning...\n" unless $response =~ /^\{/;
+
+	return $json_pkg->new->utf8->decode($response);
+}
+
+sub is_work_tree_watched {
+	my ($output) = @_;
+	my $error = $output->{error};
+	if ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {
+		$retry--;
+		my $response = qx/watchman watch "$git_work_tree"/;
+		die "Failed to make watchman watch '$git_work_tree'.\n" .
+		    "Falling back to scanning...\n" if $? != 0;
+		$output = $json_pkg->new->utf8->decode($response);
+		$error = $output->{error};
+		die "Watchman: $error.\n" .
+		"Falling back to scanning...\n" if $error;
+
+		# Uncomment for debugging watchman output
+		# open (my $fh, ">", ".git/watchman-output.out");
+		# close $fh;
+
+		# Watchman will always return all files on the first query so
+		# return the fast "everything is dirty" flag to git and do the
+		# Watchman query just to get it over with now so we won't pay
+		# the cost in git to look up each individual file.
+		my $o = watchman_clock();
+		$error = $output->{error};
+
+		die "Watchman: $error.\n" .
+		"Falling back to scanning...\n" if $error;
+
+		output_result($o->{clock}, ("/"));
+		$last_update_token = $o->{clock};
+
+		eval { launch_watchman() };
+		return 0;
+	}
+
+	die "Watchman: $error.\n" .
+	"Falling back to scanning...\n" if $error;
+
+	return 1;
+}
+
+sub get_working_dir {
+	my $working_dir;
+	if ($^O =~ 'msys' || $^O =~ 'cygwin') {
+		$working_dir = Win32::GetCwd();
+		$working_dir =~ tr/\\/\//;
+	} else {
+		require Cwd;
+		$working_dir = Cwd::cwd();
+	}
+
+	return $working_dir;
+}
diff -Nur cgra_me/.git/hooks/post-update.sample lisa/cgra_me/.git/hooks/post-update.sample
--- cgra_me/.git/hooks/post-update.sample	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/.git/hooks/post-update.sample	2022-02-28 16:37:23.636770869 +0800
@@ -0,0 +1,8 @@
+#!/bin/sh
+#
+# An example hook script to prepare a packed repository for use over
+# dumb transports.
+#
+# To enable this hook, rename this file to "post-update".
+
+exec git update-server-info
diff -Nur cgra_me/.git/hooks/pre-applypatch.sample lisa/cgra_me/.git/hooks/pre-applypatch.sample
--- cgra_me/.git/hooks/pre-applypatch.sample	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/.git/hooks/pre-applypatch.sample	2022-02-28 16:37:23.636770869 +0800
@@ -0,0 +1,14 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed
+# by applypatch from an e-mail message.
+#
+# The hook should exit with non-zero status after issuing an
+# appropriate message if it wants to stop the commit.
+#
+# To enable this hook, rename this file to "pre-applypatch".
+
+. git-sh-setup
+precommit="$(git rev-parse --git-path hooks/pre-commit)"
+test -x "$precommit" && exec "$precommit" ${1+"$@"}
+:
diff -Nur cgra_me/.git/hooks/pre-commit.sample lisa/cgra_me/.git/hooks/pre-commit.sample
--- cgra_me/.git/hooks/pre-commit.sample	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/.git/hooks/pre-commit.sample	2022-02-28 16:37:23.636770869 +0800
@@ -0,0 +1,49 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed.
+# Called by "git commit" with no arguments.  The hook should
+# exit with non-zero status after issuing an appropriate message if
+# it wants to stop the commit.
+#
+# To enable this hook, rename this file to "pre-commit".
+
+if git rev-parse --verify HEAD >/dev/null 2>&1
+then
+	against=HEAD
+else
+	# Initial commit: diff against an empty tree object
+	against=$(git hash-object -t tree /dev/null)
+fi
+
+# If you want to allow non-ASCII filenames set this variable to true.
+allownonascii=$(git config --type=bool hooks.allownonascii)
+
+# Redirect output to stderr.
+exec 1>&2
+
+# Cross platform projects tend to avoid non-ASCII filenames; prevent
+# them from being added to the repository. We exploit the fact that the
+# printable range starts at the space character and ends with tilde.
+if [ "$allownonascii" != "true" ] &&
+	# Note that the use of brackets around a tr range is ok here, (it's
+	# even required, for portability to Solaris 10's /usr/bin/tr), since
+	# the square bracket bytes happen to fall in the designated range.
+	test $(git diff --cached --name-only --diff-filter=A -z $against |
+	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
+then
+	cat <<\EOF
+Error: Attempt to add a non-ASCII file name.
+
+This can cause problems if you want to work with people on other platforms.
+
+To be portable it is advisable to rename the file.
+
+If you know what you are doing you can disable this check using:
+
+  git config hooks.allownonascii true
+EOF
+	exit 1
+fi
+
+# If there are whitespace errors, print the offending file names and fail.
+exec git diff-index --check --cached $against --
diff -Nur cgra_me/.git/hooks/pre-merge-commit.sample lisa/cgra_me/.git/hooks/pre-merge-commit.sample
--- cgra_me/.git/hooks/pre-merge-commit.sample	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/.git/hooks/pre-merge-commit.sample	2022-02-28 16:37:23.636770869 +0800
@@ -0,0 +1,13 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed.
+# Called by "git merge" with no arguments.  The hook should
+# exit with non-zero status after issuing an appropriate message to
+# stderr if it wants to stop the merge commit.
+#
+# To enable this hook, rename this file to "pre-merge-commit".
+
+. git-sh-setup
+test -x "$GIT_DIR/hooks/pre-commit" &&
+        exec "$GIT_DIR/hooks/pre-commit"
+:
diff -Nur cgra_me/.git/hooks/prepare-commit-msg.sample lisa/cgra_me/.git/hooks/prepare-commit-msg.sample
--- cgra_me/.git/hooks/prepare-commit-msg.sample	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/.git/hooks/prepare-commit-msg.sample	2022-02-28 16:37:23.636770869 +0800
@@ -0,0 +1,42 @@
+#!/bin/sh
+#
+# An example hook script to prepare the commit log message.
+# Called by "git commit" with the name of the file that has the
+# commit message, followed by the description of the commit
+# message's source.  The hook's purpose is to edit the commit
+# message file.  If the hook fails with a non-zero status,
+# the commit is aborted.
+#
+# To enable this hook, rename this file to "prepare-commit-msg".
+
+# This hook includes three examples. The first one removes the
+# "# Please enter the commit message..." help message.
+#
+# The second includes the output of "git diff --name-status -r"
+# into the message, just before the "git status" output.  It is
+# commented because it doesn't cope with --amend or with squashed
+# commits.
+#
+# The third example adds a Signed-off-by line to the message, that can
+# still be edited.  This is rarely a good idea.
+
+COMMIT_MSG_FILE=$1
+COMMIT_SOURCE=$2
+SHA1=$3
+
+/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"
+
+# case "$COMMIT_SOURCE,$SHA1" in
+#  ,|template,)
+#    /usr/bin/perl -i.bak -pe '
+#       print "\n" . `git diff --cached --name-status -r`
+# 	 if /^#/ && $first++ == 0' "$COMMIT_MSG_FILE" ;;
+#  *) ;;
+# esac
+
+# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+# git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
+# if test -z "$COMMIT_SOURCE"
+# then
+#   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
+# fi
diff -Nur cgra_me/.git/hooks/pre-push.sample lisa/cgra_me/.git/hooks/pre-push.sample
--- cgra_me/.git/hooks/pre-push.sample	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/.git/hooks/pre-push.sample	2022-02-28 16:37:23.636770869 +0800
@@ -0,0 +1,53 @@
+#!/bin/sh
+
+# An example hook script to verify what is about to be pushed.  Called by "git
+# push" after it has checked the remote status, but before anything has been
+# pushed.  If this script exits with a non-zero status nothing will be pushed.
+#
+# This hook is called with the following parameters:
+#
+# $1 -- Name of the remote to which the push is being done
+# $2 -- URL to which the push is being done
+#
+# If pushing without using a named remote those arguments will be equal.
+#
+# Information about the commits which are being pushed is supplied as lines to
+# the standard input in the form:
+#
+#   <local ref> <local oid> <remote ref> <remote oid>
+#
+# This sample shows how to prevent push of commits where the log message starts
+# with "WIP" (work in progress).
+
+remote="$1"
+url="$2"
+
+zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
+
+while read local_ref local_oid remote_ref remote_oid
+do
+	if test "$local_oid" = "$zero"
+	then
+		# Handle delete
+		:
+	else
+		if test "$remote_oid" = "$zero"
+		then
+			# New branch, examine all commits
+			range="$local_oid"
+		else
+			# Update to existing branch, examine new commits
+			range="$remote_oid..$local_oid"
+		fi
+
+		# Check for WIP commit
+		commit=$(git rev-list -n 1 --grep '^WIP' "$range")
+		if test -n "$commit"
+		then
+			echo >&2 "Found WIP commit in $local_ref, not pushing"
+			exit 1
+		fi
+	fi
+done
+
+exit 0
diff -Nur cgra_me/.git/hooks/pre-rebase.sample lisa/cgra_me/.git/hooks/pre-rebase.sample
--- cgra_me/.git/hooks/pre-rebase.sample	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/.git/hooks/pre-rebase.sample	2022-02-28 16:37:23.636770869 +0800
@@ -0,0 +1,169 @@
+#!/bin/sh
+#
+# Copyright (c) 2006, 2008 Junio C Hamano
+#
+# The "pre-rebase" hook is run just before "git rebase" starts doing
+# its job, and can prevent the command from running by exiting with
+# non-zero status.
+#
+# The hook is called with the following parameters:
+#
+# $1 -- the upstream the series was forked from.
+# $2 -- the branch being rebased (or empty when rebasing the current branch).
+#
+# This sample shows how to prevent topic branches that are already
+# merged to 'next' branch from getting rebased, because allowing it
+# would result in rebasing already published history.
+
+publish=next
+basebranch="$1"
+if test "$#" = 2
+then
+	topic="refs/heads/$2"
+else
+	topic=`git symbolic-ref HEAD` ||
+	exit 0 ;# we do not interrupt rebasing detached HEAD
+fi
+
+case "$topic" in
+refs/heads/??/*)
+	;;
+*)
+	exit 0 ;# we do not interrupt others.
+	;;
+esac
+
+# Now we are dealing with a topic branch being rebased
+# on top of master.  Is it OK to rebase it?
+
+# Does the topic really exist?
+git show-ref -q "$topic" || {
+	echo >&2 "No such branch $topic"
+	exit 1
+}
+
+# Is topic fully merged to master?
+not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
+if test -z "$not_in_master"
+then
+	echo >&2 "$topic is fully merged to master; better remove it."
+	exit 1 ;# we could allow it, but there is no point.
+fi
+
+# Is topic ever merged to next?  If so you should not be rebasing it.
+only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
+only_next_2=`git rev-list ^master           ${publish} | sort`
+if test "$only_next_1" = "$only_next_2"
+then
+	not_in_topic=`git rev-list "^$topic" master`
+	if test -z "$not_in_topic"
+	then
+		echo >&2 "$topic is already up to date with master"
+		exit 1 ;# we could allow it, but there is no point.
+	else
+		exit 0
+	fi
+else
+	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
+	/usr/bin/perl -e '
+		my $topic = $ARGV[0];
+		my $msg = "* $topic has commits already merged to public branch:\n";
+		my (%not_in_next) = map {
+			/^([0-9a-f]+) /;
+			($1 => 1);
+		} split(/\n/, $ARGV[1]);
+		for my $elem (map {
+				/^([0-9a-f]+) (.*)$/;
+				[$1 => $2];
+			} split(/\n/, $ARGV[2])) {
+			if (!exists $not_in_next{$elem->[0]}) {
+				if ($msg) {
+					print STDERR $msg;
+					undef $msg;
+				}
+				print STDERR " $elem->[1]\n";
+			}
+		}
+	' "$topic" "$not_in_next" "$not_in_master"
+	exit 1
+fi
+
+<<\DOC_END
+
+This sample hook safeguards topic branches that have been
+published from being rewound.
+
+The workflow assumed here is:
+
+ * Once a topic branch forks from "master", "master" is never
+   merged into it again (either directly or indirectly).
+
+ * Once a topic branch is fully cooked and merged into "master",
+   it is deleted.  If you need to build on top of it to correct
+   earlier mistakes, a new topic branch is created by forking at
+   the tip of the "master".  This is not strictly necessary, but
+   it makes it easier to keep your history simple.
+
+ * Whenever you need to test or publish your changes to topic
+   branches, merge them into "next" branch.
+
+The script, being an example, hardcodes the publish branch name
+to be "next", but it is trivial to make it configurable via
+$GIT_DIR/config mechanism.
+
+With this workflow, you would want to know:
+
+(1) ... if a topic branch has ever been merged to "next".  Young
+    topic branches can have stupid mistakes you would rather
+    clean up before publishing, and things that have not been
+    merged into other branches can be easily rebased without
+    affecting other people.  But once it is published, you would
+    not want to rewind it.
+
+(2) ... if a topic branch has been fully merged to "master".
+    Then you can delete it.  More importantly, you should not
+    build on top of it -- other people may already want to
+    change things related to the topic as patches against your
+    "master", so if you need further changes, it is better to
+    fork the topic (perhaps with the same name) afresh from the
+    tip of "master".
+
+Let's look at this example:
+
+		   o---o---o---o---o---o---o---o---o---o "next"
+		  /       /           /           /
+		 /   a---a---b A     /           /
+		/   /               /           /
+	       /   /   c---c---c---c B         /
+	      /   /   /             \         /
+	     /   /   /   b---b C     \       /
+	    /   /   /   /             \     /
+    ---o---o---o---o---o---o---o---o---o---o---o "master"
+
+
+A, B and C are topic branches.
+
+ * A has one fix since it was merged up to "next".
+
+ * B has finished.  It has been fully merged up to "master" and "next",
+   and is ready to be deleted.
+
+ * C has not merged to "next" at all.
+
+We would want to allow C to be rebased, refuse A, and encourage
+B to be deleted.
+
+To compute (1):
+
+	git rev-list ^master ^topic next
+	git rev-list ^master        next
+
+	if these match, topic has not merged in next at all.
+
+To compute (2):
+
+	git rev-list master..topic
+
+	if this is empty, it is fully merged to "master".
+
+DOC_END
diff -Nur cgra_me/.git/hooks/pre-receive.sample lisa/cgra_me/.git/hooks/pre-receive.sample
--- cgra_me/.git/hooks/pre-receive.sample	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/.git/hooks/pre-receive.sample	2022-02-28 16:37:23.636770869 +0800
@@ -0,0 +1,24 @@
+#!/bin/sh
+#
+# An example hook script to make use of push options.
+# The example simply echoes all push options that start with 'echoback='
+# and rejects all pushes when the "reject" push option is used.
+#
+# To enable this hook, rename this file to "pre-receive".
+
+if test -n "$GIT_PUSH_OPTION_COUNT"
+then
+	i=0
+	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
+	do
+		eval "value=\$GIT_PUSH_OPTION_$i"
+		case "$value" in
+		echoback=*)
+			echo "echo from the pre-receive-hook: ${value#*=}" >&2
+			;;
+		reject)
+			exit 1
+		esac
+		i=$((i + 1))
+	done
+fi
diff -Nur cgra_me/.git/hooks/push-to-checkout.sample lisa/cgra_me/.git/hooks/push-to-checkout.sample
--- cgra_me/.git/hooks/push-to-checkout.sample	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/.git/hooks/push-to-checkout.sample	2022-02-28 16:37:23.636770869 +0800
@@ -0,0 +1,78 @@
+#!/bin/sh
+
+# An example hook script to update a checked-out tree on a git push.
+#
+# This hook is invoked by git-receive-pack(1) when it reacts to git
+# push and updates reference(s) in its repository, and when the push
+# tries to update the branch that is currently checked out and the
+# receive.denyCurrentBranch configuration variable is set to
+# updateInstead.
+#
+# By default, such a push is refused if the working tree and the index
+# of the remote repository has any difference from the currently
+# checked out commit; when both the working tree and the index match
+# the current commit, they are updated to match the newly pushed tip
+# of the branch. This hook is to be used to override the default
+# behaviour; however the code below reimplements the default behaviour
+# as a starting point for convenient modification.
+#
+# The hook receives the commit with which the tip of the current
+# branch is going to be updated:
+commit=$1
+
+# It can exit with a non-zero status to refuse the push (when it does
+# so, it must not modify the index or the working tree).
+die () {
+	echo >&2 "$*"
+	exit 1
+}
+
+# Or it can make any necessary changes to the working tree and to the
+# index to bring them to the desired state when the tip of the current
+# branch is updated to the new commit, and exit with a zero status.
+#
+# For example, the hook can simply run git read-tree -u -m HEAD "$1"
+# in order to emulate git fetch that is run in the reverse direction
+# with git push, as the two-tree form of git read-tree -u -m is
+# essentially the same as git switch or git checkout that switches
+# branches while keeping the local changes in the working tree that do
+# not interfere with the difference between the branches.
+
+# The below is a more-or-less exact translation to shell of the C code
+# for the default behaviour for git's push-to-checkout hook defined in
+# the push_to_deploy() function in builtin/receive-pack.c.
+#
+# Note that the hook will be executed from the repository directory,
+# not from the working tree, so if you want to perform operations on
+# the working tree, you will have to adapt your code accordingly, e.g.
+# by adding "cd .." or using relative paths.
+
+if ! git update-index -q --ignore-submodules --refresh
+then
+	die "Up-to-date check failed"
+fi
+
+if ! git diff-files --quiet --ignore-submodules --
+then
+	die "Working directory has unstaged changes"
+fi
+
+# This is a rough translation of:
+#
+#   head_has_history() ? "HEAD" : EMPTY_TREE_SHA1_HEX
+if git cat-file -e HEAD 2>/dev/null
+then
+	head=HEAD
+else
+	head=$(git hash-object -t tree --stdin </dev/null)
+fi
+
+if ! git diff-index --quiet --cached --ignore-submodules $head --
+then
+	die "Working directory has staged changes"
+fi
+
+if ! git read-tree -u -m "$commit"
+then
+	die "Could not update working tree to new HEAD"
+fi
diff -Nur cgra_me/.git/hooks/update.sample lisa/cgra_me/.git/hooks/update.sample
--- cgra_me/.git/hooks/update.sample	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/.git/hooks/update.sample	2022-02-28 16:37:23.636770869 +0800
@@ -0,0 +1,128 @@
+#!/bin/sh
+#
+# An example hook script to block unannotated tags from entering.
+# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
+#
+# To enable this hook, rename this file to "update".
+#
+# Config
+# ------
+# hooks.allowunannotated
+#   This boolean sets whether unannotated tags will be allowed into the
+#   repository.  By default they won't be.
+# hooks.allowdeletetag
+#   This boolean sets whether deleting tags will be allowed in the
+#   repository.  By default they won't be.
+# hooks.allowmodifytag
+#   This boolean sets whether a tag may be modified after creation. By default
+#   it won't be.
+# hooks.allowdeletebranch
+#   This boolean sets whether deleting branches will be allowed in the
+#   repository.  By default they won't be.
+# hooks.denycreatebranch
+#   This boolean sets whether remotely creating branches will be denied
+#   in the repository.  By default this is allowed.
+#
+
+# --- Command line
+refname="$1"
+oldrev="$2"
+newrev="$3"
+
+# --- Safety check
+if [ -z "$GIT_DIR" ]; then
+	echo "Don't run this script from the command line." >&2
+	echo " (if you want, you could supply GIT_DIR then run" >&2
+	echo "  $0 <ref> <oldrev> <newrev>)" >&2
+	exit 1
+fi
+
+if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
+	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
+	exit 1
+fi
+
+# --- Config
+allowunannotated=$(git config --type=bool hooks.allowunannotated)
+allowdeletebranch=$(git config --type=bool hooks.allowdeletebranch)
+denycreatebranch=$(git config --type=bool hooks.denycreatebranch)
+allowdeletetag=$(git config --type=bool hooks.allowdeletetag)
+allowmodifytag=$(git config --type=bool hooks.allowmodifytag)
+
+# check for no description
+projectdesc=$(sed -e '1q' "$GIT_DIR/description")
+case "$projectdesc" in
+"Unnamed repository"* | "")
+	echo "*** Project description file hasn't been set" >&2
+	exit 1
+	;;
+esac
+
+# --- Check types
+# if $newrev is 0000...0000, it's a commit to delete a ref.
+zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
+if [ "$newrev" = "$zero" ]; then
+	newrev_type=delete
+else
+	newrev_type=$(git cat-file -t $newrev)
+fi
+
+case "$refname","$newrev_type" in
+	refs/tags/*,commit)
+		# un-annotated tag
+		short_refname=${refname##refs/tags/}
+		if [ "$allowunannotated" != "true" ]; then
+			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
+			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
+			exit 1
+		fi
+		;;
+	refs/tags/*,delete)
+		# delete tag
+		if [ "$allowdeletetag" != "true" ]; then
+			echo "*** Deleting a tag is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/tags/*,tag)
+		# annotated tag
+		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
+		then
+			echo "*** Tag '$refname' already exists." >&2
+			echo "*** Modifying a tag is not allowed in this repository." >&2
+			exit 1
+		fi
+		;;
+	refs/heads/*,commit)
+		# branch
+		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
+			echo "*** Creating a branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/heads/*,delete)
+		# delete branch
+		if [ "$allowdeletebranch" != "true" ]; then
+			echo "*** Deleting a branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/remotes/*,commit)
+		# tracking branch
+		;;
+	refs/remotes/*,delete)
+		# delete tracking branch
+		if [ "$allowdeletebranch" != "true" ]; then
+			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	*)
+		# Anything else (is there anything else?)
+		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
+		exit 1
+		;;
+esac
+
+# --- Finished
+exit 0
Binary files cgra_me/.git/index and lisa/cgra_me/.git/index differ
diff -Nur cgra_me/.git/info/exclude lisa/cgra_me/.git/info/exclude
--- cgra_me/.git/info/exclude	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/.git/info/exclude	2022-02-28 16:37:23.636770869 +0800
@@ -0,0 +1,6 @@
+# git ls-files --others --exclude-from=.git/info/exclude
+# Lines that start with '#' are comments.
+# For a project mostly in C, the following would be a good set of
+# exclude patterns (uncomment them if you want to use them):
+# *.[oa]
+# *~
diff -Nur cgra_me/.git/logs/HEAD lisa/cgra_me/.git/logs/HEAD
--- cgra_me/.git/logs/HEAD	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/.git/logs/HEAD	2022-02-28 16:37:25.864775466 +0800
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 a9e5fe6c9f0385486d702ba9a053b4bfde401688 zhaoying <lizhaoyinglzy@gmail.com> 1646037445 +0800	clone: from https://github.com/zhaoying-LI/cgra_me.git
diff -Nur cgra_me/.git/logs/refs/heads/master lisa/cgra_me/.git/logs/refs/heads/master
--- cgra_me/.git/logs/refs/heads/master	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/.git/logs/refs/heads/master	2022-02-28 16:37:25.864775466 +0800
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 a9e5fe6c9f0385486d702ba9a053b4bfde401688 zhaoying <lizhaoyinglzy@gmail.com> 1646037445 +0800	clone: from https://github.com/zhaoying-LI/cgra_me.git
diff -Nur cgra_me/.git/logs/refs/remotes/origin/HEAD lisa/cgra_me/.git/logs/refs/remotes/origin/HEAD
--- cgra_me/.git/logs/refs/remotes/origin/HEAD	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/.git/logs/refs/remotes/origin/HEAD	2022-02-28 16:37:25.864775466 +0800
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 a9e5fe6c9f0385486d702ba9a053b4bfde401688 zhaoying <lizhaoyinglzy@gmail.com> 1646037445 +0800	clone: from https://github.com/zhaoying-LI/cgra_me.git
Binary files cgra_me/.git/objects/pack/pack-d6ad8961af358cfa332180fdac79330dba19de69.idx and lisa/cgra_me/.git/objects/pack/pack-d6ad8961af358cfa332180fdac79330dba19de69.idx differ
Binary files cgra_me/.git/objects/pack/pack-d6ad8961af358cfa332180fdac79330dba19de69.pack and lisa/cgra_me/.git/objects/pack/pack-d6ad8961af358cfa332180fdac79330dba19de69.pack differ
diff -Nur cgra_me/.git/packed-refs lisa/cgra_me/.git/packed-refs
--- cgra_me/.git/packed-refs	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/.git/packed-refs	2022-02-28 16:37:25.864775466 +0800
@@ -0,0 +1,2 @@
+# pack-refs with: peeled fully-peeled sorted 
+a9e5fe6c9f0385486d702ba9a053b4bfde401688 refs/remotes/origin/master
diff -Nur cgra_me/.git/refs/heads/master lisa/cgra_me/.git/refs/heads/master
--- cgra_me/.git/refs/heads/master	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/.git/refs/heads/master	2022-02-28 16:37:25.864775466 +0800
@@ -0,0 +1 @@
+a9e5fe6c9f0385486d702ba9a053b4bfde401688
diff -Nur cgra_me/.git/refs/remotes/origin/HEAD lisa/cgra_me/.git/refs/remotes/origin/HEAD
--- cgra_me/.git/refs/remotes/origin/HEAD	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/.git/refs/remotes/origin/HEAD	2022-02-28 16:37:25.864775466 +0800
@@ -0,0 +1 @@
+ref: refs/remotes/origin/master
diff -Nur cgra_me/.gitignore lisa/cgra_me/.gitignore
--- cgra_me/.gitignore	2018-05-09 09:34:57.000000000 +0800
+++ lisa/cgra_me/.gitignore	2022-02-28 16:37:25.868775474 +0800
@@ -15,9 +15,10 @@
 #Excluding DFG file
 *.tag
 *.dot
-
+*.pdf
 #Excluding user custom benchmarks
 benchmarks/userbench/*
+benchmarks/*
 !benchmarks/userbench/README
 
 #Excluding build path
@@ -27,7 +28,9 @@
 benchmarks/exp-run/
 
 #Excluding output
-/output/
+output/
+figs/
+
 
 #Excluding cmake file
 cmake-build*
diff -Nur cgra_me/inc/CGRA/AnnealMapper.h lisa/cgra_me/inc/CGRA/AnnealMapper.h
--- cgra_me/inc/CGRA/AnnealMapper.h	2018-05-09 09:34:57.000000000 +0800
+++ lisa/cgra_me/inc/CGRA/AnnealMapper.h	2022-02-28 16:37:25.908775556 +0800
@@ -37,75 +37,278 @@
 #include <map>
 #include <vector>
 #include <memory>
-
+#include <algorithm>
+#include <unordered_set>
 #include <CGRA/CGRA.h>
 #include <CGRA/OpGraph.h>
 #include <CGRA/Mapper.h>
 #include <CGRA/Mapping.h>
 
-typedef struct
-{
-    std::map<OpGraphNode*, std::vector<MRRGNode*>> mapping;
-} OpMapping;
+using namespace std;
+
+
+
+
 
 class AnnealMapper : public Mapper
 {
-    public:
-        // Custom setup with variable args
-        AnnealMapper(std::shared_ptr<CGRA> cgra, int timelimit, const std::map<std::string, std::string> & args);
-        // Default setup
-        AnnealMapper(std::shared_ptr<CGRA> cgra);               
-        // Custom setup
-        AnnealMapper(std::shared_ptr<CGRA> cgra, int timelimit,  int rand_seed, float initial_penalty, float penalty_factor, float const_temp_factor, int swap_factor, float cold_accept_rate); 
-        ~AnnealMapper() = default;
-
-        Mapping mapOpGraph(std::shared_ptr<OpGraph> opgraph, int II) override;
-
-
-    protected:
-        int     rand_seed;
-        float   pfactor;
-        float   pfactor_factor;
-        float   const_temp_factor;
-        int     swap_factor;
-        float   cold_accept_rate;
-        float   updateTempConst(float temp);
-
-    private:
-        bool inner_place_and_route_loop(OpGraph* opgraph, MRRG* mrrg, float temp, float* accept_rate);
-        MRRGNode* getCandidateFU(MRRG* mrrg, OpGraphOp* op);
-        MRRGNode* getRandomUnoccupiedFU(MRRG* mrrg, OpGraphOp* op);
-        OpGraphOp* getOpNodePtr(OpGraph* opgraph, MRRGNode* n);
-
-        OpMapping ripUpOp(OpGraphOp* op, float* cost = NULL);
-        void restoreOp(OpMapping oldmap);
-
-        bool routeOp(OpGraphOp* op, MRRG* mrrg);
-        bool routeVal(OpGraphVal* val);
-        bool placeOp(OpGraphOp* op, MRRGNode* n);
-
-        bool checkOveruse(MRRG* mrrg);
-        
-        // mapping/unmapping
-        void  mapMRRGNode(OpGraphNode*, MRRGNode* node);
-        void  unmapMRRGNode(OpGraphNode*, MRRGNode* node);
-        std::vector<MRRGNode*> unmapAllMRRGNodes(OpGraphNode*);
-        void mapAllMRRGNodes(OpGraphNode*, std::vector<MRRGNode*> nodes);
-        MRRGNode* getMappedMRRGNode(OpGraphOp* op);
-
-        // mapping and occupancy
-        std::map<MRRGNode*,int> occupancy;
-        std::map<OpGraphNode*, std::vector<MRRGNode*>> mapping;
-
-        // Costing
-        float getTotalOpCost(OpGraphOp* op);
-        float getCost(MRRGNode* n);
-        float getCost(MRRG* n);
-        float getCost(OpGraphNode* n);
-        float getCost(OpGraph* opgraph);
-        bool compare_mrrg_node_cost(MRRGNode* a, MRRGNode* b);
+public:
+    // Custom setup with variable args
+    AnnealMapper(std::shared_ptr<CGRA> cgra, int timelimit, const std::map<std::string, std::string> &args);
+    // Default setup
+    AnnealMapper(std::shared_ptr<CGRA> cgra);
+    // Custom setup
+    AnnealMapper(std::shared_ptr<CGRA> cgra, int timelimit, int rand_seed, float initial_penalty, float penalty_factor, float const_temp_factor, int swap_factor, float cold_accept_rate);
+    ~AnnealMapper() = default;
+
+    Mapping mapOpGraph(std::shared_ptr<OpGraph> opgraph, int II, std::string arch_model_name) override;
+
+    static void topological_sort_visit(std::vector<OpGraphOp *> *L, std::map<OpGraphOp *, bool> *mark, OpGraphOp *n)
+    {
+        if (!(*mark)[n])
+        {
+            if (n->opcode != OPGRAPH_OP_OUTPUT)
+            {
+                for (auto &m : n->output->output)
+                {
+                    topological_sort_visit(L, mark, m);
+                }
+            }
+
+            (*mark)[n] = true;
+            L->insert(L->begin(), n); // push n to head
+        }
+    }
+
+    static OpGraphOp *topological_sort_check_marked(std::vector<OpGraphOp *> nodes, std::map<OpGraphOp *, bool> *mark)
+    {
+        for (auto &n : nodes)
+        {
+            if (!(*mark)[n])
+                return n;
+        }
+        return NULL;
+    }
+
+    // This topological sort algorithm uses a depth first search
+    // NB: The graph MUST be acyclic, else explosions may happen...
+    void topological_sort(std::shared_ptr<OpGraph> g)
+    {
+        std::vector<OpGraphOp *> L;
+
+        // // Unmark all nodes
+        // std::map<OpGraphOp *, bool> mark;
+        // for (auto &n : g->op_nodes)
+        // {
+        //     mark[n] = false;
+        // }
+
+        // OpGraphOp *n;
+        // while ((n = topological_sort_check_marked(g->op_nodes, &mark)))
+        // {
+        //     topological_sort_visit(&L, &mark, n);
+        // }
+        std::set<OpGraphOp *> waiting_set;
+         for (auto n : g->op_nodes)
+        {
+            waiting_set.insert(n);
+        }
+        int iteration = 0;
+        while(iteration<1000){
+            for(auto n: waiting_set){
+                bool mapped  = true;
+                for(auto input_val: n->input){
+                    auto input_node = input_val->input;
+                    if(mapping[input_node].size() == 0){
+                        mapped = false;
+                    }
+                }
+                if(mapped){
+                    L.push_back(n);
+                    waiting_set.erase(n);
+                    break;
+                }
+            }
+
+            iteration ++;
+
+        }
+
+        for(auto node: waiting_set){
+            L.push_back(node);
+        }
+
+        assert(L.size() ==  g->op_nodes.size());
+        g->op_nodes = L;
+    }
+    /*
+bool test_compare(float penalty_factor, MRRGNode* a, MRRGNode* b)
+{
+    return getCost(a) < getCost(b);
+}
 
+bool compare_op_cost(float penalty_factor, OpGraphOp* a, OpGraphOp* b)
+{
+    return a->getCost(penalty_factor) > b->getCost(penalty_factor);
+}
+*/
+    float updateTemperature(float t, float acceptance_rate)
+    {
+        if (acceptance_rate > 0.96)
+        {
+            return t * 0.5;
+        }
+        else if (acceptance_rate > 0.8)
+        {
+            return t * 0.9;
+        }
+        else if (acceptance_rate > 0.15)
+        {
+            return t * 0.98;
+        }
+        else
+        {
+            return t * 0.95;
+        }
+    }
+
+    std::vector<std::pair<MRRGNode *, int>> candidate_fu_intersect(std::vector<std::pair<MRRGNode *, int>> v1, std::vector<std::pair<MRRGNode *, int>> v2)
+    {
+        std::vector<std::pair<MRRGNode *, int>> result;
+
+        for (auto &p : v1)
+        {
+            for (auto &n : v2)
+            {
+                if (p.first == n.first)
+                    result.push_back({p.first, p.second + n.second});
+            }
+        }
+
+        return result;
+    }
+
+    // generate a random FU, zhaoying changes it to non-occupied
+    MRRGNode *getRandomFU(MRRG *mrrg, OpGraphOp *op)
+    {
+        int min_start = 0;
+        std::vector<MRRGNode *> candidates;
+        for (auto &fu : mrrg->function_nodes)
+        {   
+            mpos mmmm{fu->x_, fu->y_, fu->cycle};
+            bool exist = false;
+            for(auto m :  mapped_pos){
+                if(m.x == mmmm.x && mmmm.y == m.y  && mmmm.t == m.t){
+                    exist = true;
+                    break;
+                }
+            }
+            if (fu->canMapOp(op)&& occupancy[fu] == 0)
+            {
+                candidates.push_back(fu);
+            }
+        }
+
+        if (candidates.size() < 1)
+        {
+            cout << "Could not place: " << *op << endl;
+            assert(candidates.size() > 0);
+        }
+
+        return candidates[rand() % candidates.size()];
+    }
+
+    template <typename type>
+    std::vector<type> vector_intersect(std::vector<type> v1, std::vector<type> v2)
+    {
+        std::sort(v1.begin(), v1.end());
+        std::sort(v2.begin(), v2.end());
+
+        std::vector<type> v_intersection;
+
+        std::set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), std::back_inserter(v_intersection));
+
+        return v_intersection;
+    }
+
+    std::vector<MRRGNode *> filterCanMapOp(std::vector<MRRGNode *> fus, OpGraphOp const *op)
+    {
+        std::vector<MRRGNode *> result;
+        for (auto &f : fus)
+        {
+            if (f->canMapOp(op))
+            {
+                result.push_back(f);
+            }
+        }
+
+        return result;
+    }
+    
+    void updateOveruse(MRRG *mrrg)
+    {
+        overuse_num_ = 0;
+        for (auto &node : mrrg->routing_nodes)
+        {
+            if (occupancy[node] > node->capacity)
+            {
+                overuse_num_ += occupancy[node]-  node->capacity;
+            }
+        }
+    }
+
+
+protected:
+    int rand_seed;
+    float pfactor;
+    float pfactor_factor;
+    float const_temp_factor;
+    int swap_factor;
+    float cold_accept_rate;
+    float updateTempConst(float temp);
+
+private:
+    bool inner_place_and_route_loop(OpGraph *opgraph, MRRG *mrrg, float temp, float *accept_rate);
+    MRRGNode *getCandidateFU(MRRG *mrrg, OpGraphOp *op);
+    MRRGNode *getRandomUnoccupiedFU(MRRG *mrrg, OpGraphOp *op);
+    OpGraphOp *getOpNodePtr(OpGraph *opgraph, MRRGNode *n);
+
+    OpMapping ripUpOp(OpGraphOp *op, float *cost = NULL);
+    void restoreOp(OpMapping oldmap);
+
+    bool routeOp(OpGraphOp *op, MRRG *mrrg);
+    bool routeVal(OpGraphVal *val);
+    bool placeOp(OpGraphOp *op, MRRGNode *n);
+
+    bool checkOveruse(MRRG *mrrg);
+
+    // mapping/unmapping
+    void mapMRRGNode(OpGraphNode *, MRRGNode *node);
+    void unmapMRRGNode(OpGraphNode *, MRRGNode *node);
+    std::vector<MRRGNode *> unmapAllMRRGNodes(OpGraphNode *);
+    void mapAllMRRGNodes(OpGraphNode *, std::vector<MRRGNode *> nodes);
+    MRRGNode *getMappedMRRGNode(OpGraphOp *op);
+
+    // mapping and occupancy
+    std::map<MRRGNode *, int> occupancy;
+    std::map<OpGraphNode *, std::vector<MRRGNode *>> mapping;
+
+    // Costing
+    float getTotalOpCost(OpGraphOp *op);
+    float getCost(MRRGNode *n);
+    float getCost(MRRG *n);
+    float getCost(OpGraphNode *n);
+    float getCost(OpGraph *opgraph);
+    bool compare_mrrg_node_cost(MRRGNode *a, MRRGNode *b);
+
+    MRRG * this_mrr;
+    std::set<mpos> mapped_pos;
+
+    bool allow_overuse = true;
+
+    int MAX_OVERUSE = 1000; // I set 1000 as it is a good value to get an initial mapping.
+
+    int overuse_num_ = 0;
 };
 
 #endif
-
diff -Nur cgra_me/inc/CGRA/debug.h lisa/cgra_me/inc/CGRA/debug.h
--- cgra_me/inc/CGRA/debug.h	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/inc/CGRA/debug.h	2022-02-28 16:37:25.912775566 +0800
@@ -0,0 +1,45 @@
+#pragma once
+
+#include <cassert>
+#include <cstdlib>
+#include <fstream>
+#include <iostream>
+#include <string>
+#include <utility>
+
+class LOGGER {
+
+  bool abort;
+
+ public:
+  LOGGER(std::string reason, std::string file, int lineno, bool abort) : abort(abort) {
+    std::cerr << reason <<  " : ";
+  }
+
+  ~LOGGER() noexcept(false) {
+    std::cerr << std::endl;
+    if (abort) {
+      throw;
+    }
+  }
+
+  template <typename T>
+  inline LOGGER& operator<<(T&& x) {
+    std::cerr << std::forward<T>(x);
+    return *this;
+  }
+};
+
+#define CHECK(COND) \
+  if (!(COND)) LOGGER("[CHECK FAIL]", __FILE__, __LINE__, true) << #COND << " "
+
+// #ifdef DEBUG_MODE
+#define LOG(S) if (getenv(#S)) LOGGER("[DEBUG]", __FILE__, __LINE__, false)
+// #else
+// #define LOG(S) if (false) LOGGER("[DEBUG]", __FILE__, __LINE__, false)
+// #endif
+
+#define ENFORCED_SYSTEM(CMD)                    \
+  if (int ret = system(CMD))                    \
+    LOGGER("[SHELL]", __FILE__, __LINE__, true) \
+      << "Failed command: " << (CMD) << ", code" << ret
diff -Nur cgra_me/inc/CGRA/ILPMapper.h lisa/cgra_me/inc/CGRA/ILPMapper.h
--- cgra_me/inc/CGRA/ILPMapper.h	2018-05-09 09:34:57.000000000 +0800
+++ lisa/cgra_me/inc/CGRA/ILPMapper.h	2022-02-28 16:37:25.908775556 +0800
@@ -66,7 +66,7 @@
         ILPMapper(std::shared_ptr<CGRA> cgra, int timelimit, double mipgap, int solnlimit);
         ~ILPMapper() = default;
 
-        Mapping mapOpGraph(std::shared_ptr<OpGraph> opgraph, int II) override;
+        Mapping mapOpGraph(std::shared_ptr<OpGraph> opgraph, int II, std::string arch_model_name) override;
 
     private:
         ILPSolverType solvertype;
diff -Nur cgra_me/inc/CGRA/lisa/gnn.h lisa/cgra_me/inc/CGRA/lisa/gnn.h
--- cgra_me/inc/CGRA/lisa/gnn.h	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/inc/CGRA/lisa/gnn.h	2022-02-28 16:37:25.912775566 +0800
@@ -0,0 +1,60 @@
+#include <ctime>
+#include <set>
+#include <unistd.h>
+#include <iostream>
+#include <fstream>
+#include <unordered_set>
+
+#include <CGRA/debug.h>
+#include <CGRA/OpGraph.h>
+
+
+
+
+#ifndef ___GNN_H__
+#define ___GNN_H__
+
+
+
+
+
+static std::string gen_random(const int len)
+    {
+
+      std::string tmp_s;
+      static const char alphanum[] =
+          "0123456789"
+          "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
+          "abcdefghijklmnopqrstuvwxyz";
+
+      srand((unsigned)time(NULL) * getpid());
+
+      tmp_s.reserve(len);
+
+      for (int i = 0; i < len; ++i)
+        tmp_s += alphanum[rand() % (sizeof(alphanum) - 1)];
+
+      return tmp_s;
+    }
+
+class GNN{
+  public:
+    GNN();
+
+    void inference();
+
+    void dump_dfg();
+    void dump_feature();
+
+
+    void call_gnn();
+
+
+  private:
+    std::string dfg_name_;
+    
+   
+};
+
+
+#endif
diff -Nur cgra_me/inc/CGRA/lisa/LISAController.h lisa/cgra_me/inc/CGRA/lisa/LISAController.h
--- cgra_me/inc/CGRA/lisa/LISAController.h	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/inc/CGRA/lisa/LISAController.h	2022-02-28 16:37:25.912775566 +0800
@@ -0,0 +1,177 @@
+
+#include <ctime>
+#include <set>
+#include <unistd.h>
+#include <iostream>
+#include <fstream>
+#include <map>
+#include <vector>
+#include <unordered_set>
+#include <stdlib.h>
+
+#include<CGRA/lisa/LISADFG.h>
+#include<CGRA/lisa/LISASchedule.h>
+#ifndef ___LISAController_H__
+#define ___LISAController_H__
+
+
+//currently, we have three types of labels:
+// a) schedule order: set the max value as 2 * len(longest_path); this is to leave some space for the medium value. 
+//   for example, we have a graph with three nodes: A, B, and C. We have two edges that A->B and A->C. B, C have the same initial label. 
+//   So value: A:1, B:2, C:2. If B has more child nodes, thus B should be scheduled before A. However, there is no space between 1 and 2.
+//  initial value: 2* asap value
+//  calculate value from mapping: normalized to  2 * len(longest_path)
+// b) communication: initial value: the degree value.
+//    let the communication value be the total length of distance between neighbours. Do not normalize it,
+// c) same level node of distance. Same level means the node have the same ASAP value, and they have common parents or children. Also, make sure the node should have same descendant.
+// This is not determined by the ancestor, as the ancestor usually has been placed before this..
+// d) association: association value can be positive. The lower the value, the closer the neighbours. 
+//    we should have two type of association: temporal association and spatial association.
+//    Time difference can be negative or postive, but physical different must be positive.  
+//    initial value: longest_path - distance_between_two_nodes. distance_between_two_nodes is calculated by difference of asap value;
+//    calculate from : let us calculate the average distance between neigbours. 
+
+
+struct node_label{
+  int schedule_order;
+  int communication;
+  std::map<int, int> sameLevel_node_distance;
+  std::map<int, std::pair<int, int>> association; //<spatial,temporal>
+
+  std::string toStr(){
+    std::stringstream output;
+    output<<" schedule_order:"<<schedule_order<<" communication:"<<communication<<"\t  sameLevel_node_distance:\t";
+    for(auto dis: sameLevel_node_distance){
+      output<<" <"<<dis.first<<","<<dis.second<<"> ";
+    }
+     output<<"\n \tassociation:\t";
+    for(auto aff: association){
+      output<<" <"<<aff.first<<","<<aff.second.first<<","<<aff.second.second<<"> ";
+    }
+    return output.str();
+  }
+
+  int calTotalPoint(){
+    int point = 0;
+    point += schedule_order;
+    for(auto pair: sameLevel_node_distance){
+      point += pair.second;
+    }
+    for(auto pair: association){
+      point += pair.second.first;
+      point += pair.second.second;
+    }
+
+    return point;
+
+  }
+};
+
+struct perf_metric{
+    int ii;
+    float cost;
+    int running_time;
+
+    bool operator < (const perf_metric& other) const {
+        if( ii < other.ii ) return true;
+        if ( ii == other.ii && cost < other.cost ) return true;
+        if ( ii == other.ii && cost && other.cost && running_time <  other.running_time) return true;
+        return false;
+    }
+};
+
+using DFG_label = std::map<int, node_label>;
+
+class LISAController{
+  public:
+    LISAController(int fabric_x, int fabric_y, std::string dfg_id, std::set<int> nodes, std::map<int, std::string> node_op, std::vector<std::pair<int,int>> edges);
+
+    void initLabels();
+    
+    //for generate and update label
+    void passMapping(bool isBest, std::map<int, pos3d> & mapping, int max_lat, perf_metric perf);
+    std::map<int, int> genScheduleOrderLabel(std::map<int, pos3d> & mapping,  int max_lat);
+    std::map<int, int> genCommunicationLabel(std::map<int, pos3d> & mapping,  int max_lat);
+    std::map<int, std::pair<int, int>> genlAssocationLabel(int node_id, std::map<int, pos3d> & mapping,  int max_lat);
+    std::map<int, int> genSameLevelNodeLabel(int node_id, std::map<int, pos3d> & mapping,  int max_lat);
+    void updateLabel(std::shared_ptr<DFG_label> label_a, std::shared_ptr<DFG_label> label_b, std::shared_ptr<DFG_label> update_label);
+    void updateNodeLabel(node_label & node_label_a, node_label & node_label_b, node_label & update_node_label);
+
+    //generate final combined label
+    int calLabelDifference(node_label & a_label, node_label & b_label);
+    std::vector<std::shared_ptr<DFG_label>> filterBestLabels(std::vector<std::shared_ptr<DFG_label>> best_labels);
+    void generateCombinedBestLabelHistorically(perf_metric best_perf);
+
+
+    
+    std::shared_ptr<DFG_label> getBestLabel(){return best_label_;}
+    std::shared_ptr<DFG_label> getCurrLabel(){return label_hist.back();}
+
+    //for gnn dataset generation and call gnn inference
+    void dumpBestLabelForGNNDataSet();
+    std::string labelToStrForGNNDataSet(DFG_label & dfg_label);
+    void callGNNInference();
+    void dumpGraphForInference(std::string graph_name);
+    void getLabelFromFile(DFG_label & dfg_label, std::string graph_name);
+
+    //utils
+    void setArchandDFGFileName(std::string arch_file_name, std::string dfg_file, std::string arch_name){
+      arch_file_name_ = arch_file_name; dfg_file_name_ = dfg_file;   arch_name_ = arch_name; }
+      
+    std::string mappingToStr(std::map<int, pos3d> & mapping, int max_lat);
+    std::string bestMappingToStr(){return mappingToStr(best_mapping_.first, best_mapping_.second);};
+    bool isStartNode(int node_id){if(start_nodes_.find(node_id) == start_nodes_.end()) return false; return true;}
+    std::set<int> getSameLevelNodes(int node_id){return sameLevel_nodes_with_common_descendent_[node_id];};
+    std::string DFGLabelToStr(DFG_label & dfg_label) const;
+     std::map<int, int> getNodeASAP(){
+      std::map<int, int> node_asap;
+      for(auto nf: dfg_->node_feature_){
+        node_asap.emplace(nf.first, nf.second.asap);
+      }
+      return node_asap;
+    }
+    std::string gen_random(const int len)
+    {
+      std::string tmp_s;
+      static const char alphanum[] =
+          "0123456789"
+          "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
+          "abcdefghijklmnopqrstuvwxyz";
+      srand((unsigned)time(NULL) * getpid());
+      tmp_s.reserve(len);
+      for (int i = 0; i < len; ++i)
+        tmp_s += alphanum[rand() % (sizeof(alphanum) - 1)];
+      return tmp_s;
+    }
+
+    void setMII(int MII){MII_ = MII;}
+  
+  private:
+    std::shared_ptr<DFG_label> init_label_;
+    std::shared_ptr<DFG_label> best_label_;
+    std::shared_ptr<DFG_label> src_of_best_label_;
+    std::pair<std::map<int, pos3d>, int> best_mapping_;
+    std::vector<std::shared_ptr<DFG_label> > label_hist;
+    std::map<std::shared_ptr<DFG_label>, perf_metric> label_perf; // this is to combine the best mapping
+
+    // dfg relevant labels
+    LISADFG* dfg_;
+    std::set<int> start_nodes_; 
+    std::map<int, std::set<int>> sameLevel_nodes_with_common_descendent_; 
+
+    int fabric_x_;
+    int fabric_y_;
+
+    int MII_ = 0; //for cgra_me
+
+
+    std::string arch_file_name_;
+    std::string dfg_file_name_;
+    std::string arch_name_; // this is for dumping label
+
+    double label_difference_threashold = 1;
+
+};
+
+
+#endif
\ No newline at end of file
diff -Nur cgra_me/inc/CGRA/lisa/LISADFG.h lisa/cgra_me/inc/CGRA/lisa/LISADFG.h
--- cgra_me/inc/CGRA/lisa/LISADFG.h	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/inc/CGRA/lisa/LISADFG.h	2022-02-28 16:37:25.912775566 +0800
@@ -0,0 +1,76 @@
+#include <ctime>
+#include <set>
+#include <unistd.h>
+#include <iostream>
+#include <fstream>
+#include <unordered_set>
+#include <sstream>
+
+#include <CGRA/debug.h>
+#include <CGRA/OpGraph.h>
+
+
+
+
+#ifndef ___LISADFG_H__
+#define ___LISADFG_H__
+
+
+struct edge{
+  int src;
+  int des;
+
+  bool operator<(const edge& b) const
+  { 
+    if (src != b.src){
+      return src < b.src;
+    }else {
+      return des < b.des;
+    }
+  } 
+
+  bool operator==(const edge& b) const
+  { 
+    return src == b.src && des == b.des;
+  } 
+};
+
+struct feature{
+  std::string op_type;
+  int asap;
+  int input_degree;
+  int output_degree;
+
+  std::string toStr(){
+    std::stringstream output;
+    output<< "op:"<<op_type<<" asap:"<<asap<<" in_degree:"<<input_degree<<" out_degree"<<output_degree;
+    return output.str();
+  }
+};
+
+class LISADFG{
+  public:
+
+    friend class LISAController;
+    LISADFG(std::string dfg_id, std::set<int> nodes,  std::map<int, std::string> node_op, std::vector<std::pair<int,int>> edges);
+    void calASAP();
+    void calDegree();
+    int cal_dist(int src, int des);
+    bool is_edge(int src, int des){return !(node_children_[src].find(des) == node_children_[src].end() ); }
+    std::string ToString();
+  private:
+    std::set<int> nodes_;
+    std::map<int, std::string> node_op_;
+    std::map<int, std::set<int>> node_parents_;
+    std::map<int, std::set<int>> node_children_;
+    std::set<edge> edges_;
+    std::map<int, feature> node_feature_;
+    std::map<int, std::set<int>> asap_to_node_;
+    int max_length_; // means max asap value
+    int max_degree_;
+    std::string dfg_id_;
+    
+};
+
+
+#endif
\ No newline at end of file
diff -Nur cgra_me/inc/CGRA/lisa/LISAMapper.h lisa/cgra_me/inc/CGRA/lisa/LISAMapper.h
--- cgra_me/inc/CGRA/lisa/LISAMapper.h	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/inc/CGRA/lisa/LISAMapper.h	2022-02-28 16:37:25.912775566 +0800
@@ -0,0 +1,354 @@
+/*******************************************************************************
+ * CGRA-ME Software End-User License Agreement
+ *
+ * The software programs comprising "CGRA-ME" and the documentation provided
+ * with them are copyright by its authors S. Chin, K. Niu, N. Sakamoto, J. Zhao,
+ * A. Rui, S. Yin, A. Mertens, J. Anderson, and the University of Toronto. Users
+ * agree to not redistribute the software, in source or binary form, to other
+ * persons or other institutions. Users may modify or use the source code for
+ * other non-commercial, not-for-profit research endeavours, provided that all
+ * copyright attribution on the source code is retained, and the original or
+ * modified source code is not redistributed, in whole or in part, or included
+ * in or with any commercial product, except by written agreement with the
+ * authors, and full and complete attribution for use of the code is given in
+ * any resulting publications.
+ *
+ * Only non-commercial, not-for-profit use of this software is permitted. No
+ * part of this software may be incorporated into a commercial product without
+ * the written consent of the authors. The software may not be used for the
+ * design of a commercial electronic product without the written consent of the
+ * authors. The use of this software to assist in the development of new
+ * commercial CGRA architectures or commercial soft processor architectures is
+ * also prohibited without the written consent of the authors.
+ *
+ * This software is provided "as is" with no warranties or guarantees of
+ * support.
+ *
+ * This Agreement shall be governed by the laws of Province of Ontario, Canada.
+ *
+ * Please contact Prof. Anderson if you are interested in commercial use of the
+ * CGRA-ME framework.
+ ******************************************************************************/
+
+#ifndef ___LISAMapper_H__
+#define ___LISAMapper_H__
+
+#include <string>
+#include <map>
+#include <vector>
+#include <memory>
+#include <algorithm>
+#include <chrono>
+#include <random>
+#include <cmath>
+#include <ctime>
+
+#include <CGRA/CGRA.h>
+#include <CGRA/OpGraph.h>
+#include <CGRA/Mapper.h>
+#include <CGRA/Mapping.h>
+#include <CGRA/lisa/gnn.h>
+#include <CGRA/lisa/LISAController.h>
+
+using namespace std;
+
+struct op_edge{
+    OpGraphOp * src;
+    OpGraphOp * des;
+    int length;
+
+   
+};
+
+struct op_edge_comp {
+    bool operator()(op_edge const & a, op_edge const & b) {
+        // your code here
+        if(a.length != b.length){
+            return a.length >  b.length;
+        }else{
+            // just give an result. 
+            std::string as = a.src->name + a.des->name;
+            std::string bs = b.src->name + b.des->name;
+            return as.compare(bs);
+        }
+    }
+};
+
+class Generator {
+    std::default_random_engine generator;
+    std::normal_distribution<double> distribution;
+    double min;
+    double max;
+public:
+    Generator(double mean, double stddev, double min, double max):
+        distribution(mean, stddev), min(min), max(max)
+    {}
+
+    double operator ()() {
+        while (true) {
+            double number = this->distribution(generator);
+            if (number >= this->min && number <= this->max)
+                return number;
+        }
+    }
+};
+
+
+class LISAMapper : public Mapper
+{
+public:
+    // Custom setup with variable args
+    LISAMapper(std::shared_ptr<CGRA> cgra, int timelimit, const std::map<std::string, std::string> &args);
+    // Default setup
+    LISAMapper(std::shared_ptr<CGRA> cgra);
+    // Custom setup
+    LISAMapper(std::shared_ptr<CGRA> cgra, int timelimit, int rand_seed, float initial_penalty, float penalty_factor, float const_temp_factor, int swap_factor, float cold_accept_rate);
+    ~LISAMapper() = default;
+
+    Mapping mapOpGraph(std::shared_ptr<OpGraph> opgraph, int II, std::string arch_model_name) override;
+
+
+    float getFinalCost();
+
+    static void topological_sort_visit(std::vector<OpGraphOp *> *L, std::map<OpGraphOp *, bool> *mark, OpGraphOp *n)
+    {
+        if (!(*mark)[n])
+        {
+            if (n->opcode != OPGRAPH_OP_OUTPUT)
+            {
+                for (auto &m : n->output->output)
+                {
+                    topological_sort_visit(L, mark, m);
+                }
+            }
+
+            (*mark)[n] = true;
+            L->insert(L->begin(), n); // push n to head
+        }
+    }
+
+    static OpGraphOp *topological_sort_check_marked(std::vector<OpGraphOp *> nodes, std::map<OpGraphOp *, bool> *mark)
+    {
+        for (auto &n : nodes)
+        {
+            if (!(*mark)[n])
+                return n;
+        }
+        return NULL;
+    }
+
+
+    
+    void updateOveruse(MRRG *mrrg)
+    {
+        overuse_num_ = 0;
+        for (auto &node : mrrg->routing_nodes)
+        {
+            if (occupancy[node] > node->capacity)
+            {
+                overuse_num_ += occupancy[node]-  node->capacity;
+            }
+        }
+    }
+
+    void initLisa(std::vector<std::pair<int, int>> lisa_edges, std::set<std::pair<int, int>> lisa_backedges, std::map<OpGraphOp*, int>  node_to_id,  std::map<int, OpGraphOp*>  id_to_node, std::shared_ptr<std::map<int, node_label>> dfg_label){
+        dfg_label_ = dfg_label;
+        lisa_backedges_ = lisa_backedges;
+        lisa_edges_ = lisa_edges;
+        node_to_id_ = node_to_id;
+        id_to_node_ = id_to_node;
+
+        for(auto node: node_to_id_){
+            node_children_[node.second] =  std::set<int>();
+        }
+        for(auto edge: lisa_edges){
+            node_children_[edge.first].insert(edge.second);
+        }
+       
+       
+    }
+
+    template <typename type>
+    std::vector<type> vector_intersect(std::vector<type> v1, std::vector<type> v2);
+    MRRGNode *  getRandomFU(MRRG *mrrg, OpGraphOp *op);
+    // MRRGNode *  getRandomFUWithII(MRRG *mrrg, OpGraphOp *op);
+    
+    float updateTemperature(float t, float acceptance_rate);
+    void topological_sort(OpGraph *g);
+    std::vector<std::pair<MRRGNode *, int>> candidate_fu_intersect(std::vector<std::pair<MRRGNode *, int>> v1, std::vector<std::pair<MRRGNode *, int>> v2);
+    std::vector<MRRGNode *> filterCanMapOp(std::vector<MRRGNode *> fus, OpGraphOp const *op);
+
+    std::map<int, pos3d> dumpMapping(std::shared_ptr<OpGraph> opgraph, int &max_latency);
+    std::string printMapping(){
+        int test_latency =0 ;
+        auto dumpedmapping = dumpMapping(opgraph_, test_latency);
+        // std::cout<<"dumpedmapping "<<dumpedmapping.size()<<"\n";
+        std::stringstream result;
+        for(auto node: opgraph_->op_nodes){
+            if(mapping.find(node)!=mapping.end() && mapping[node].size() > 0){
+                result<<node->name<<" "<<mapping[node].front()->getFullName()<<"\n";
+            }
+            
+        }
+         result<< lisa_ctrl->mappingToStr(dumpedmapping, test_latency);
+         return result.str();
+    }
+
+    bool optimizeMapping(OpGraph *opgraph, MRRG *mrrg);
+    MRRGNode *  getLISAFU(std::shared_ptr<OpGraph> opgraph, MRRG *mrrg, OpGraphOp *op, int accepted = 1 , int total_tried =1, int num_swap = 1);
+    std::vector<MRRGNode*> getDesiredFu(MRRG *mrrg, int start_II, int end_II, OpGraphOp *op);
+    std::pair<int,int> getIntervalByScheduleOrder(std::shared_ptr<OpGraph> opgraph, std::map<int, pos3d> & dumped_mapping, OpGraphOp *op, int scheduler_order );
+
+    std::map<MRRGNode *, int> getCostByComm(MRRG *mrrg, std::shared_ptr<OpGraph> opgraph, std::map<int, pos3d> & dumped_mapping, std::vector<MRRGNode *> candidates, OpGraphOp *op );
+    std::map<MRRGNode *, int> getCostByAssociation(std::shared_ptr<OpGraph> opgraph, std::map<int, pos3d> & dumped_mapping, std::vector<MRRGNode *> candidates, OpGraphOp *op, int start_II );
+    std::map<MRRGNode *, int> getCostForSameLevelNode(std::shared_ptr<OpGraph> opgraph, std::map<int, pos3d> & dumped_mapping, std::vector<MRRGNode *> candidates, OpGraphOp *op );
+
+     MRRGNode *  getCloseRandomFU(MRRG *mrrg, OpGraphOp *op, MRRGNode * old_fu){
+        return  getCloseRandomFU(mrrg, op,  old_fu,  cgra_x_,  cgra_y_ );
+     }
+    MRRGNode *  getCloseRandomFU(MRRG *mrrg, OpGraphOp *op, MRRGNode * old_fu, int max_physical_dis,  int max_temp_dis );
+     MRRGNode* getRoutingNode(MRRG *mrrg, int x, int y, int t);
+
+    bool enable_eval_routing_priority(){ lisa_eval_routing_priority = true;}
+
+
+    bool routeOp_withfailed_node(OpGraphOp *op, MRRG *mrrg, std::set<OpGraphOp *> &failed);
+
+    void setLISAController( std::shared_ptr<LISAController> ctrl,int cgra_x,int cgra_y){ 
+        lisa_ctrl = ctrl;
+        cgra_x_ = cgra_x;
+        cgra_y_ = cgra_y;
+         node_asap_ = lisa_ctrl->getNodeASAP();
+        }
+    void enableTraining(){ is_training = true;}
+    void disableTraining(){ is_training = false;}
+
+    int MOD(int cycle){
+        return (cycle + 100 * II_)%II_;
+    }
+
+     bool place_and_routing_parallel =  false;
+
+    
+protected:
+    int rand_seed;
+    float pfactor;
+    float pfactor_factor;
+    float const_temp_factor;
+    int swap_factor;
+    float cold_accept_rate;
+    float updateTempConst(float temp);
+
+private:
+    bool inner_place_and_route_loop(OpGraph *opgraph, MRRG *mrrg, float temp, float *accept_rate);
+    MRRGNode *getCandidateFU(MRRG *mrrg, OpGraphOp *op);
+    MRRGNode *getRandomUnoccupiedFU(MRRG *mrrg, OpGraphOp *op);
+    OpGraphOp *getOpNodePtr(OpGraph *opgraph, MRRGNode *n);
+
+    OpMapping ripUpOp(OpGraphOp *op, float *cost = NULL);
+    void restoreOp(OpMapping oldmap);
+
+    bool routeOp(OpGraphOp *op, MRRG *mrrg);
+    bool routeOpInput(OpGraphOp *op, MRRG *mrrg);
+    bool routeVal(OpGraphVal *val,  OpGraphOp *output_op = NULL) ;
+    bool placeOp(OpGraphOp *op, MRRGNode *n);
+
+    bool checkOveruse(MRRG *mrrg);
+
+    // mapping/unmapping
+    void mapMRRGNode(OpGraphNode *, MRRGNode *node);
+    void unmapMRRGNode(OpGraphNode *, MRRGNode *node);
+    std::vector<MRRGNode *> unmapAllMRRGNodes(OpGraphNode *);
+    void mapAllMRRGNodes(OpGraphNode *, std::vector<MRRGNode *> nodes);
+    MRRGNode *getMappedMRRGNode(OpGraphOp *op);
+
+    // mapping and occupancy
+    // std::map<MRRGNode *, std::vector<OpGraphNode *>> occupancy_detail;
+    std::map<MRRGNode *, int> occupancy;
+    std::map<OpGraphNode *, std::vector<MRRGNode *>> mapping;
+
+    // Costing
+    float getTotalOpCost(OpGraphOp *op);
+    float getCost(MRRGNode *n);
+    float getCost(MRRG *n);
+    float getCost(OpGraphNode *n);
+    float getCost(OpGraph *opgraph);
+    bool compare_mrrg_node_cost(MRRGNode *a, MRRGNode *b);
+
+
+
+    //for lisa
+    std::vector<std::pair<int, int>> lisa_edges_;//useless
+    std::set<std::pair<int, int>> lisa_backedges_;//useless
+    std::map<OpGraphOp*, int>  node_to_id_;
+    std::map<int, OpGraphOp*>  id_to_node_;
+    std::map<int, int> node_asap_;
+
+    std::map<OpGraphOp*, int> overuse_counter;
+
+
+    std::map<int, std::set<int>> node_children_;
+
+    std::shared_ptr<std::map<int, node_label>> dfg_label_;
+
+    std::set<op_edge, op_edge_comp> op_edges_;
+
+    bool allow_overuse = false;
+
+    int MAX_OVERUSE = 1000;
+
+    int overuse_num_ = 0;
+
+    int II_ = 0;
+
+    MRRG *mrrg_ = NULL;
+
+    const int MAX_SECOND_IN_ROUTING = 2;
+
+    std::set<MRRGNode *> overuse_fu;
+
+    std::set<mpos> mapped_pos;
+
+    std::shared_ptr<LISAController> lisa_ctrl;
+
+    int cgra_x_ = 0;
+    int cgra_y_ = 0;
+
+    std::shared_ptr<OpGraph> opgraph_;
+
+    bool is_training = false;
+
+    bool finish_init = false;
+
+
+    bool lisa_eval_routing_priority = false;
+
+   
+
+    std::chrono::steady_clock::time_point mapper_start_time;
+
+     std::set<OpGraphOpCode> lat_opcode ={OpGraphOpCode::OPGRAPH_OP_NOP ,
+    OpGraphOpCode::OPGRAPH_OP_SEXT,
+    OpGraphOpCode::OPGRAPH_OP_ZEXT,
+    OpGraphOpCode::OPGRAPH_OP_TRUNC,
+    OpGraphOpCode::OPGRAPH_OP_PHI,
+    OpGraphOpCode::OPGRAPH_OP_ADD,
+    OpGraphOpCode::OPGRAPH_OP_SUB,
+    OpGraphOpCode::OPGRAPH_OP_MUL,
+    OpGraphOpCode::OPGRAPH_OP_DIV,
+    OpGraphOpCode::OPGRAPH_OP_AND,
+    OpGraphOpCode::OPGRAPH_OP_OR,
+    OpGraphOpCode::OPGRAPH_OP_XOR,
+    OpGraphOpCode::OPGRAPH_OP_SHL,
+    OpGraphOpCode::OPGRAPH_OP_SHRA,
+    OpGraphOpCode::OPGRAPH_OP_SHRL,
+    OpGraphOpCode::OPGRAPH_OP_LOAD,
+    OpGraphOpCode::OPGRAPH_OP_STORE,
+    OpGraphOpCode::OPGRAPH_OP_GEP,
+    OpGraphOpCode::OPGRAPH_OP_ICMP,
+    } ;
+
+
+};
+
+#endif
diff -Nur cgra_me/inc/CGRA/lisa/LISASchedule.h lisa/cgra_me/inc/CGRA/lisa/LISASchedule.h
--- cgra_me/inc/CGRA/lisa/LISASchedule.h	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/inc/CGRA/lisa/LISASchedule.h	2022-02-28 16:37:25.912775566 +0800
@@ -0,0 +1,48 @@
+#include <ctime>
+#include <set>
+#include <map>
+#include <unistd.h>
+#include <iostream>
+#include <fstream>
+#include <unordered_set>
+#include <sstream>
+#include <tuple> 
+#include <algorithm> 
+#include <CGRA/debug.h>
+#include <CGRA/lisa/LISADFG.h>
+
+
+
+
+#ifndef ___LISASCHEDULE_H__
+#define ___LISASCHEDULE_H__
+
+struct pos3d{
+  int x;
+  int y;
+  int t;
+
+  std::string toStr(){
+    return "("+std::to_string(x)+","+std::to_string(y)+","+std::to_string(t)+")";
+  }
+};
+class LISASchedule{
+  friend class LISAController;
+  public:
+    LISASchedule(LISADFG* dfg, int x, int y, int t, std::map<int, pos3d> & mapping);
+
+    int getOffset(int x, int y, int t){
+      return t*x_*y_ + x * y_ + y;
+    }
+
+    std::string simpleSchedToString();
+    std::string complexSchedToString();
+  private:
+    int x_;
+    int y_;
+    int t_;
+    // int *ts_mapping_ ; //temporal_spatial_mapping
+    std::map<int, pos3d> mapping_;
+    LISADFG* dfg_;
+};
+#endif
\ No newline at end of file
diff -Nur cgra_me/inc/CGRA/Mapper.h lisa/cgra_me/inc/CGRA/Mapper.h
--- cgra_me/inc/CGRA/Mapper.h	2018-05-09 09:34:57.000000000 +0800
+++ lisa/cgra_me/inc/CGRA/Mapper.h	2022-02-28 16:37:25.908775556 +0800
@@ -39,27 +39,78 @@
 
 #include <CGRA/CGRA.h>
 #include <CGRA/OpGraph.h>
+#include <CGRA/debug.h>
 #include <CGRA/Mapping.h>
 
+
+#define systolic_array_x 7
+#define systolic_array_y 7
+struct mpos{
+    int x;
+    int y;
+    unsigned int t;
+    bool operator==(const mpos& other) const {
+    return x == other.x && y == other.y && t == other.t;
+    }
+
+     bool operator<(const mpos& other) const {
+    return x < other.x || y < other.y ;
+    }
+};
+
+
 enum class MapperType
 {
     ILPMapper = 0,
-    AnnealMapper = 1
+    AnnealMapper = 1,
+    LISAMapper = 2
 };
 
+typedef struct
+{
+    std::map<OpGraphNode*, std::vector<MRRGNode*>> mapping;
+} OpMapping;
+
 class Mapper
 {
     public:
         virtual Mapping mapOpGraph(std::shared_ptr<OpGraph> opgraph);
-        virtual Mapping mapOpGraph(std::shared_ptr<OpGraph> opgraph, int II) = 0;
+        virtual Mapping mapOpGraph(std::shared_ptr<OpGraph> opgraph, int II, std::string arch_model_name) = 0;
         void genBitstream();
 
 
+
         virtual ~Mapper();
         static std::unique_ptr<Mapper> createMapper(MapperType mt, std::shared_ptr<CGRA> cgra, int timelimit, const std::map<std::string, std::string> & args);
 
     protected:
         Mapper(std::shared_ptr<CGRA> cgra, int timelimit);
+        std::string arch_model_name_;
+
+        std::map<std::pair<int, int>, int> systolic_pe_index;
+        
+        int sys_arr[systolic_array_x][systolic_array_y] =
+        {
+            {0,0,0,0,0,0,0},
+            {0,1,2,1,2,2,0},
+            {0,2,1,1,1,1,0},
+            {0,2,1,2,1,1,0},
+            {0,2,1,1,2,1,0},
+            {0,2,1,2,1,1,0},
+            {0,0,0,0,0,0,0}
+        };
+
+        //  int sys_arr[systolic_array_x][systolic_array_y] =
+        // {
+        //     {0,0,0,0,0,0,0, 0},
+        //     {0,1,2,2,2,2,2, 0},
+        //     {0,2,1,1,1,1,1, 0},
+        //     {0,2,1,1,1,1,1, 0},
+        //     {0,2,1,1,2,1,2, 0},
+        //     {0,2,1,1,1,1,2, 0},
+        //     {0,2,2,1,2,1,2, 0},
+        //     {0,0,0,0,0,0,1, 0}
+        // };
 
         std::shared_ptr<CGRA>   cgra;       // Architecture Object
         int     timelimit;  // The mapper timeout in seconds
diff -Nur cgra_me/inc/CGRA/Module.h lisa/cgra_me/inc/CGRA/Module.h
--- cgra_me/inc/CGRA/Module.h	2018-05-09 09:34:57.000000000 +0800
+++ lisa/cgra_me/inc/CGRA/Module.h	2022-02-28 16:37:25.908775556 +0800
@@ -66,7 +66,7 @@
 #define ON true
 #define OFF false
 // Determine if we want to print out debug messages
-#define DEBUG_MODE OFF
+#define DEBUG_MODE ON
 // DEFAULT DATA SIZE FOR MODULES, can change here
 #define DEFAULT_SIZE 32
 // A port size of zero in memory indicates that it is parameterized. The actual port size will then be determined by the module size
@@ -358,7 +358,7 @@
 {
     public:
         // Constructor takes in a name, the operations that the unit supports, and the size of the module
-        FuncUnit(std::string name, std::vector<OpGraphOpCode> supported_modes = {OPGRAPH_OP_ADD, OPGRAPH_OP_MUL}, unsigned size = DEFAULT_SIZE, int II = 1, int latency = 0);
+        FuncUnit(std::string name, std::vector<OpGraphOpCode> supported_modes = {OPGRAPH_OP_ADD, OPGRAPH_OP_MUL}, unsigned size = DEFAULT_SIZE, int II = 1, int latency = 1);
         virtual void GenFunctionality();
         virtual void GenConnections();
         virtual std::vector<BitSetting> getBitConfig(
@@ -377,7 +377,7 @@
         };
         int getLatency() const
         {
-            return 0; //TODO: NEED TO SORT out II and LATENCY if different operations on the same func unit have different II/Latency
+            return 1; //TODO: NEED TO SORT out II and LATENCY if different operations on the same func unit have different II/Latency
             //    return selected_mode.Latency;
         };
         // For the bitstream generation. Maps an operation to a set of bits
diff -Nur cgra_me/inc/CGRA/MRRG.h lisa/cgra_me/inc/CGRA/MRRG.h
--- cgra_me/inc/CGRA/MRRG.h	2018-05-09 09:34:57.000000000 +0800
+++ lisa/cgra_me/inc/CGRA/MRRG.h	2022-02-28 16:37:25.908775556 +0800
@@ -37,7 +37,7 @@
 #include <string>
 #include <vector>
 #include <map>
-
+#include <assert.h> 
 #include <CGRA/OpGraph.h>
 
 typedef enum
@@ -67,14 +67,91 @@
         MRRGNode(Module* parent, unsigned int cycle, std::string name, MRRGNode_Type type = MRRG_NODE_ROUTING, bool essential = false);
 
 
+        void makeSystolicPE(int index){
+            if(index == 0){
+                return;
+            }else if(index == 1){
+                //make it as as add PE;
+                std::vector<OpGraphOpCode> temp_ops;
+                for(auto op: supported_ops){
+                    if(op != OPGRAPH_OP_DIV || op != OPGRAPH_OP_MUL){
+                        temp_ops.push_back(op);
+                    }
+                }
+                supported_ops = temp_ops;
+            }else if (index == 2){
+                std::vector<OpGraphOpCode> temp_ops;
+                for(auto op: supported_ops){
+                    if(op != OPGRAPH_OP_ADD || op != OPGRAPH_OP_SUB){
+                        temp_ops.push_back(op);
+                    }
+                }
+                supported_ops = temp_ops;
+            }else{
+                assert(false);
+            }
+        }
+
+        void checkNonMemoryPE(){
+            if(x_ != 1){
+                std::vector<OpGraphOpCode> temp_ops;
+                for(auto op: supported_ops){
+                    if(op != OPGRAPH_OP_LOAD || op != OPGRAPH_OP_STORE){
+                        temp_ops.push_back(op);
+                    }
+                }
+                supported_ops = temp_ops;
+            }
+        }
+
+        void removeSystolicNonMemoryPE(int systolic_x){
+            if(x_ != 1 || y_!=1 || y_ != systolic_x-1 ||x_ != systolic_x-1 ){
+                std::vector<OpGraphOpCode> temp_ops;
+                for(auto op: supported_ops){
+                    if(op != OPGRAPH_OP_LOAD || op != OPGRAPH_OP_STORE){
+                        temp_ops.push_back(op);
+                    }
+                }
+                supported_ops = temp_ops;
+            }
+        }
+
+        void removeSystolicLeftStore(int systolic_x){
+            if(x_ == 1 ){
+                std::vector<OpGraphOpCode> temp_ops;
+                for(auto op: supported_ops){
+                    if( op != OPGRAPH_OP_STORE){
+                        temp_ops.push_back(op);
+                    }
+                }
+                supported_ops = temp_ops;
+            }
+        }
+
+        void removeSystolicRightLoad(int systolic_x){
+            if(x_ == systolic_x-1 ){
+                std::vector<OpGraphOpCode> temp_ops;
+                for(auto op: supported_ops){
+                    if( op != OPGRAPH_OP_LOAD){
+                        temp_ops.push_back(op);
+                    }
+                }
+                supported_ops = temp_ops;
+            }
+        }
+
+
         // Node properties
-        std::string name;
+
         MRRGNode_Type type;
         NodePortType pt;
 
         bool canMapOp(OpGraphOp const * op);
         std::vector<OpGraphOpCode> supported_ops;
 
+        std::vector<OpGraphOpCode> supported_add_ops = {OPGRAPH_OP_CONST,OPGRAPH_OP_ADD,OPGRAPH_OP_SUB, OPGRAPH_OP_LOAD, OPGRAPH_OP_STORE };
+        std::vector<OpGraphOpCode> supported_mul_ops = {OPGRAPH_OP_CONST,OPGRAPH_OP_MUL,OPGRAPH_OP_DIV , OPGRAPH_OP_LOAD, OPGRAPH_OP_STORE };
+
         std::vector<MRRGNode*>  fanout;
         std::vector<MRRGNode*>  fanin;
         std::map<int, MRRGNode*> operand;
@@ -83,6 +160,8 @@
         Module* parent;
 
         std::string getFullName();
+
+        void setName(std::string name_);
         const std::string& getHierarchyQualifiedName() const { return name; }
 
         unsigned int cycle;
@@ -99,6 +178,11 @@
 
         // variable
         MRRGNode* prev;
+
+        int x_;
+        int y_;
+
+        int     occupancy = 0;
 /*
         // fixed mapper data
         float   base_cost;
@@ -114,6 +198,8 @@
     private:
 
         friend std::ostream& operator<< (std::ostream& out, const MRRGNode& node);
+        std::string name;
+
 };
 
 class MRRG
@@ -133,10 +219,32 @@
         // Checks MRRG properties, links etc
         bool verify();
 
+        int distance (MRRGNode* a, MRRGNode* b);
+
         unsigned int II;
         void print_dot();
         void print_dot_clustered();
 
+        void makeSystolicArray(std::map<std::pair<int,int>, int> systolic_location, int systolic_x){
+            for(auto node: function_nodes){
+                assert(systolic_location.find(std::make_pair(node->x_, node->y_)) != systolic_location.end());
+                node->makeSystolicPE(systolic_location[std::make_pair(node->x_, node->y_)]);
+            }
+            for(auto node: function_nodes){
+                node->removeSystolicLeftStore(systolic_x);
+                node->removeSystolicNonMemoryPE(systolic_x);
+                node->removeSystolicRightLoad(systolic_x);
+            }
+        }
+
+         void makeLeftMostMemoryAccess(){
+            for(auto node: function_nodes){
+                // assert(systolic_location.find(std::make_pair(node->x_, node->y_)) != systolic_location.end());
+                node->checkNonMemoryPE();
+            }
+        }
+
+
         std::vector<std::map<std::string, MRRGNode*>> nodes;
 
         std::vector<MRRGNode*> function_nodes;
diff -Nur cgra_me/Makefile lisa/cgra_me/Makefile
--- cgra_me/Makefile	2018-05-09 09:34:57.000000000 +0800
+++ lisa/cgra_me/Makefile	2022-02-28 16:37:25.868775474 +0800
@@ -2,7 +2,7 @@
 #Two possible values
 #debug
 #release
-BUILD_TYPE = release
+BUILD_TYPE = debug
 
 #Build directory
 BUILD_DIR = ./build
diff -Nur cgra_me/README.md lisa/cgra_me/README.md
--- cgra_me/README.md	2018-05-09 09:34:57.000000000 +0800
+++ lisa/cgra_me/README.md	2022-02-28 16:37:25.868775474 +0800
@@ -1 +1,26 @@
-**Please see our [website](http://cgra-me.ece.utoronto.ca/) for full documentation!** 
+
+
+## Get stat by command line (by single benchmark)
+
+
+* ILP:  
+`$CGRA_MAPPER  -m 0 --II 20  -g ./benchmarks/microbench/conv2/my_graph_loop.dot  b --xml ./arch/simple/target_arch/arch-homo-orth_2_2.xml --cgra_x 4 --cgra_y 4`
+* SA:  
+`$CGRA_MAPPER  -m 1 --II 20  -g ./benchmarks/microbench/conv2/my_graph_loop.dot  b --xml ./arch/simple/target_arch/arch-homo-orth_2_2.xml --cgra_x 4 --cgra_y 4`
+* LISA-GNN:  
+`conda activate lisa`  
+`$CGRA_MAPPER  -m 2 --II 20  --inef  -g ./benchmarks/microbench/conv2/my_graph_loop.dot  b --xml ./arch/simple/target_arch/arch-homo-orth_2_2.xml --cgra_x 4 --cgra_y 4`
+* Generate training data and dump label (add dfg_id)
+`$CGRA_MAPPER  -m 2 --II 20  --dfg_id dfg_id --training --training_output  -g ./benchmarks/microbench/conv2/my_graph_loop.dot  b --xml ./arch/simple/target_arch/arch-homo-orth_2_2.xml --cgra_x 4 --cgra_y 4`
+
+
+
+## Get stat by script (by batch)
+python run_exper.py $option  
+* Generate data label: `gnn_training_data`
+* Get LISA output: `gnn_lisa`
+* Get stat for ILP ans SA: `baseline`
+  
+## draw figure for stat
+python get_stat.py file_path
+
diff -Nur cgra_me/result/.gitignore lisa/cgra_me/result/.gitignore
--- cgra_me/result/.gitignore	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/result/.gitignore	2022-02-28 16:37:25.912775566 +0800
@@ -0,0 +1,4 @@
+# Ignore everything in this directory
+*
+# Except this file
+!.gitignore
diff -Nur cgra_me/run_exper.py lisa/cgra_me/run_exper.py
--- cgra_me/run_exper.py	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/run_exper.py	2022-02-28 16:37:25.912775566 +0800
@@ -0,0 +1,345 @@
+from subprocess import Popen, PIPE
+import threading
+import time
+import random
+import queue
+import os
+import sys
+from pathlib import Path
+
+arch_folder = "./arch/simple/target_arch/"
+benchmark_folder = "./benchmarks/polybench/"
+arch_prefix = "arch-homo-orth"
+# target_arch = [(4,4),  (4,4, "leftmostmemory"), (4,4, "1reg"),(3,3), (5,5, "systolic")
+all_arch = [ (4,4),  (3,3),(4,4, "1reg"), (4,4, "leftmostmemory"), (8,8), (5,5, "systolic")]
+target_arch = [ (4,4),  (3,3),(4,4, "1reg"), (4,4, "leftmostmemory"), (8,8), (5,5, "systolic")]
+gnn_training_data_target_arch = [  (8,8)]
+
+target_bench = ["2mm", "atax", "bicg", "cholesky", "doitgen", "gemm", "gemver", "gesummv", "mvt", "symm", "syr2k", "syrk", "trmm" ]
+unroll_bench = ["2mm_unroll", "atax_unroll", "bicg_unroll", "cholesky_unroll", "doitgen_unroll", "gemm_unroll", "gemver_unroll", "gesummv_unroll", "mvt_unroll", "symm_unroll", "syr2k_unroll", "syrk_unroll", "trmm_unroll" ]
+unroll_5_bench = ["2mm_unroll_5", "atax_unroll_5", "bicg_unroll_5", "cholesky_unroll_5", "doitgen_unroll_5", "gemm_unroll_5", "gemver_unroll_5", "gesummv_unroll_5", "mvt_unroll_5", "symm_unroll_5", "syr2k_unroll_5", "syrk_unroll_5", "trmm_unroll_5" ]
+
+process_num =16 # number of cpu cores to be used
+
+max_II = 24
+
+
+if len(sys.argv) < 5 :
+    assert(False and "Expect at least foure arguments")
+
+arch_idx = int (sys.argv[2]) 
+target_arch = []
+target_arch.append(all_arch[arch_idx])
+
+unroll_factor = str(sys.argv[3])
+if unroll_factor == "2":
+    target_bench = unroll_bench
+elif unroll_factor != "5":
+    target_bench = unroll_5_bench
+
+
+process_num = int (sys.argv[4])
+
+print("target architecture:", arch_prefix + "_" + str(target_arch[0][0]) + "x" + str(target_arch[0][1]))
+print("target bench:", target_bench)
+print("core number:", process_num)
+
+
+
+
+class BasicTask(object):
+
+    def __init__(self, name="", cmd="", args=[], output="none"):
+        self._cmd = cmd
+        self._args = args
+        self._name = name
+        self.output = output
+        pass
+
+    def run2(self):
+        print
+        'start task: %s' % self._name
+        for i in range(10):
+            n = random.randint(2, 5)
+            print
+            '%s is running..., sleep for %d sec ' % (self._name, n)
+            time.sleep(n)
+        print
+        'End task: %s' % self._name
+
+    def run(self):
+        if self._cmd:
+            print
+            'Run command \'%s\' with arguments: %s' % (self._cmd, self._args)
+            cmd_line = [self._cmd] + self._args
+            print(cmd_line)
+            if "none" in self.output:
+                p = Popen(cmd_line)
+            else:
+                file =  open(self.output, "w")
+                p = Popen(cmd_line, stdout= file, stderr=file)
+            p.wait()
+        elif self._args:
+            p = Popen(self._args)
+            p.wait()
+        else:
+            print
+            "The command is NULL!"
+
+    def setRunCommand(self, cmd):
+        self._command = cmd
+
+    def setArgument(self, args=[]):
+        self._args = args
+
+    def setName(self, name):
+        self._name = name
+
+    def getOutput(self):
+        pass
+
+    def getError(self):
+        pass
+
+    def getWarning(self):
+        pass
+
+
+class TaskManager(object):
+    def __init__(self, n):
+        self._pool = []
+        self._bTerminated = False
+        self._tasks = queue.Queue()
+        self._tasks_lock = threading.Lock()
+        self._sem = threading.Semaphore(0)
+        self._num_task = n
+
+        for i in range(n):
+            name = 'Thread%30d' % i
+            t = threading.Thread(target=self._run, name=name)
+            self._pool.append(t)
+            # t.start()
+
+    def addTask(self, task):
+        self._tasks_lock.acquire()
+        self._tasks.put(task)
+        self._tasks_lock.release()
+
+    def _pick(self):
+        print
+        'Rest tasks: %d' % self._tasks.qsize()
+        if self._bTerminated:
+            return None
+
+        self._tasks_lock.acquire()
+
+        t = None
+        if self._tasks.qsize() > 0:
+            t = self._tasks.get()
+
+        self._tasks_lock.release()
+
+        return t
+
+    def _run(self):
+        # self._sem.acquire()
+        while True:
+            if self._bTerminated:
+                break
+            t = self._pick()
+            if t:
+                t.run()
+            else:
+                break
+
+    def start(self):
+        for t in self._pool:
+            t.start()
+
+        for t in self._pool:
+            t.join()
+
+    def stop(self):
+        self._bTerminated = True
+        self.start()
+
+    def setNumThreads(self, n):
+        self._num_task = n
+
+
+
+tm = TaskManager(process_num)
+
+if not os.path.exists('lisa_training_log'):
+        os.makedirs('lisa_training_log')
+
+
+if len(sys.argv) >1 and "t_lisa" in str(sys.argv[1]):
+    os.system('cp ./build/bin/cgrame ./build/bin/training_cgrame')
+    for arch in target_arch:
+        arch_max_II = max_II
+        arch_file_name = arch_prefix + "_" + str(arch[0]) + "_" + str(arch[1])
+        if len(arch)>2:
+            arch_file_name += "_" + str(arch[2])
+        arch_filename =  arch_folder + arch_file_name+".xml"
+        print(arch_filename)
+        arch_model_name =  "cgra_me_"+str(arch[0]) + "_" + str(arch[1])
+        if len(arch)>2:
+            arch_model_name += "_" + str(arch[2])
+            if "systolic" in str(arch[2]): # I set this as to get a better label, the max-II of final evaluation should be 1
+                arch_max_II = 2
+        
+
+        #iterate benchmark 
+        for bench in target_bench:
+            bench_filename =  benchmark_folder + bench + "/my_graph_loop.dot"
+            print(bench_filename)
+
+            arg = [ "-m",  "2",  "--II", str(arch_max_II), "--arch_name",arch_model_name, "--training",  "--training_output", "lisa_training_log/" + bench + "_" + str(arch[0]) + "_" + str(arch[1]), "-g", bench_filename , "b",  "--xml", arch_filename, "--cgra_x",  str(arch[0] + 2),  "--cgra_y",  str(arch[1] + 2) ]
+            ts = BasicTask(name="schedule", cmd="./build/bin/training_cgrame", args=arg, output = "lisa_training_log/" + bench + "_" + arch_model_name + ".log")
+            tm.addTask(ts)
+elif len(sys.argv) >1 and "gnn_training_data" in str(sys.argv[1]):
+    os.system('cp ./build/bin/cgrame ./build/bin/gnn_data_cgrame')
+    if not os.path.exists('lisa_training_log/forgnn'):
+        os.makedirs('lisa_training_log/forgnn')
+    
+    start_indx = int(sys.argv[2])
+    end_indx = start_indx + process_num
+    if len(sys.argv) >3:
+        end_indx = int(sys.argv[3])
+    print("star-index",start_indx )
+    for arch in gnn_training_data_target_arch:
+        arch_max_II = max_II
+        arch_file_name = arch_prefix + "_" + str(arch[0]) + "_" + str(arch[1])
+        if len(arch)>2:
+            arch_file_name += "_" + str(arch[2])
+        arch_filename =  arch_folder + arch_file_name+".xml"
+        print(arch_filename)
+        arch_model_name =  "cgra_me_"+str(arch[0]) + "_" + str(arch[1])
+        if len(arch)>2:
+            arch_model_name += "_" + str(arch[2])
+            if "systolic" in str(arch[2]): # I set this as to get a better label, the max-II of final evaluation should be 1
+                arch_max_II = 2
+        if not os.path.exists("../lisa_gnn/data/labels/"+arch_model_name):
+            os.makedirs("../lisa_gnn/data/labels/"+arch_model_name)
+            Path("../lisa_gnn/data/labels/"+arch_model_name+"/label_evaluate.txt").touch()
+
+       
+        for i in range (start_indx, end_indx):
+            bench = "gnn_data" + str(i)
+            bench_filename =  "../lisa_gnn/data/cgra_me/cgra_me/" + str(i) + ".dot"
+            print(bench_filename)
+
+            arg = [ "-m",  "2", "--arch_name",arch_model_name,  "--II",  str(arch_max_II),  "--dfg_id", str(i),  "--training",  "--training_output", "lisa_training_log/forgnn/" + bench + "_" + str(arch[0]) + "_" + str(arch[1]), "-g", bench_filename , "b",  "--xml", arch_filename, "--cgra_x",  str(arch[0] + 2),  "--cgra_y",  str(arch[1] + 2) ]
+            ts = BasicTask(name="schedule", cmd="./build/bin/gnn_data_cgrame", args=arg, output = "lisa_training_log/forgnn/" + bench + "_" + arch_model_name+ ".log")
+            tm.addTask(ts)
+elif len(sys.argv) >1 and "gnn_lisa" in str(sys.argv[1]):
+    os.system('cp ./build/bin/cgrame ./build/bin/gnn_lisa_cgrame')
+    for arch in target_arch:
+        arch_max_II = max_II
+        arch_file_name = arch_prefix + "_" + str(arch[0]) + "_" + str(arch[1])
+        if len(arch)>2:
+            arch_file_name += "_" + str(arch[2])
+            if "systolic" in str(arch[2]): # I set this as to get a better label, the max-II of final evaluation should be 1
+                arch_max_II = 1
+        arch_filename =  arch_folder + arch_file_name+".xml"
+        print(arch_filename)
+        arch_model_name =  "cgra_me_"+str(arch[0]) + "_" + str(arch[1])
+        if len(arch)>2:
+            arch_model_name += "_" + str(arch[2])
+
+        #iterate benchmark 
+        for bench in target_bench:
+            bench_filename =  benchmark_folder + bench + "/my_graph_loop.dot"
+            print(bench_filename)
+
+            arg = [ "-m",  "2", "--arch_name",arch_model_name,  "--II", str(arch_max_II),  "--inef", "-g", bench_filename , "b",  "--xml", arch_filename, "--cgra_x",  str(arch[0] + 2),  "--cgra_y",  str(arch[1] + 2) ]
+            ts = BasicTask(name="schedule", cmd="./build/bin/gnn_lisa_cgrame", args=arg)
+            tm.addTask(ts)
+elif len(sys.argv) >1 and "eval_rouing_priority" in str(sys.argv[1]):
+    os.system('cp ./build/bin/cgrame ./build/bin/eval_routing_priority')
+    for arch in target_arch:
+        arch_max_II = max_II
+        arch_file_name = arch_prefix + "_" + str(arch[0]) + "_" + str(arch[1])
+        if len(arch)>2:
+            arch_file_name += "_" + str(arch[2])
+            if "systolic" in str(arch[2]): # I set this as to get a better label, the max-II of final evaluation should be 1
+                arch_max_II = 1
+        arch_filename =  arch_folder + arch_file_name+".xml"
+        print(arch_filename)
+        arch_model_name =  "cgra_me_"+str(arch[0]) + "_" + str(arch[1])
+        if len(arch)>2:
+            arch_model_name += "_" + str(arch[2])
+
+        #iterate benchmark 
+        for bench in target_bench:
+            bench_filename =  benchmark_folder + bench + "/my_graph_loop.dot"
+            print(bench_filename)
+
+            arg = [ "-m",  "2", "--arch_name",arch_model_name,  "--eval_routing_priority", "--II", str(arch_max_II),  "--inef", "-g", bench_filename , "b",  "--xml", arch_filename, "--cgra_x",  str(arch[0] + 2),  "--cgra_y",  str(arch[1] + 2) ]
+            ts = BasicTask(name="schedule", cmd="./build/bin/eval_routing_priority", args=arg)
+            tm.addTask(ts)
+elif len(sys.argv) >1 and "baseline" in str(sys.argv[1]):
+    #iterate arch file
+    os.system('cp ./build/bin/cgrame ./build/bin/baseline_cgrame')
+    for arch in target_arch:
+        arch_max_II = max_II
+        arch_file_name = arch_prefix + "_" + str(arch[0]) + "_" + str(arch[1])
+        if len(arch)>2:
+            arch_file_name += "_" + str(arch[2])
+            if "systolic" in str(arch[2]): # I set this as to get a better label, the max-II of final evaluation should be 1
+                arch_max_II = 1
+        arch_filename =  arch_folder + arch_file_name+".xml"
+        print(arch_filename)
+        arch_model_name =  "cgra_me_"+str(arch[0]) + "_" + str(arch[1])
+        if len(arch)>2:
+            arch_model_name += "_" + str(arch[2])
+        
+
+        #iterate benchmark 
+        for bench in target_bench:
+            bench_filename =  benchmark_folder + bench + "/my_graph_loop.dot"
+            print(bench_filename)
+
+            arg = [ "-m",  "0",  "--II",  str(arch_max_II),"--arch_name",arch_model_name,   "-g", bench_filename , "b",  "--xml", arch_filename, "--cgra_x", str(arch[0] + 2),  "--cgra_y",  str(arch[1] + 2)]
+            ts = BasicTask(name="schedule", cmd="./build/bin/baseline_cgrame", args=arg)
+            tm.addTask(ts)
+
+            arg = [ "-m",  "1",  "--II",  str(arch_max_II), "--arch_name",arch_model_name,  "-g", bench_filename , "b",  "--xml", arch_filename, "--cgra_x", str(arch[0] + 2),  "--cgra_y",  str(arch[1] + 2)]
+            ts = BasicTask(name="schedule", cmd="./build/bin/baseline_cgrame", args=arg)
+            tm.addTask(ts)
+
+            # arg = [ "-m",  "2",  "--II",  "24", "-g", bench_filename , "b",  "--xml", arch_filename, "--cgra_x",  str(arch[0] + 2),  "--cgra_y",  str(arch[1] + 2)]
+            # ts = BasicTask(name="schedule", cmd="./build/bin/cgrame", args=arg)
+            # tm.addTask(ts)
+elif len(sys.argv) >1 and "sa_more_time" in str(sys.argv[1]):
+    #iterate arch file
+    os.system('cp ./build/bin/cgrame ./build/bin/sa_more_time_cgrame')
+    for arch in target_arch:
+        arch_max_II = max_II
+        arch_file_name = arch_prefix + "_" + str(arch[0]) + "_" + str(arch[1])
+        if len(arch)>2:
+            arch_file_name += "_" + str(arch[2])
+            if "systolic" in str(arch[2]): # I set this as to get a better label, the max-II of final evaluation should be 1
+                arch_max_II = 1
+        arch_filename =  arch_folder + arch_file_name+".xml"
+        print(arch_filename)
+        arch_model_name =  "cgra_me_"+str(arch[0]) + "_" + str(arch[1])
+        if len(arch)>2:
+            arch_model_name += "_" + str(arch[2])
+        
+
+        #iterate benchmark 
+        for bench in target_bench:
+            bench_filename =  benchmark_folder + bench + "/my_graph_loop.dot"
+            print(bench_filename)
+            arg = [ "-m",  "1", "--sa_more_running_time",  "--II",  str(arch_max_II), "--arch_name",arch_model_name,  "-g", bench_filename , "b",  "--xml", arch_filename, "--cgra_x", str(arch[0] + 2),  "--cgra_y",  str(arch[1] + 2)]
+            ts = BasicTask(name="schedule", cmd="./build/bin/sa_more_time_cgrame", args=arg)
+            tm.addTask(ts)
+
+            # arg = [ "-m",  "2",  "--II",  "24", "-g", bench_filename , "b",  "--xml", arch_filename, "--cgra_x",  str(arch[0] + 2),  "--cgra_y",  str(arch[1] + 2)]
+            # ts = BasicTask(name="schedule", cmd="./build/bin/cgrame", args=arg)
+            # tm.addTask(ts)
+else:
+    print("should not happen!!!!!!!!!!!!!!!!!!!!!!!!")
+tm.start()
diff -Nur cgra_me/run_unmapped.py lisa/cgra_me/run_unmapped.py
--- cgra_me/run_unmapped.py	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/run_unmapped.py	2022-02-28 16:37:25.912775566 +0800
@@ -0,0 +1,207 @@
+from subprocess import Popen, PIPE
+import threading
+import time
+import random
+import queue
+import os
+import sys
+from pathlib import Path
+
+arch_folder = "./arch/simple/target_arch/"
+benchmark_folder = "../gnn/data/cgra_me/"
+arch_prefix = "arch-homo-orth"
+target_arch = [ (3,3),(4,4), (4,4, "1reg")]
+# target_arch = [ (3,3),(4,4), (4,4, "1reg"), (4,4, "leftmostmemory")]
+# target_bench = ["accumulate", "cap", "matrixmultiply", "conv2", "conv3", "mac", "mac2", "mults1", "mults2" ]
+target_bench = []
+target_bench.append([1,15,21,25,31,32,34,55,64,65,68,73,81,89,102,108,115,127,130,131])
+target_bench.append([1,4,6,13,25,37,47,49,50,66,67,68,70,76,78,82,85,99,103,105])
+target_bench.append( [1,5,8,13,20,22,25,32,34,37,38,45,52,56,68,76,78,80,93,94])
+# target_bench.append([1,5,6,7,8,10,11,13,15,16,19,20,21,22,23,25,26,27,28,29])
+# target_bench = ["2mm_unroll", "atax_unroll", "bicg_unroll", "cholesky_unroll", "doitgen_unroll", "gemm_unroll", "gemver_unroll", "gesummv_unroll", "mvt_unroll", "symm_unroll", "syr2k_unroll", "syrk_unroll", "trmm_unroll" ]
+# target_bench = ["cap", "conv3", "mac2",  "mults2" ]
+# target_bench = ["mac"]
+process_num =45 # number of cpu cores to be used
+
+max_II = 24
+
+class BasicTask(object):
+
+    def __init__(self, name="", cmd="", args=[], output="none"):
+        self._cmd = cmd
+        self._args = args
+        self._name = name
+        self.output = output
+        pass
+
+    def run2(self):
+        print
+        'start task: %s' % self._name
+        for i in range(10):
+            n = random.randint(2, 5)
+            print
+            '%s is running..., sleep for %d sec ' % (self._name, n)
+            time.sleep(n)
+        print
+        'End task: %s' % self._name
+
+    def run(self):
+        if self._cmd:
+            print
+            'Run command \'%s\' with arguments: %s' % (self._cmd, self._args)
+            cmd_line = [self._cmd] + self._args
+            print(cmd_line)
+            if "none" in self.output:
+                p = Popen(cmd_line)
+            else:
+                file =  open(self.output, "w")
+                p = Popen(cmd_line, stdout= file, stderr=file)
+            p.wait()
+        elif self._args:
+            p = Popen(self._args)
+            p.wait()
+        else:
+            print
+            "The command is NULL!"
+
+    def setRunCommand(self, cmd):
+        self._command = cmd
+
+    def setArgument(self, args=[]):
+        self._args = args
+
+    def setName(self, name):
+        self._name = name
+
+    def getOutput(self):
+        pass
+
+    def getError(self):
+        pass
+
+    def getWarning(self):
+        pass
+
+
+class TaskManager(object):
+    def __init__(self, n):
+        self._pool = []
+        self._bTerminated = False
+        self._tasks = queue.Queue()
+        self._tasks_lock = threading.Lock()
+        self._sem = threading.Semaphore(0)
+        self._num_task = n
+
+        for i in range(n):
+            name = 'Thread%30d' % i
+            t = threading.Thread(target=self._run, name=name)
+            self._pool.append(t)
+            # t.start()
+
+    def addTask(self, task):
+        self._tasks_lock.acquire()
+        self._tasks.put(task)
+        self._tasks_lock.release()
+
+    def _pick(self):
+        print
+        'Rest tasks: %d' % self._tasks.qsize()
+        if self._bTerminated:
+            return None
+
+        self._tasks_lock.acquire()
+
+        t = None
+        if self._tasks.qsize() > 0:
+            t = self._tasks.get()
+
+        self._tasks_lock.release()
+
+        return t
+
+    def _run(self):
+        # self._sem.acquire()
+        while True:
+            if self._bTerminated:
+                break
+            t = self._pick()
+            if t:
+                t.run()
+            else:
+                break
+
+    def start(self):
+        for t in self._pool:
+            t.start()
+
+        for t in self._pool:
+            t.join()
+
+    def stop(self):
+        self._bTerminated = True
+        self.start()
+
+    def setNumThreads(self, n):
+        self._num_task = n
+
+
+
+tm = TaskManager(process_num)
+
+if not os.path.exists('../gnn/data/cgra_me_label'):
+        os.makedirs('../gnn/data/cgra_me_label')
+if not os.path.exists('lisa_training_log'):
+        os.makedirs('lisa_training_log')
+
+if "gnn" in sys.argv[1]:
+    os.system('cp ./build/bin/cgrame ./build/bin/eval_unmaped')
+    for i  in range(len(target_arch)):
+        arch = target_arch[i]
+        arch_max_II = max_II
+        arch_file_name = arch_prefix + "_" + str(arch[0]) + "_" + str(arch[1])
+        if len(arch)>2:
+            arch_file_name += "_" + str(arch[2])
+            if "systolic" in str(arch[2]): # I set this as to get a better label, the max-II of final evaluation should be 1
+                arch_max_II = 1
+        arch_filename =  arch_folder + arch_file_name+".xml"
+        print(arch_filename)
+        arch_model_name =  "cgra_me_"+str(arch[0]) + "_" + str(arch[1])
+        if len(arch)>2:
+            arch_model_name += "_" + str(arch[2])
+
+        #iterate benchmark 
+        for bench in target_bench[i]:
+            bench_filename =  benchmark_folder + str(bench) + ".dot"
+            print(bench_filename)
+
+            arg = [ "-m",  "2", "--arch_name",arch_model_name, "--eval_unmapped", "--II", str(arch_max_II),  "--inef", "-g", bench_filename , "b",  "--xml", arch_filename, "--cgra_x",  str(arch[0] + 2),  "--cgra_y",  str(arch[1] + 2) ]
+            ts = BasicTask(name="schedule", cmd="./build/bin/eval_unmaped", args=arg)
+            tm.addTask(ts)
+elif "training" in sys.argv[1]:
+    os.system('cp ./build/bin/cgrame ./build/bin/eval_unmaped_training_cgrame')
+    for i  in range(len(target_arch)):
+        arch = target_arch[i]
+        arch_max_II = max_II
+        arch_file_name = arch_prefix + "_" + str(arch[0]) + "_" + str(arch[1])
+        if len(arch)>2:
+            arch_file_name += "_" + str(arch[2])
+            if "systolic" in str(arch[2]): # I set this as to get a better label, the max-II of final evaluation should be 1
+                arch_max_II = 1
+        arch_filename =  arch_folder + arch_file_name+".xml"
+        print(arch_filename)
+        arch_model_name =  "cgra_me_"+str(arch[0]) + "_" + str(arch[1])
+        if len(arch)>2:
+            arch_model_name += "_" + str(arch[2])
+
+        #iterate benchmark 
+        for bench in target_bench[i]:
+            bench_filename =  benchmark_folder + str(bench) + ".dot"
+            print(bench_filename)
+
+            arg = [ "-m",  "2",  "--II", str(arch_max_II), "--arch_name",arch_model_name, "--eval_unmapped", "--training",  "--training_output", "lisa_training_log/" + str(bench) + "_" + str(arch[0]) + "_" + str(arch[1]), "-g", bench_filename , "b",  "--xml", arch_filename, "--cgra_x",  str(arch[0] + 2),  "--cgra_y",  str(arch[1] + 2) ]
+            ts = BasicTask(name="schedule", cmd="./build/bin/eval_unmaped_training_cgrame", args=arg, output = "lisa_training_log/" + str(bench) + "_" + arch_model_name + ".log")
+            tm.addTask(ts)
+else:
+    assert(False)
+    
+tm.start()
diff -Nur cgra_me/src/adl_1/ADLParser.cpp lisa/cgra_me/src/adl_1/ADLParser.cpp
--- cgra_me/src/adl_1/ADLParser.cpp	2018-05-09 09:34:57.000000000 +0800
+++ lisa/cgra_me/src/adl_1/ADLParser.cpp	2022-02-28 16:37:25.912775566 +0800
@@ -48,7 +48,7 @@
 #include "ADLStructs.h"
 #include "SyntacticSugar.h"
 
-#define DEBUG_OUT 0
+#define DEBUG_OUT 1
 
 namespace adl1 {
 
@@ -81,7 +81,16 @@
     pugi::xml_parse_result archResult = archDoc.load_file(archSource);
 
     //Fill the architecture portion of the structures by passing xmlData by reference to this function
-    bool archFilled = fill_arch_data(archDoc, xmlData);
+    bool archFilled;
+    if (archFileName.find("specialNOC") != std::string::npos) {
+        std::cout << "found special NOC!" << '\n';
+        archFilled = fill_arch_data(archDoc, xmlData, true, false);
+    }else if (archFileName.find("systolic") != std::string::npos) {
+        std::cout << "found systolic arch!" << '\n';
+        archFilled = fill_arch_data(archDoc, xmlData, false, true);
+    }else{
+     archFilled = fill_arch_data(archDoc, xmlData);
+    }
 
     //If unsuccessful, abort
     if(!archFilled) {
@@ -110,7 +119,7 @@
     return true;
 };
 
-bool fill_arch_data(pugi::xml_node archDoc, ADLStructs &xmlData)
+bool fill_arch_data(pugi::xml_node archDoc, ADLStructs &xmlData, bool special_arch, bool systolic_arch)
 {
     //std::cout << "Begin filling architecture\n";
     //The architecture document begins with <architecture>
@@ -154,7 +163,7 @@
     }
 
     for(auto mesh : architecture.children("mesh")) {
-        create_orthogonal_mesh(xmlData, mesh);
+        create_orthogonal_mesh(xmlData, mesh, special_arch,systolic_arch );
     }
 
     for(auto diagonal : architecture.children("diagonal")) {
@@ -248,6 +257,7 @@
                     }
                 }
                 xmlData.subModules.push_back(std::pair<std::string, moduleTemplate>(name, temp));
+                std::cout<<" xmlData.subModules.push_back"<<name<<"\n";
 
                 //Move over to the next operating block if I need to
                 xmlData.arch.setCurrentCol(xmlData.arch.getCurrentCol()+1);
@@ -549,6 +559,7 @@
         auto blockType = args.count("type") == 0 ? STANDARD_NOBYPASS : read<CGRABlockType>(args.at("type"));
         m->addSubModule(new SimpleFU(simpName, blockType));
     } else if(type == "ConstUnit") {
+        std::cout<<"!!!!!!!!!pass ConstUnit"<<m->getName()<<"\n";
         auto constName = args.at("name");
         unsigned size = args.count("size") == 0 ? 32 : std::stoi(args.at("size"));
         m->addSubModule(new ConstUnit(constName, size));
@@ -631,6 +642,7 @@
 
     //First, I should create and add each composite module
     //Do this by iterating through the subModules member of the xmlData and adding the result to the CGRA
+    
     if(DEBUG_OUT) std::cout << "Looking for submodules to add...\n";
     for(auto elem : xmlData.subModules) {
         std::string subModuleName = elem.first;
@@ -639,6 +651,7 @@
         Module* m = create_module(subModuleName, subModuleType, xmlData);
 
         result->addSubModule(m);
+        std::cout<<result->getName()<<" submodule size"<<result->submodules.size()<<"\n";
     }
 
     //Add the ports if there are any
@@ -675,6 +688,9 @@
         add_connection_to_CGRA(result, toType, toArgs, fromType, fromArgs);
     }
 
+    std::cout<<"*********xmlData"<<std::endl;
+    xmlData.print();
+
     return result;
 }
 
diff -Nur cgra_me/src/adl_1/ADLParser.h lisa/cgra_me/src/adl_1/ADLParser.h
--- cgra_me/src/adl_1/ADLParser.h	2018-05-09 09:34:57.000000000 +0800
+++ lisa/cgra_me/src/adl_1/ADLParser.h	2022-02-28 16:37:25.912775566 +0800
@@ -54,7 +54,7 @@
 bool fill_module_templates(pugi::xml_node templateDoc, ADLStructs &xmlData);
 
 //This function fills the xmlData with the information found in the architecture document
-bool fill_arch_data(pugi::xml_node archDoc, ADLStructs &xmlData);
+bool fill_arch_data(pugi::xml_node archDoc, ADLStructs &xmlData, bool special_arch = false, bool systolic_arch = false);
 
 //This function fills the xmlData with the information declared in each pattern within the architecture document
 bool declare_pattern(pugi::xml_node pattern, ADLStructs &xmlData);
diff -Nur cgra_me/src/adl_1/module_templates.xml lisa/cgra_me/src/adl_1/module_templates.xml
--- cgra_me/src/adl_1/module_templates.xml	2018-05-09 09:34:57.000000000 +0800
+++ lisa/cgra_me/src/adl_1/module_templates.xml	2022-02-28 16:37:25.912775566 +0800
@@ -1,16 +1,81 @@
 <templates>
     <module name="meshblock1">
         <input name="in0"/> <input name="in1"/> <input name="in2"/> <input name="in3"/>
-        <output name="out"/>
-        <inst name="func" module="FuncUnit" op="add sub mul div and or xor shl shr"/>
-        <inst name="register" module="Register"/>
+        <output name="out0"/> <output name="out1"/>  <output name="out2"/>  <output name="out3"/>
+        <inst name="func" module="FuncUnit" op="add sub mul div and or xor shl shr shra"/>
+        <inst name="register0" module="Register"/>
+        <inst name="register1" module="Register"/>
+        <inst name="register2" module="Register"/>
+        <inst name="register3" module="Register"/>
+
+
+        <inst name="const" module="ConstUnit"/>
+        <inst name="mem_port" module="MemPort" ninput="4"/>
         <wire name="in_a"/> <wire name="in_b"/> <wire name="func_out"/>
-        <connection select-from="this.in0 this.in1 this.in2 this.in3 register.out" to="in_a in_b"/>
+        <connection select-from="this.in0 this.in1 this.in2 this.in3 register0.out register1.out register2.out register3.out const.out func_out" to="in_a in_b"/>
         <connection from="in_a" to="func.in_a"/>
         <connection from="in_b" to="func.in_b"/>
         <connection select-from="in_a in_b func.out" to="func_out"/>
-        <connection from="func_out" to="register.in"/>
-        <connection select-from="func_out register.out" to="this.out"/>
+        <connection from="func_out" to="register0.in"/>
+        <connection from="func_out" to="register1.in"/>
+        <connection from="func_out" to="register2.in"/>
+        <connection from="func_out" to="register3.in"/>
+        <connection select-from="this.in0 this.in1 this.in2 this.in3 func_out register0.out register1.out register2.out register3.out mem_port.out" to="this.out0"/>
+        <connection select-from="this.in0 this.in1 this.in2 this.in3 func_out register0.out register1.out register2.out register3.out mem_port.out" to="this.out1"/>
+        <connection select-from="this.in0 this.in1 this.in2 this.in3 func_out register0.out register1.out register2.out register3.out mem_port.out" to="this.out2"/>
+        <connection select-from="this.in0 this.in1 this.in2 this.in3 func_out register0.out register1.out register2.out register3.out mem_port.out" to="this.out3"/>
+        <connection from="this.in0" to="mem_port.in0"/>
+        <connection from="this.in1" to="mem_port.in1"/>
+        <connection from="this.in2" to="mem_port.in2"/>
+        <connection from="this.in3" to="mem_port.in3"/>
+    </module>
+
+    <module name="meshbock_noreg">
+        <input name="in0"/> <input name="in1"/> <input name="in2"/> <input name="in3"/>
+        <output name="out0"/> <output name="out1"/>  <output name="out2"/>  <output name="out3"/>
+        <inst name="func" module="FuncUnit" op="add sub mul div and or xor shl shr shra"/>
+
+
+        <inst name="const" module="ConstUnit"/>
+        <inst name="mem_port" module="MemPort" ninput="4"/>
+        <wire name="in_a"/> <wire name="in_b"/> <wire name="func_out"/>
+        <connection select-from="this.in0 this.in1 this.in2 this.in3  const.out func_out" to="in_a in_b"/>
+        <connection from="in_a" to="func.in_a"/>
+        <connection from="in_b" to="func.in_b"/>
+        <connection select-from="in_a in_b func.out" to="func_out"/>
+        <connection select-from="this.in0 this.in1 this.in2 this.in3 func_out  mem_port.out" to="this.out0"/>
+        <connection select-from="this.in0 this.in1 this.in2 this.in3 func_out  mem_port.out" to="this.out1"/>
+        <connection select-from="this.in0 this.in1 this.in2 this.in3 func_out  mem_port.out" to="this.out2"/>
+        <connection select-from="this.in0 this.in1 this.in2 this.in3 func_out  mem_port.out" to="this.out3"/>
+        <connection from="this.in0" to="mem_port.in0"/>
+        <connection from="this.in1" to="mem_port.in1"/>
+        <connection from="this.in2" to="mem_port.in2"/>
+        <connection from="this.in3" to="mem_port.in3"/>
+    </module>
+
+    <module name="meshbock_1reg">
+        <input name="in0"/> <input name="in1"/> <input name="in2"/> <input name="in3"/>
+        <output name="out0"/> <output name="out1"/>  <output name="out2"/>  <output name="out3"/>
+        <inst name="func" module="FuncUnit" op="add sub mul div and or xor shl shr shra"/>
+        <inst name="register0" module="Register"/>
+
+
+        <inst name="const" module="ConstUnit"/>
+        <inst name="mem_port" module="MemPort" ninput="4"/>
+        <wire name="in_a"/> <wire name="in_b"/> <wire name="func_out"/>
+        <connection select-from="this.in0 this.in1 this.in2 this.in3 register0.out  const.out func_out" to="in_a in_b"/>
+        <connection from="in_a" to="func.in_a"/>
+        <connection from="in_b" to="func.in_b"/>
+        <connection select-from="in_a in_b func.out" to="func_out"/>
+        <connection from="func_out" to="register0.in"/>
+        <connection select-from="this.in0 this.in1 this.in2 this.in3 func_out register0.out mem_port.out" to="this.out0"/>
+        <connection select-from="this.in0 this.in1 this.in2 this.in3 func_out register0.out mem_port.out" to="this.out1"/>
+        <connection select-from="this.in0 this.in1 this.in2 this.in3 func_out register0.out mem_port.out" to="this.out2"/>
+        <connection select-from="this.in0 this.in1 this.in2 this.in3 func_out register0.out mem_port.out" to="this.out3"/>
+        <connection from="this.in0" to="mem_port.in0"/>
+        <connection from="this.in1" to="mem_port.in1"/>
+        <connection from="this.in2" to="mem_port.in2"/>
+        <connection from="this.in3" to="mem_port.in3"/>
     </module>
 
     <module name="meshblock2">
@@ -60,6 +125,8 @@
         <connection from="mem_port.out" to="this.out"/>
     </module>
 
+  
+
     <module name="VLIWAdresPE">
         <input name="in0"/> <input name="in1"/> <input name="in2"/> <input name="in3"/> <input name="in4"/> <input name="in5"/> <input name="in6"/> <input name="in7"/>
         <output name="out"/>
diff -Nur cgra_me/src/adl_1/SyntacticSugar.cpp lisa/cgra_me/src/adl_1/SyntacticSugar.cpp
--- cgra_me/src/adl_1/SyntacticSugar.cpp	2018-05-09 09:34:57.000000000 +0800
+++ lisa/cgra_me/src/adl_1/SyntacticSugar.cpp	2022-02-28 16:37:25.912775566 +0800
@@ -47,8 +47,10 @@
 namespace adl1 {
 
 //This function populates the xmlData with the "mesh" attributes that the user defines
-bool create_orthogonal_mesh(ADLStructs &xmlData, pugi::xml_node mesh)
+bool create_orthogonal_mesh(ADLStructs &xmlData, pugi::xml_node mesh, bool special_arch, bool systolic_arch  )
 {
+
+    std::cout<<"set mesh\n";
     //Gather the operating rows and cols for the mesh
     std::stringstream colRange, rowRange;
     std::string colRangeStr;
@@ -111,6 +113,8 @@
         for(int i = startCol + 1; i < endCol; i++) {
             std::string name = "block_" + std::to_string(startRow) + "_" + std::to_string(i);
             xmlData.subModules.push_back(std::pair<std::string, moduleTemplate>(name, meshIO));
+            std::cout<<"ioblock only xmlData.subModules.push_back "<<name<<" "<<xmlData.subModules.size()<<"\n";
+
 
             //Connect this block to the block below it
             std::string toName = name + ".in";
@@ -122,6 +126,8 @@
 
             name = "block_" + std::to_string(endRow) + "_" + std::to_string(i);
             xmlData.subModules.push_back(std::pair<std::string, moduleTemplate>(name, meshIO));
+                        std::cout<<"ioblock only xmlData.subModules.push_back "<<name<<" "<<xmlData.subModules.size()<<"\n";
+
 
             //Connect this to the block above it
             fromName = name + ".out";
@@ -136,6 +142,8 @@
         for(int i = startRow + 1; i < endRow; i++) {
             std::string name = "block_" + std::to_string(i) + "_" + std::to_string(startCol);
             xmlData.subModules.push_back(std::pair<std::string, moduleTemplate>(name, meshIO));
+                    std::cout<<" ioblock only xmlData.subModules.push_back "<<name<<" "<<xmlData.subModules.size()<<"\n";
+
 
             //Connect this to the right of it
             std::string toName = name + ".in";
@@ -147,6 +155,8 @@
 
             name = "block_" + std::to_string(i) + "_" + std::to_string(endCol);
             xmlData.subModules.push_back(std::pair<std::string, moduleTemplate>(name, meshIO));
+            std::cout<<"ioblock only xmlData.subModules.push_back "<<name<<" "<<xmlData.subModules.size()<<"\n";
+
 
             toName = name + ".in";
             fromName = "block_" + std::to_string(i) + "_" + std::to_string(endCol - 1) + outEast;
@@ -189,6 +199,7 @@
                     }
                 }
                 xmlData.subModules.push_back(std::pair<std::string, moduleTemplate>(name, temp));
+                std::cout<<" xmlData.subModules.push_back "<<name<<" "<<xmlData.subModules.size()<<" "<<temp.name<<"\n";
                 xmlData.arch.setCurrentCol(xmlData.arch.getCurrentCol() + 1);
                 if(xmlData.arch.getCurrentCol() > xmlData.arch.getPatternEndCol()) {
                     xmlData.arch.setCurrentCol(col);
@@ -211,10 +222,11 @@
     //Top and bottom row excluding corners
     for(int i = startCol + 2; i < endCol - 1; i++) {
         std::string opBlock = create_xml_block(startRow + 1, i);
+        
         std::string target = create_xml_block(startRow + 1, i - 1);
         std::string from = opBlock + outWest;
         std::string to = target + inEast;
-        xmlData.connections.push_back(std::make_tuple("to", to, "from", from));
+        if(!special_arch)  xmlData.connections.push_back(std::make_tuple("to", to, "from", from));
 
         target = create_xml_block(startRow + 1, i + 1);
         from = opBlock + outEast;
@@ -230,6 +242,7 @@
         target = create_xml_block(endRow - 1, i - 1);
         from = opBlock + outWest;
         to = target + outEast;
+        // if(!special_arch)  right-most column, 
         xmlData.connections.push_back(std::make_tuple("to", to, "from", from));
 
         target = create_xml_block(endRow - 1, i + 1);
@@ -240,17 +253,18 @@
         target = create_xml_block(endRow - 2, i);
         from = opBlock + outNorth;
         to = target + inSouth;
-        xmlData.connections.push_back(std::make_tuple("to", to, "from", from));
+        if(!special_arch) xmlData.connections.push_back(std::make_tuple("to", to, "from", from));
 
     }
 
     //Left and right row excluding corners
     for(int i = startRow + 2; i < endRow - 1; i++) {
         std::string opBlock = create_xml_block(i, startCol + 1);
+
         std::string target = create_xml_block(i - 1, startCol + 1);
         std::string from = opBlock + outNorth;
         std::string to = target + inSouth;
-        xmlData.connections.push_back(std::make_tuple("to", to, "from", from));
+        if(!special_arch)  xmlData.connections.push_back(std::make_tuple("to", to, "from", from));
 
         target = create_xml_block(i + 1, startCol + 1);
         from = opBlock + outSouth;
@@ -266,6 +280,7 @@
         target = create_xml_block(i - 1, endCol - 1);
         from = opBlock + outNorth;
         to = target + inSouth;
+        // if(!special_arch)  bottom row
         xmlData.connections.push_back(std::make_tuple("to", to, "from", from));
 
         target = create_xml_block(i + 1, endCol - 1);
@@ -276,7 +291,7 @@
         target = create_xml_block(i, endCol - 2);
         from = opBlock + outWest;
         to = target + inEast;
-        xmlData.connections.push_back(std::make_tuple("to", to, "from", from));
+        if(!special_arch)  xmlData.connections.push_back(std::make_tuple("to", to, "from", from));
     }
 
 
@@ -297,7 +312,7 @@
     targetBlock = "block_" + std::to_string(endRow - 2) + "_" + std::to_string(startCol + 1);
     from = opBlock + outNorth;
     to = targetBlock + inSouth;
-    xmlData.connections.push_back(std::make_tuple("to", to, "from", from));
+    if(!special_arch)  xmlData.connections.push_back(std::make_tuple("to", to, "from", from));
 
     targetBlock = "block_" + std::to_string(endRow - 1) + "_" + std::to_string(startCol + 2);
     from = opBlock + outEast;
@@ -308,7 +323,7 @@
     targetBlock = "block_" + std::to_string(startRow + 1) + "_" + std::to_string(endCol - 2);
     from = opBlock + outWest;
     to = targetBlock + inEast;
-    xmlData.connections.push_back(std::make_tuple("to", to, "from", from));
+    if(!special_arch) xmlData.connections.push_back(std::make_tuple("to", to, "from", from));
 
     targetBlock = "block_" + std::to_string(startRow + 2) + "_" + std::to_string(endCol - 1);
     from = opBlock + outSouth;
@@ -319,12 +334,12 @@
     targetBlock = "block_" + std::to_string(endRow - 2) + "_" + std::to_string(endCol - 1);
     from = opBlock + outNorth;
     to = targetBlock + inSouth;
-    xmlData.connections.push_back(std::make_tuple("to", to, "from", from));
+    if(!special_arch)  xmlData.connections.push_back(std::make_tuple("to", to, "from", from));
 
     targetBlock = "block_" + std::to_string(endRow - 1) + "_" + std::to_string(endCol - 2);
     from = opBlock + outWest;
     to = targetBlock + inEast;
-    xmlData.connections.push_back(std::make_tuple("to", to, "from", from));
+    if(!special_arch)  xmlData.connections.push_back(std::make_tuple("to", to, "from", from));
 
 
 }
@@ -594,6 +609,8 @@
                     }
                 }
                 xmlData.subModules.push_back(std::pair<std::string, moduleTemplate>(name, temp));
+
+                std::cout<<" xmlData.subModules.push_back "<<name<<" "<<xmlData.subModules.size()<<"\n";
                 xmlData.arch.setCurrentCol(xmlData.arch.getCurrentCol() + 1);
                 if(xmlData.arch.getCurrentCol() > xmlData.arch.getPatternEndCol()) {
                     xmlData.arch.setCurrentCol(col);
@@ -836,7 +853,7 @@
 }
 
 //This function creates the connections for a block on the inside of a mesh pattern
-bool connect_inner_mesh_block(ADLStructs &xmlData, std::map<int, std::string> ports)
+bool connect_inner_mesh_block(ADLStructs &xmlData, std::map<int, std::string> ports, bool systolic_arch )
 {
     int row = xmlData.arch.getCurrentRow();
     int col = xmlData.arch.getCurrentCol();
@@ -846,7 +863,7 @@
     std::string targetBlock = "block_" + std::to_string(row-1) + "_" + std::to_string(col);
     std::string from = opBlock + (ports.find(0)->second);
     std::string to = targetBlock + (ports.find(6)->second);
-    xmlData.connections.push_back(std::make_tuple("to", to, "from", from));
+    if(!systolic_arch) xmlData.connections.push_back(std::make_tuple("to", to, "from", from));
 
     //Bottom block
     targetBlock = "block_" + std::to_string(row+1) + "_" + std::to_string(col);
@@ -858,9 +875,9 @@
     targetBlock = "block_" + std::to_string(row) + "_" + std::to_string(col-1);
     from = opBlock + ports.find(3)->second;
     to = targetBlock + ports.find(5)->second;
-    xmlData.connections.push_back(std::make_tuple("to", to, "from", from));
+    if(!systolic_arch) xmlData.connections.push_back(std::make_tuple("to", to, "from", from));
 
-    //West block
+    //Eest block
     targetBlock = "block_" + std::to_string(row) + "_" + std::to_string(col + 1);
     from = opBlock + ports.find(1)->second;
     to = targetBlock + ports.find(7)->second;
diff -Nur cgra_me/src/adl_1/SyntacticSugar.h lisa/cgra_me/src/adl_1/SyntacticSugar.h
--- cgra_me/src/adl_1/SyntacticSugar.h	2018-05-09 09:34:57.000000000 +0800
+++ lisa/cgra_me/src/adl_1/SyntacticSugar.h	2022-02-28 16:37:25.912775566 +0800
@@ -49,13 +49,13 @@
 
 //This function fills the xmlData with the orthogonal mesh architecture for CGRA with the
 //attributes specified in the xml document
-bool create_orthogonal_mesh(ADLStructs &xmlData, pugi::xml_node mesh);
+bool create_orthogonal_mesh(ADLStructs &xmlData, pugi::xml_node mesh, bool special_arch = false, bool systolic_arch = false);
 
 //This does the same as the above function
 bool create_diag_mesh(ADLStructs &xmlData, pugi::xml_node diagonal);
 
 //This function only adds lines and should be removed
-bool connect_inner_mesh_block(ADLStructs &xmlData, std::map<int, std::string> ports);
+bool connect_inner_mesh_block(ADLStructs &xmlData, std::map<int, std::string> ports, bool systolic_arch = false);
 
 }
 
diff -Nur cgra_me/src/core/AnnealMapper.cpp lisa/cgra_me/src/core/AnnealMapper.cpp
--- cgra_me/src/core/AnnealMapper.cpp	2018-05-09 09:34:57.000000000 +0800
+++ lisa/cgra_me/src/core/AnnealMapper.cpp	2022-02-28 16:37:25.912775566 +0800
@@ -47,15 +47,15 @@
 using std::cout;
 using std::endl;
 
-#define ALLOW_MULTIPLE_PLACEMENT
+#define ALLOW_MULTIPLE_PLACEMENT false/
 #define SIMPLE_ANNEAL_SCHEDULE
 #define CALCULATE_INITIAL_TEMPERATURE
 // Debugging output flags
 //#define ANNEAL_DEBUG
 //#define PLACEMENT_DEBUG
-//#define DEBUG_ROUTING
+// #define DEBUG_ROUTING
 
-AnnealMapper::AnnealMapper(std::shared_ptr<CGRA> cgra, int timelimit, const std::map<std::string, std::string> & args)
+AnnealMapper::AnnealMapper(std::shared_ptr<CGRA> cgra, int timelimit, const std::map<std::string, std::string> &args)
     : Mapper(cgra, timelimit)
 {
     try
@@ -67,7 +67,7 @@
         swap_factor = std::stoi(args.at("AnnealMapper.swap_factor"));
         cold_accept_rate = std::stof(args.at("AnnealMapper.cold_accept_rate"));
     }
-    catch(const std::exception & e)
+    catch (const std::exception &e)
     {
         throw cgrame_error(std::string("AnnealMapper Parameter Parsing Exception Thrown by: [") + e.what() + "] at File: " + std::string(__FILE__) + " Line: " + std::to_string(__LINE__));
     }
@@ -89,11 +89,11 @@
 {
 }
 
-float AnnealMapper::getCost(MRRGNode* n)
+float AnnealMapper::getCost(MRRGNode *n)
 {
     float base_cost;
 
-    if(n->type == MRRG_NODE_FUNCTION)
+    if (n->type == MRRG_NODE_FUNCTION)
         base_cost = 2.0;
     else
         base_cost = 1.0;
@@ -101,15 +101,15 @@
     return base_cost * occupancy[n] + (occupancy[n] <= n->capacity ? 0.0 : (occupancy[n] - n->capacity) * pfactor);
 }
 
-float AnnealMapper::getCost(MRRG* mrrg)
+float AnnealMapper::getCost(MRRG *mrrg)
 {
     float total = 0.0;
-    for(auto & node: mrrg->function_nodes)
+    for (auto &node : mrrg->function_nodes)
     {
         total += getCost(node);
     }
 
-    for(auto & node: mrrg->routing_nodes)
+    for (auto &node : mrrg->routing_nodes)
     {
         total += getCost(node);
     }
@@ -117,32 +117,32 @@
     return total;
 }
 
-float AnnealMapper::getCost(OpGraph* opgraph)
+float AnnealMapper::getCost(OpGraph *opgraph)
 {
     float result = 0.0;
-    for(auto & op: opgraph->op_nodes)
+    for (auto &op : opgraph->op_nodes)
     {
         result += getCost(op);
     }
-    for(auto & val: opgraph->val_nodes)
+    for (auto &val : opgraph->val_nodes)
     {
         result += getCost(val);
     }
     return result;
 }
 
-float AnnealMapper::getCost(OpGraphNode * n)
+float AnnealMapper::getCost(OpGraphNode *n)
 {
     float result = 0.0;
 
-    if(mapping[n].size() == 0)
+    if (mapping[n].size() == 0)
     {
         cout << "there's an unroute/unmap for OpGraphNode: " << n->name << "\n";
         result = INFINITY;
     }
     else
     {
-        for(auto & node : mapping[n])
+        for (auto &node : mapping[n])
         {
             result += getCost(node);
         }
@@ -150,23 +150,23 @@
     return result;
 }
 
-bool AnnealMapper::checkOveruse(MRRG* mrrg)
+bool AnnealMapper::checkOveruse(MRRG *mrrg)
 {
     bool result = true;
-    for(auto & node: mrrg->function_nodes)
+    for (auto &node : mrrg->function_nodes)
     {
-        if(occupancy[node] > node->capacity)
+        if (occupancy[node] > node->capacity)
         {
-            std::cout << *node << " is overused. (" << occupancy[node] << "/" << node->capacity << ")\n";
+            LOG(OVERUSE) << *node << " is overused. (" << occupancy[node] << "/" << node->capacity << ")\n";
             result = false;
         }
     }
 
-    for(auto & node: mrrg->routing_nodes)
+    for (auto &node : mrrg->routing_nodes)
     {
-        if(occupancy[node] > node->capacity)
+        if (occupancy[node] > node->capacity)
         {
-            std::cout << *node << " is overused. (" << occupancy[node] << "/" << node->capacity << ")\n";
+            LOG(OVERUSE) << *node << " is overused. (" << occupancy[node] << "/" << node->capacity << ")\n";
             result = false;
         }
     }
@@ -174,18 +174,18 @@
     return result;
 }
 
-OpGraphOp* AnnealMapper::getOpNodePtr(OpGraph* opgraph, MRRGNode* n)
+OpGraphOp *AnnealMapper::getOpNodePtr(OpGraph *opgraph, MRRGNode *n)
 {
     int size_vector = opgraph->op_nodes.size();
 
-    OpGraphOp* return_ptr;
+    OpGraphOp *return_ptr;
 
     //loop through all op nodes to find same MRRG node as 'this'
     //may be very slow
     for (int i = 0; i < size_vector; i++)
     {
-        MRRGNode* current_node = getMappedMRRGNode(opgraph->op_nodes[i]);
-        if(current_node == n)
+        MRRGNode *current_node = getMappedMRRGNode(opgraph->op_nodes[i]);
+        if (current_node == n)
         {
             return_ptr = opgraph->op_nodes[i];
 #ifdef DEBUG
@@ -199,31 +199,31 @@
     return return_ptr;
 }
 
-void AnnealMapper::mapMRRGNode(OpGraphNode* opnode, MRRGNode* n)
+void AnnealMapper::mapMRRGNode(OpGraphNode *opnode, MRRGNode *n)
 {
     try
     {
         mapping[opnode].push_back(n);
     }
-    catch(const std::exception & e)
+    catch (const std::exception &e)
     {
         throw cgrame_error(std::string("AnnealMapper Exception Thrown by: [") + e.what() + "] at File: " + std::string(__FILE__) + " Line: " + std::to_string(__LINE__));
     }
     occupancy[n]++;
 }
 
-void AnnealMapper::mapAllMRRGNodes(OpGraphNode* opnode, std::vector<MRRGNode*> nodes)
+void AnnealMapper::mapAllMRRGNodes(OpGraphNode *opnode, std::vector<MRRGNode *> nodes)
 {
     // map all nodes
-    for(auto & n: nodes)
+    for (auto &n : nodes)
     {
         mapMRRGNode(opnode, n);
     }
 }
 
-void AnnealMapper::unmapMRRGNode(OpGraphNode* opnode, MRRGNode* n)
+void AnnealMapper::unmapMRRGNode(OpGraphNode *opnode, MRRGNode *n)
 {
-/*
+    /*
     for(auto & node: mapping[opnode])
     {
         if(node == n)
@@ -239,28 +239,28 @@
     try
     {
         auto iter = find(mapping[opnode].begin(), mapping[opnode].end(), n);
-        if(iter != mapping[opnode].end())
+        if (iter != mapping[opnode].end())
         {
             occupancy[n]--;
             assert(occupancy[n] >= 0);
             mapping[opnode].erase(iter);
         }
     }
-    catch(const std::exception & e)
+    catch (const std::exception &e)
     {
         throw cgrame_error(std::string("AnnealMapper Exception Thrown by: [") + e.what() + "] at File: " + std::string(__FILE__) + " Line: " + std::to_string(__LINE__));
     }
 }
 
-std::vector<MRRGNode*> AnnealMapper::unmapAllMRRGNodes(OpGraphNode* opnode)
+std::vector<MRRGNode *> AnnealMapper::unmapAllMRRGNodes(OpGraphNode *opnode)
 {
-    std::vector<MRRGNode*> result;
+    std::vector<MRRGNode *> result;
 
     // save mapping
     result = mapping[opnode];
 
     // unmap all nodes
-    for(auto & n: mapping[opnode])
+    for (auto &n : mapping[opnode])
     {
         occupancy[n]--;
         assert(occupancy[n] >= 0);
@@ -274,13 +274,13 @@
 /**
   Returns the MRRGNode that the Op is mapped to, NULL if unmapped
  **/
-MRRGNode* AnnealMapper::getMappedMRRGNode(OpGraphOp* op)
+MRRGNode *AnnealMapper::getMappedMRRGNode(OpGraphOp *op)
 {
-    std::vector<MRRGNode*>& mapped_nodes = mapping[op];
-    if(mapped_nodes.size() != 0)
+    std::vector<MRRGNode *> &mapped_nodes = mapping[op];
+    if (mapped_nodes.size() != 0)
     {
         assert(mapped_nodes.size() == 1); // Op should only be mapped to a single node
-        assert(mapped_nodes[0]); // make sure we don't have a NULL pointer
+        assert(mapped_nodes[0]);          // make sure we don't have a NULL pointer
 
         return mapped_nodes[0];
     }
@@ -288,81 +288,19 @@
     return NULL; // return null if unmapped
 }
 
-
-static void topological_sort_visit(std::vector<OpGraphOp*> * L, std::map<OpGraphOp*, bool> * mark, OpGraphOp* n)
-{
-    if(!(*mark)[n])
-    {
-        if(n->opcode != OPGRAPH_OP_OUTPUT)
-        {
-            for(auto & m : n->output->output)
-            {
-                topological_sort_visit(L, mark, m);
-            }
-        }
-
-        (*mark)[n] = true;
-        L->insert(L->begin(), n); // push n to head
-    }
-}
-
-static OpGraphOp* topological_sort_check_marked(std::vector<OpGraphOp*> nodes, std::map<OpGraphOp*, bool> * mark)
-{
-    for(auto & n : nodes)
-    {
-        if(!(*mark)[n])
-            return n;
-    }
-    return NULL;
-}
-
-// This topological sort algorithm uses a depth first search
-// NB: The graph MUST be acyclic, else explosions may happen...
-void topological_sort(OpGraph* g)
-{
-    std::vector<OpGraphOp*> L;
-
-    // Unmark all nodes
-    std::map<OpGraphOp*, bool> mark;
-    for(auto & n : g->op_nodes)
-    {
-        mark[n] = false;
-    }
-
-    OpGraphOp* n;
-    while((n = topological_sort_check_marked(g->op_nodes, &mark)))
-    {
-        topological_sort_visit(&L, &mark, n);
-    }
-
-    g->op_nodes = L;
-}
-/*
-bool test_compare(float penalty_factor, MRRGNode* a, MRRGNode* b)
-{
-    return getCost(a) < getCost(b);
-}
-
-bool compare_op_cost(float penalty_factor, OpGraphOp* a, OpGraphOp* b)
-{
-    return a->getCost(penalty_factor) > b->getCost(penalty_factor);
-}
-*/
-bool operator<(const std::pair<float,MRRGNode*> & a, const std::pair<float,MRRGNode*> & b)
-{
-    return a.first > b.first;
-}
-
 // Route a val node on to the MRRG, false if unable to route
-bool AnnealMapper::routeVal(OpGraphVal* val)
+bool AnnealMapper::routeVal(OpGraphVal *val)
 {
+
     assert(val);
+    // cout << "Routing val: " << *val << endl;
+
 #ifdef DEBUG_ROUTING
     cout << "Routing val: " << *val << endl;
-    cout << "Routing from: " << *(val->input->mapped_nodes[0]) << endl;
+    // cout << "Routing from: " << *(val->input->mapped_nodes[0]) << endl;
 #endif
     // verify that fanin and fanouts are placed
-    if(mapping[val->input].size() == 0)
+    if (mapping[val->input].size() == 0)
     {
 #ifdef DEBUG_ROUTING
         cout << "Routing input not mappped!" << endl;
@@ -370,17 +308,17 @@
         return false;
     }
     // verify fanouts placed; initialize fanout_mapped flags
-    std::map<MRRGNode*, bool> fanout_mapped;
-    std::map<MRRGNode*, unsigned int> output_number;
+    std::map<MRRGNode *, bool> fanout_mapped;
+    std::map<MRRGNode *, unsigned int> output_number;
 
     // TODO: is this the right place to resize this vector?
     val->output_latency.resize(val->output.size());
 
-    for(unsigned int i = 0; i < val->output.size(); ++i)
+    for (unsigned int i = 0; i < val->output.size(); ++i)
     {
-        OpGraphOp* fos = val->output[i];
+        OpGraphOp *fos = val->output[i];
 
-        if(mapping[fos].size() == 0)
+        if (mapping[fos].size() == 0)
         {
 #ifdef DEBUG_ROUTING
             cout << *fos << "NOT MAPPED?!?!" << endl;
@@ -389,57 +327,181 @@
             return false;
         }
         // TODO: this next line of code is so ugly.....
-        MRRGNode* dst = mapping[fos][0]->operand[val->output_operand[i]];
+        MRRGNode *dst = mapping[fos][0]->operand[val->output_operand[i]];
+        #ifdef DEBUG_ROUTING
+            std::cout << "dest" << dst->getFullName() << "\n";
+        #endif
         output_number[dst] = i;
         fanout_mapped[dst] = false;
-#ifdef DEBUG_ROUTING
-        cout << "          to: " << *(fos->mapped_nodes[0]) << ", operand = " << val->output_operand[i] << endl;
-#endif
+        // #ifdef DEBUG_ROUTING
+        //         cout << "          to: " << *(fos->mapped_nodes[0]) << ", operand = " << val->output_operand[i] << endl;
+        // #endif
     }
 
-    std::list<MRRGNode*> src_nodes;
+    std::list<MRRGNode *> src_nodes;
     src_nodes.push_back(mapping[val->input][0]);
 
+    std::map<MRRGNode *, int> min_distance; // if node exites in the map, this node has been mapped.
+    min_distance[mapping[val->input][0]] = 0;
+
+//lamda function
+    auto find_least_occupy_node = [&](MRRGNode *output_node) {
+        int curr_dis = min_distance[output_node] - output_node->latency * 100 - 1;
+        int least_occupy_value = occupancy[output_node->prev];
+        auto least_occupy_node = output_node->prev;
+        // std::cout<<"fan in size "<<output_node->fanin.size()<<"\n";
+        for (auto dddd : output_node->fanin)
+        {
+            if (min_distance.find(dddd) != min_distance.end())
+            {
+                if (min_distance[dddd] == curr_dis)
+                {
+                    if (occupancy[dddd] < least_occupy_value)
+                    {
+                        least_occupy_value = occupancy[dddd];
+                        least_occupy_node = dddd;
+                    }
+                }
+            }
+        }
+        return least_occupy_node;
+    };
+//lamda function2    
+    auto recursive_update = [&](MRRGNode  * node){
+        std::queue<MRRGNode *> update_dist;
+        update_dist.push(node);
+        while(!update_dist.empty()){
+            MRRGNode *update_node = update_dist.front();
+            update_dist.pop();
+            int d_of_updatenode = min_distance[update_node];
+            for (auto output_node : update_node->fanout)
+            {
+                if (min_distance.find(output_node) != min_distance.end())
+                {
+                    bool need_update = false;
+                    if (output_node->prev == update_node)
+                    {
+                        need_update = true;
+                    }
+                    else if ((min_distance[output_node] - output_node->latency * 100 ) > d_of_updatenode - 1)
+                    {
+                        need_update = true;
+                    }
+                    if (!need_update)
+                    {
+                        auto least_node = find_least_occupy_node(output_node);
+                        output_node->prev = least_node;
+                        continue;
+                    }
+
+                    if (min_distance[output_node] <= d_of_updatenode + output_node->latency * 100 + 1)
+                        continue;
+                    output_node->prev = update_node;
+                    update_dist.push(output_node);
+                    min_distance[output_node] = d_of_updatenode + output_node->latency * 100  + 1;
+                }
+            }
+                    
+        }
+    };
+//lamda function3
+    auto update_fanout = [&](MRRGNode *node){
+        int min_d = min_distance[node] - node->latency * 100  - 1;
+        MRRGNode *min_node = node->prev;
+        for (auto node_input : node->fanin)
+        {
+            if (min_distance.find(node_input) != min_distance.end())
+            {
+                int d = min_distance[node_input];
+                if (d < min_d)
+                {
+                    min_d = d;
+                    min_node = node_input;
+                }
+            }
+        }
+        if (min_d == min_distance[node] - node->latency * 100  - 1)
+        {
+            auto least_node = find_least_occupy_node(node);
+            node->prev = least_node;
+            return true;
+        }
+        assert(min_d < min_distance[node] - node->latency * 100  - 1);
+// we need to update the value
+#ifdef DEBUG_ROUTING
+        cout << "-----------update: " << node->getFullName() << " from " << min_distance[node] << " to " << min_d + node->latency << endl;
+#endif
+        min_distance[node] = min_d + node->latency * 100  + 1;
+        assert(min_node != NULL);
+        assert(min_node);
+        node->prev = min_node;
+
+        recursive_update(node);
+
+        return true;
+    };
+
+
     bool all_fanouts_mapped = false;
-    while(!all_fanouts_mapped)
+    while (!all_fanouts_mapped)
     {
         // try mapping
-        std::priority_queue<std::pair<float, MRRGNode*>, std::vector<std::pair<float, MRRGNode*>>> queue;
-        std::vector<MRRGNode*> nodes_in_queue;
+        std::priority_queue<std::pair<float, MRRGNode *>, std::vector<std::pair<float, MRRGNode *>>> queue;
+        std::vector<MRRGNode *> nodes_in_queue;
 
-        for(auto s = src_nodes.begin(); s != src_nodes.end(); ++s)
+        for (auto s = src_nodes.begin(); s != src_nodes.end(); ++s)
         {
 #ifdef DEBUG_ROUTING
             cout << "queueing fanouts of src_node: " << **s << endl;
 #endif
-            for(auto n = (*s)->fanout.begin(); n != (*s)->fanout.end(); ++n)
+            for (auto n = (*s)->fanout.begin(); n != (*s)->fanout.end(); ++n)
             {
                 // check that fanouts arent already in the src_node list
-                if(find(src_nodes.begin(), src_nodes.end(), *n) == src_nodes.end())
+                // if(occupancy[*n]> 1) continue;
+
+                if (find(src_nodes.begin(), src_nodes.end(), *n) == src_nodes.end() && !(*n)->prev)
                 {
+                    if (occupancy[*n] >= 1 && ( !allow_overuse || overuse_num_ >=  MAX_OVERUSE ) ){
+                        continue;
+                    }
                     (*n)->prev = (*s);
+                    // std::cout << " add1 fanout" << (*n)->getFullName() << "\n";
+                    min_distance[*n] = min_distance[(*s)] + (*n)->latency * 100  + 1;
+
                     queue.push(std::make_pair(getCost(*n), (*n)));
                     //nodes_in_queue.push_back(*n);
                 }
+                else
+                {
+                    // check whether need to update distance
+                    // the idea here: when find a  new node which can reach the old node, check the distance of old node and see if need update.
+                    // if need update, then we recursively update the fan-in. Meanwhile, for each updated node, let us try to find the best fan-in with the
+                    // same least latency but with least occupancy
+                    if (!(*n)->prev)
+                        continue;
+                    if (min_distance.find(*n) == min_distance.end())
+                        continue;
+                    update_fanout(*n);
+                }
             }
         }
 
         // while we still have more routing options, try to route
         bool mapped_a_node = false;
-        while(!queue.empty())
+        while (!queue.empty())
         {
             auto node = queue.top();
             queue.pop();
             //nodes_in_queue.erase(find(nodes_in_queue.begin(), nodes_in_queue.end(), node.second));
 
             float node_cost = node.first;
-            MRRGNode* n = node.second;
+            MRRGNode *n = node.second;
 #ifdef DEBUG_ROUTING
-            cout << "queue popped: " << *n << ": " << node_cost <<  endl;
+            cout << "queue popped: " << *n << ": " << node_cost << endl;
 #endif
             // if n is a new sink
             // test if n->first is in map, then test if is unmapped
-            if(fanout_mapped.find(n) != fanout_mapped.end() && !fanout_mapped[n])
+            if (fanout_mapped.find(n) != fanout_mapped.end() && !fanout_mapped[n])
             {
 #ifdef DEBUG_ROUTING
                 cout << "Router found sink: " << *n << "." << endl;
@@ -451,9 +513,9 @@
                 src_nodes.push_back(n);
 
                 unsigned int latency = 0;
-                MRRGNode* k = n->prev;
+                MRRGNode *k = n->prev;
 
-                while(find(src_nodes.begin(), src_nodes.end(), k) == src_nodes.end())
+                while (find(src_nodes.begin(), src_nodes.end(), k) == src_nodes.end())
                 {
 #ifdef DEBUG_ROUTING
                     cout << *k << endl;
@@ -471,23 +533,42 @@
 
                 // clear queue and unmark all backtrack paths to src_nodes
                 // inner while loop will end when queue is empty
-                while(!queue.empty())
+                while (!queue.empty())
                 {
                     auto node_pair = queue.top();
                     queue.pop();
                     //nodes_in_queue.erase(find(nodes_in_queue.begin(), nodes_in_queue.end(), node_pair.second));
 
-                    MRRGNode* k = node_pair.second;
+                    MRRGNode *k = node_pair.second;
                     // while we haven't backtracked to already removed path AND we havent reached any source nodes
-                    while(k != NULL && find(src_nodes.begin(), src_nodes.end(), k) == src_nodes.end())
+                    while (k != NULL && find(src_nodes.begin(), src_nodes.end(), k) == src_nodes.end())
                     {
-                        MRRGNode* prev = k;
+                        MRRGNode *prev = k;
                         k = k->prev;
                         prev->prev = NULL;
+                        auto it = min_distance.find(prev);
+                        if (it != min_distance.end())
+                            min_distance.erase(it);
+                    }
+                }
+                for (auto it = min_distance.begin(); it != min_distance.end();)
+                {
+                    auto node = it->first;
+                    if (find(src_nodes.begin(), src_nodes.end(), node) == src_nodes.end())
+                    {
+                        it = min_distance.erase(it);
+                    }
+                    else
+                    {
+                        it++;
                     }
                 }
 
                 // we have now mapped the fanout
+                // std::cout<<"mapped one fanout\n";
+                #ifdef DEBUG_ROUTING
+                        cout << "latency "<<n->getFullName()<<" "<<latency << endl;
+                #endif
                 fanout_mapped[n] = true;
                 val->output_latency[output_number[n]] = latency;
                 mapped_a_node = true;
@@ -495,15 +576,29 @@
             else
             {
                 // queue up all fanouts
-                if(n->type == MRRG_NODE_ROUTING)
+                if (n->type == MRRG_NODE_ROUTING)
                 {
-                    for(auto i = n->fanout.begin(); i != n->fanout.end(); ++i)
+                    for (auto i = n->fanout.begin(); i != n->fanout.end(); ++i)
                     {
                         // check that fanouts arent already in the src_node
-                        if(!(*i)->prev)
+                        //  if(occupancy[*i]> 1) continue;
+                        if (!(*i)->prev)
                         {
+                             if (occupancy[*i] >= 1 && ( !allow_overuse || overuse_num_ >=  MAX_OVERUSE ) ){
+                                continue;
+                            }
                             (*i)->prev = n;
+                            // std::cout << " add2 fanout" << (*i)->getFullName() << "\n";
+
                             queue.push(std::make_pair(node_cost + getCost(*i), (*i)));
+                            min_distance[*i] = min_distance[n] + (*i)->latency  * 100 + 1;
+                        }
+                        else
+                        {
+                            // check whether need to update distance
+                            if (min_distance.find(*i) == min_distance.end())
+                                continue;
+                            update_fanout(*i);
                         }
                     }
                 }
@@ -511,7 +606,7 @@
         }
 
         // if we exited the loop and didn't map a node, we have an unreachable route
-        if(!mapped_a_node) // if we exited the loop and didn't map a node, we have an unreachable route
+        if (!mapped_a_node) // if we exited the loop and didn't map a node, we have an unreachable route
         {
 #ifdef DEBUG_ROUTING
             cout << "Routing Failed" << endl;
@@ -519,19 +614,20 @@
             return false;
         }
         all_fanouts_mapped = true;
-        for(auto i = fanout_mapped.begin(); i != fanout_mapped.end(); ++i)
+        for (auto i = fanout_mapped.begin(); i != fanout_mapped.end(); ++i)
         {
             all_fanouts_mapped &= i->second;
         }
     }
+   
 
-    for(auto s = src_nodes.begin(); s != src_nodes.end(); ++s)
+    for (auto s = src_nodes.begin(); s != src_nodes.end(); ++s)
     {
-        if((*s)->type == MRRG_NODE_ROUTING)
+        if ((*s)->type == MRRG_NODE_ROUTING)
         {
-#ifdef DEBUG_ROUTING
-            cout << "Mapping routing node: " << **s << endl;
-#endif
+            #ifdef DEBUG_ROUTING
+            cout << "Mapping routing node: " << **s << "  "<<(*s)->latency<<"\n";
+            #endif
             // map val to this node
             mapMRRGNode(val, *s);
         }
@@ -542,27 +638,32 @@
 #endif
         }
     }
-
+  
 #ifdef DEBUG_ROUTING
     cout << "Routing Succeeded" << endl;
 #endif
+
+   
+    min_distance.clear();
+    // assert(false);
     return true;
+
 }
 
-float AnnealMapper::getTotalOpCost(OpGraphOp* op)
+float AnnealMapper::getTotalOpCost(OpGraphOp *op)
 {
     float result = 0.0;
     result += getCost(op);
 
-    if(op->opcode != OPGRAPH_OP_INPUT && op->opcode != OPGRAPH_OP_CONST)
+    if (op->opcode != OPGRAPH_OP_INPUT && op->opcode != OPGRAPH_OP_CONST)
     {
-        for(auto in = op->input.begin(); in != op->input.end(); ++in)
+        for (auto in = op->input.begin(); in != op->input.end(); ++in)
         {
             result += getCost((*in));
         }
     }
 
-    if(op->opcode != OPGRAPH_OP_OUTPUT && op->opcode != OPGRAPH_OP_STORE)
+    if (op->opcode != OPGRAPH_OP_OUTPUT && op->opcode != OPGRAPH_OP_STORE)
     {
         result += getCost(op->output);
     }
@@ -572,11 +673,11 @@
 
 // Rips up Op as well as routes in and out (if they exist) and records the cost of whatever was ripped up
 // if a pointer to cost is given, the cost is also returned
-OpMapping AnnealMapper::ripUpOp(OpGraphOp* op, float* cost)
+OpMapping AnnealMapper::ripUpOp(OpGraphOp *op, float *cost)
 {
     OpMapping result;
 
-    if(cost)
+    if (cost)
     {
         *cost = 0.0;
         *cost += getCost(op);
@@ -584,23 +685,23 @@
 
     result.mapping[op] = unmapAllMRRGNodes(op);
 
-    if(op->opcode != OPGRAPH_OP_INPUT && op->opcode != OPGRAPH_OP_CONST)
+    if (op->opcode != OPGRAPH_OP_INPUT && op->opcode != OPGRAPH_OP_CONST)
     {
-        for(auto &in: op->input)
+        for (auto &in : op->input)
         {
-            if(cost)
+            if (cost)
             {
                 *cost += getCost(in);
             }
             // record input val mapping, only if not already recorded. This happens when the same value feeds both operands.
-            if(result.mapping.find(in) == result.mapping.end())
+            if (result.mapping.find(in) == result.mapping.end())
                 result.mapping[in] = unmapAllMRRGNodes(in);
         }
     }
 
-    if(op->opcode != OPGRAPH_OP_OUTPUT && op->opcode != OPGRAPH_OP_STORE)
+    if (op->opcode != OPGRAPH_OP_OUTPUT && op->opcode != OPGRAPH_OP_STORE)
     {
-        if(cost)
+        if (cost)
         {
             *cost += getCost(op->output);
         }
@@ -614,46 +715,43 @@
 
 void AnnealMapper::restoreOp(OpMapping oldmap)
 {
-    for(auto m = oldmap.mapping.begin(); m != oldmap.mapping.end(); ++m)
+    for (auto m = oldmap.mapping.begin(); m != oldmap.mapping.end(); ++m)
     {
         mapAllMRRGNodes(m->first, m->second);
     }
 }
 
 // get a random unoccupied  FU
-MRRGNode* AnnealMapper::getRandomUnoccupiedFU(MRRG* mrrg, OpGraphOp* op)
+MRRGNode *AnnealMapper::getRandomUnoccupiedFU(MRRG *mrrg, OpGraphOp *op)
 {
-    std::vector<MRRGNode*> candidates;
-    for(auto & fu : mrrg->function_nodes)
-    {
-        if(fu->canMapOp(op) && occupancy[fu] == 0)
-        {
-            candidates.push_back(fu);
-        }
-    }
+    int min_cycle = 0;
+    for(auto input_val: op->input){
+        auto op =  input_val->input;
+         if (mapping[op].size() != 0){
+            int cyclye = mapping[op].front()->cycle;
+            min_cycle =  cyclye>min_cycle? cyclye:min_cycle;
+         }
 
-    if(candidates.size() < 1)
-    {
-        cout << "Could not place: " << *op << endl;
-        assert(candidates.size() > 0);
     }
-
-    return candidates[rand() % candidates.size()];
-}
-
-// generate a random FU
-MRRGNode* getRandomFU(MRRG* mrrg, OpGraphOp* op)
-{
-    std::vector<MRRGNode*> candidates;
-    for(auto & fu : mrrg->function_nodes)
+    std::vector<MRRGNode *> candidates;
+    std::vector<MRRGNode *> badcandidates;
+    for (auto &fu : mrrg->function_nodes)
     {
-        if(fu->canMapOp(op))
+        if (fu->canMapOp(op) && occupancy[fu] == 0)
         {
-            candidates.push_back(fu);
+            if(fu->cycle < min_cycle){
+                candidates.push_back(fu);
+            }
+            badcandidates.push_back(fu);
         }
     }
+    if (candidates.size() < 1){
+        candidates =  badcandidates;
+    }else {
+            return candidates[rand() % candidates.size()];
 
-    if(candidates.size() < 1)
+    }
+    if (candidates.size() < 1)
     {
         cout << "Could not place: " << *op << endl;
         assert(candidates.size() > 0);
@@ -662,33 +760,6 @@
     return candidates[rand() % candidates.size()];
 }
 
-
-    template <typename type>
-std::vector<type> vector_intersect(std::vector<type> v1, std::vector<type> v2)
-{
-    std::sort(v1.begin(), v1.end());
-    std::sort(v2.begin(), v2.end());
-
-    std::vector<type> v_intersection;
-
-    std::set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), std::back_inserter(v_intersection));
-
-    return v_intersection;
-}
-
-std::vector<MRRGNode*> filterCanMapOp(std::vector<MRRGNode*> fus, OpGraphOp const * op)
-{
-    std::vector<MRRGNode*> result;
-    for(auto &f : fus)
-    {
-        if(f->canMapOp(op))
-        {
-            result.push_back(f);
-        }
-    }
-
-    return result;
-}
 /*
 bool compare_mrrg_node_occupancy(MRRGNode* a, MRRGNode* b)
 {
@@ -746,21 +817,6 @@
     return nodes2[rand() % nodes2.size()].first;
 }
 */
-std::vector<std::pair<MRRGNode*, int>> candidate_fu_intersect(std::vector<std::pair<MRRGNode*, int>> v1, std::vector<std::pair<MRRGNode*, int>> v2)
-{
-    std::vector<std::pair<MRRGNode*, int>> result;
-
-    for(auto & p : v1)
-    {
-        for(auto & n : v2)
-        {
-            if(p.first == n.first)
-                result.push_back({p.first, p.second + n.second});
-        }
-    }
-
-    return result;
-}
 
 /*
 MRRGNode* getInputMRRGNode(OpGraphOp* op, int operand)
@@ -831,36 +887,38 @@
     return getRandClosestLeastOccupied(filtered_candidates);
 }
 */
-bool AnnealMapper::placeOp(OpGraphOp* op, MRRGNode* n)
+bool AnnealMapper::placeOp(OpGraphOp *op, MRRGNode *n)
 {
     assert(n->type == MRRG_NODE_FUNCTION);
 
-    if(mapping[op].size() != 0) // Make sure this op is not placed anywhere else
+    if (mapping[op].size() != 0) // Make sure this op is not placed anywhere else
         return false;
 
     mapMRRGNode(op, n);
 
+    mapped_pos.insert(mpos{n->x_, n->y_, n->cycle});
+
     return true;
 }
 
 inline bool accept(float delta_cost, float temperature)
 {
-    if(delta_cost < 0)
+    if (delta_cost < 0)
         return true;
 
     float probability = exp(-(delta_cost) / temperature);
 
-    return probability > ((float) rand() / (float) RAND_MAX);
+    return probability > ((float)rand() / (float)RAND_MAX);
 }
 
 inline bool accept(float new_cost, float old_cost, float temperature)
 {
-    if(new_cost < old_cost)
+    if (new_cost < old_cost)
         return true;
 
     float probability = exp(-(new_cost - old_cost) / temperature);
 
-    return probability > ((float) rand() / (float) RAND_MAX);
+    return probability > ((float)rand() / (float)RAND_MAX);
 }
 
 inline float AnnealMapper::updateTempConst(float t)
@@ -868,68 +926,53 @@
     return t * const_temp_factor; //0.999;
 }
 
-float updateTemperature(float t, float acceptance_rate)
-{
-    if(acceptance_rate > 0.96)
-    {
-        return t * 0.5;
-    }
-    else if(acceptance_rate > 0.8)
-    {
-        return t * 0.9;
-    }
-    else if(acceptance_rate > 0.15)
-    {
-        return t * 0.98;
-    }
-    else
-    {
-        return t * 0.95;
-    }
-}
-
-bool AnnealMapper::routeOp(OpGraphOp* op, MRRG* mrrg)
+bool AnnealMapper::routeOp(OpGraphOp *op, MRRG *mrrg)
 {
     bool result = true;
     // route input vals
-    if(op->opcode != OPGRAPH_OP_INPUT && op->opcode != OPGRAPH_OP_CONST)
+    if (op->opcode != OPGRAPH_OP_INPUT && op->opcode != OPGRAPH_OP_CONST)
     {
-        for(auto v = op->input.begin(); v != op->input.end(); ++v)
+        for (auto v = op->input.begin(); v != op->input.end(); ++v)
         {
+            if(!(*v)) continue;
             // check all nodes and make sure prev is NULL
-            for(auto node = mrrg->function_nodes.begin(); node != mrrg->function_nodes.end(); ++node)
+            for (auto node = mrrg->function_nodes.begin(); node != mrrg->function_nodes.end(); ++node)
                 (*node)->prev = NULL;
 
-            for(auto node = mrrg->routing_nodes.begin(); node != mrrg->routing_nodes.end(); ++node)
+            for (auto node = mrrg->routing_nodes.begin(); node != mrrg->routing_nodes.end(); ++node)
                 (*node)->prev = NULL;
 
+            
             bool r = routeVal(*v);
-            if(!r)
+            updateOveruse(mrrg);
+            if (!r)
             {
-                cout << "Could not route val: \"" << **v << "\". Turn on DEBUG_ROUTING for more info." << endl;
+                // cout << "Could not route val: \"" << **v << "\". Turn on DEBUG_ROUTING for more info." << endl;
             }
             result &= r;
         }
     }
 
     // route output val
-    if(op->opcode != OPGRAPH_OP_OUTPUT && op->opcode != OPGRAPH_OP_STORE)
+    if (op->opcode != OPGRAPH_OP_OUTPUT && op->opcode != OPGRAPH_OP_STORE)
     {
         // check all nodes and make sure prev is NULL
-        for(auto node = mrrg->function_nodes.begin(); node != mrrg->function_nodes.end(); ++node)
+        for (auto node = mrrg->function_nodes.begin(); node != mrrg->function_nodes.end(); ++node)
             (*node)->prev = NULL;
 
-        for(auto node = mrrg->routing_nodes.begin(); node != mrrg->routing_nodes.end(); ++node)
+        for (auto node = mrrg->routing_nodes.begin(); node != mrrg->routing_nodes.end(); ++node)
             (*node)->prev = NULL;
 
         bool r = routeVal(op->output);
-        if(!r)
+        updateOveruse(mrrg);
+
+        if (!r)
         {
-            cout << "Could not route val: \"" << *(op->output) << "\". Turn on DEBUG_ROUTING for more info." << endl;
+            // cout << "Could not route val: \"" << *(op->output) << "\". Turn on DEBUG_ROUTING for more info." << endl;
         }
         result &= r;
     }
-
+    // LOG(SA)<<" route "<< op->name << " "<<result<<"\n";
     return result;
 }
 
@@ -944,10 +987,30 @@
 
 // This is the main mapping function
 // true on success, false on failure
-Mapping AnnealMapper::mapOpGraph(std::shared_ptr<OpGraph> opgraph, int II) 
+Mapping AnnealMapper::mapOpGraph(std::shared_ptr<OpGraph> opgraph, int II, std::string arch_model_name)
 {
-    // get the mrrg object 
-    MRRG* mrrg = cgra->getMRRG(II).get();
+    // get the mrrg object
+    MRRG *mrrg = cgra->getMRRG(II).get();
+
+     for(int i = 0; i< systolic_array_x; i++){
+        for(int j=0; j< systolic_array_y;j++){
+            systolic_pe_index.emplace(std::make_pair(i,j),sys_arr[i][j]);
+        }
+    }
+        arch_model_name_ = arch_model_name;
+
+
+    this->this_mrr = mrrg;
+    if (arch_model_name_.find("systolic") != std::string::npos) {
+        this_mrr->makeSystolicArray(systolic_pe_index, systolic_array_x);
+    }
+
+     if (arch_model_name_.find("leftmostmemory") != std::string::npos) {
+        this_mrr->makeLeftMostMemoryAccess();
+    }
+
+    MAX_OVERUSE = opgraph->op_nodes.size() * 100;
+
 
     // Create result obj
     Mapping mapping_result(cgra, II, opgraph);
@@ -955,6 +1018,13 @@
     // Set the random seed
     srand(this->rand_seed);
 
+     for(auto node: mrrg->routing_nodes){
+        occupancy[node] = 0;
+    }
+    for(auto node: mrrg->function_nodes){
+        occupancy[node] = 0;
+    }
+
 #ifdef ANNEAL_DEBUG
     ofstream anneal_debug;
     anneal_debug.open("anneal_debug.csv");
@@ -964,39 +1034,93 @@
     // TODO: This does not work on graphs with back edges
     // topological_sort(opgraph);
 
-    cout << "Initial placement:" << endl;
+    LOG(SA) << "Initial placement:" << "\n";
+
+     std::vector<OpGraphOp*>  sorted_nodes;
+    for(auto node: opgraph->op_nodes){
+        if(find(sorted_nodes.begin(), sorted_nodes.end(),node) == sorted_nodes.end()){
+            sorted_nodes.push_back(node);
+        }
+    }
     // randomized initial placement
-    for(auto & op: opgraph->op_nodes)
+    std::map<OpGraphNode*, MRRGNode*>  bestPlacement;
+    int min_cost  = 10000000;
+     bool routed = true;
+    for(int i  = 0 ; i < 100 ; i++){
+        routed = true;
+        std::map<OpGraphNode*, MRRGNode*>  currPlacement;
+
+         for (auto &op : sorted_nodes)
+        {
+    #ifdef ALLOW_MULTIPLE_PLACEMENT
+            MRRGNode *fu = getRandomFU(mrrg, op);
+    #else
+            MRRGNode *fu = getRandomUnoccupiedFU(mrrg, op);
+    #endif
+            LOG(SA) <<"iter:"<< i <<" " << *op << " : " << *fu << "\n";
+            bool placed = placeOp(op, fu);
+            currPlacement.emplace(op, fu);
+            assert(placed);
+        }
+
+        for (auto &op :sorted_nodes)
+        {
+            routed = routeOp(op, mrrg);
+            
+            if(!routed) break;
+        }
+
+        if(routed) {
+            int curr_cost = getCost(mrrg);
+            if(curr_cost < min_cost){
+                bestPlacement =  currPlacement;
+                min_cost = curr_cost;
+            }
+        }
+
+        for (auto &op :sorted_nodes)
+        {
+            ripUpOp(op);
+        }
+
+        if( i == 50) {
+            allow_overuse =  true;
+            LOG(SA) <<"iter:"<< i <<" set overuse\n" ;
+        }
+        
+    }
+    
+    if(!routed) return mapping_result;
+    for (auto &op : sorted_nodes)
     {
-#ifdef ALLOW_MULTIPLE_PLACEMENT
-        MRRGNode* fu = getRandomFU(mrrg, op);
-#else
-        MRRGNode* fu = getRandomUnoccupiedFU(mrrg, op);
-#endif
-        cout << *op << " : " << *fu << endl;
-        bool routed = placeOp(op, fu );
-        assert(routed);
+        ripUpOp(op);
     }
-
-    for(auto & op: opgraph->op_nodes)
+        for (auto &op : sorted_nodes)
+    {
+        placeOp(op, bestPlacement[op]);
+    }
+    for (auto &op :sorted_nodes)
     {
-        bool routed = routeOp(op, mrrg);
+        routed = routeOp(op, mrrg);
+        
         assert(routed);
     }
 
+    allow_overuse =  false;
+
     // Verify initial place and route
-    for(auto & op: opgraph->op_nodes)
+    for (auto &op : sorted_nodes)
     {
-        if(mapping[op].size() == 0)
+        if (mapping[op].size() == 0)
         {
             cout << "No initial placement for: " << op->name << endl;
             assert(0);
         }
     }
 
-    for(auto & val: opgraph->val_nodes)
+    for (auto &val : sorted_nodes)
     {
-        if(mapping[val].size() == 0)
+        if (mapping[val].size() == 0)
         {
             cout << "No initial routing for: " << val->name << endl;
             assert(0);
@@ -1006,7 +1130,9 @@
 #ifdef CALCULATE_INITIAL_TEMPERATURE
     /************************* TRY TO DO 100 iterations before annealing********/
 
-    cout << "Finding delta Costs:" << endl << "INITIAL:" << endl << "OpGraph Cost: " <<  getCost(opgraph.get()) << endl;
+    cout << "Finding delta Costs:" << endl
+         << "INITIAL:" << endl
+         << "OpGraph Cost: " << getCost(opgraph.get()) << endl;
     cout << "MRRG Cost: " << getCost(mrrg) << endl;
     cout << "Penalty Factor: " << pfactor << endl;
 
@@ -1021,22 +1147,27 @@
         int index = rand() % vector_size;
 
         //perturb at this index
-        OpGraphOp* op = opgraph->op_nodes[index];
+        OpGraphOp *op = opgraph->op_nodes[index];
 
         //substitute a new fu
-        MRRGNode* fu;
+        MRRGNode *fu;
         fu = getRandomFU(mrrg, op);
 
-        if (fu->canMapOp(op)){
+        if (fu->canMapOp(op))
+        {
             //check if occupied
-            if(occupancy[fu] == 0)
+            if (occupancy[fu] == 0)
             {
                 //move there
                 OpMapping oldmap = ripUpOp(op);
                 bool success = placeOp(op, fu);
                 if (success)
                     success = routeOp(op, mrrg);
-                assert(success);
+                if(!success){
+                    ripUpOp(op);
+                    restoreOp(oldmap);
+                    continue;
+                } 
 
                 //get new cost
                 float new_cost = getCost(mrrg);
@@ -1047,7 +1178,6 @@
                 //restore changes
                 ripUpOp(op);
                 restoreOp(oldmap);
-
             }
             else
             {
@@ -1056,10 +1186,10 @@
 #endif
                 //swap, rip off two nodes?
                 //first find the op node corresponding to this mrrg node
-                OpGraphOp* second_op = getOpNodePtr(opgraph.get(), fu);
+                OpGraphOp *second_op = getOpNodePtr(opgraph.get(), fu);
 
                 //keep track of op's MRRG Node
-                MRRGNode* first_MRRGNode = getMappedMRRGNode(op);
+                MRRGNode *first_MRRGNode = getMappedMRRGNode(op);
 
                 //swap these two nodes
                 OpMapping oldmap_x = ripUpOp(op);
@@ -1105,12 +1235,12 @@
     float natural_log = log(accept_percentage);
 
     // initial temperature
-    float temperature = (-1)*max_delta_cost/(natural_log);
-    cout << " max delta cost is " << max_delta_cost <<endl;
+    float temperature = (-1) * max_delta_cost / (natural_log);
+    cout << " max delta cost is " << max_delta_cost << endl;
 #else
     float temperature = 1000000.0;
 #endif
-    cout << "Initial Temperature is " << temperature <<endl;
+    cout << "Initial Temperature is " << temperature << endl;
 
     /************************** Done 100 iterations **************************************/
 
@@ -1120,60 +1250,60 @@
     double current_time = getcurrenttime();
 
     float current_cost = getCost(mrrg);
-    while(no_timelimit || (current_time - start_time) < timelimit)
+    while (no_timelimit || (current_time - start_time) < timelimit)
     {
         float accept_rate = 0.0;
         float previous_cost = current_cost;
-        cout << "Annealing at:" << endl;
-        cout << "\ttemp: " << temperature << endl;
-        cout << "\tpfactor: " << pfactor << endl;
-        if(inner_place_and_route_loop(opgraph.get(), mrrg, temperature, &accept_rate))
+        LOG(SA) << "Annealing at:"
+                << "\ttemp: " << temperature
+                << "\tpfactor: " << pfactor;
+        if (inner_place_and_route_loop(opgraph.get(), mrrg, temperature, &accept_rate))
         {
             mapping_result.setMapping(mapping);
-            cout << "MappingTime: " << (int)(getcurrenttime() - start_time) << endl;
-            cout << "MapperTimeout: 0" << endl;
-            cout << "Mapped: 1" << endl;
+            LOG(SA) << "MappingTime: " << (int)(getcurrenttime() - start_time);
+            LOG(SA) << "MapperTimeout: 0";
+            LOG(SA) << "Mapped: 1";
             mapping_result.setMapped(true);
             return mapping_result;
         }
         current_cost = getCost(mrrg);
 
 #ifdef ANNEAL_DEBUG
-        anneal_debug << temperature <<",";
-        anneal_debug << current_cost <<",";
-        anneal_debug << pfactor <<",";
+        anneal_debug << temperature << ",";
+        anneal_debug << current_cost << ",";
+        anneal_debug << pfactor << ",";
         anneal_debug << endl;
 #endif
         // TODO: Changed from 0.01
         //if(temperature  < 0.001 * mrrg->getCost(pfactor) / mrrg->routing_nodes.size())
-        if(accept_rate < cold_accept_rate && current_cost >= previous_cost)
+        if (accept_rate < cold_accept_rate && current_cost >= previous_cost)
         {
 #ifdef ANNEAL_DEBUG
             anneal_debug.close();
 #endif
-            cout << "Mapper is Cold and no valid mapping was found." << endl;
-            cout << "Current Temperature acceptance rate was: " << accept_rate << endl;
-            cout << "Cold acceptance rate is: " << cold_accept_rate << endl;
-            cout << "Current Cost is: " << current_cost << endl;
-            cout << "Previous  Cost was: " << previous_cost << endl;
-            cout << "Mapped: 0" << endl;
+            LOG(SA) << "Mapper is Cold and no valid mapping was found.";
+            LOG(SA) << "Current Temperature acceptance rate was: " << accept_rate;
+            LOG(SA) << "Cold acceptance rate is: " << cold_accept_rate;
+            LOG(SA) << "Current Cost is: " << current_cost;
+            LOG(SA) << "Previous  Cost was: " << previous_cost;
+            LOG(SA) << "Mapped: 0";
             return mapping_result;
         }
-        cout << "mrrg cost: " << getCost(mrrg) << endl;
-        cout << "mrrg size: " << mrrg->routing_nodes.size() << endl;
-        cout << "update temp. & pfactor" << endl;
+        LOG(SA) << "mrrg cost: " << getCost(mrrg);
+        LOG(SA) << "mrrg size: " << mrrg->routing_nodes.size();
+        LOG(SA) << "update temp. & pfactor";
         // update temperature
 #ifdef SIMPLE_ANNEAL_SCHEDULE
         temperature = updateTempConst(temperature);
 #else
-        temperature = updateTemperature(temperature, (float)total_accepted/total_tries);
+        temperature = updateTemperature(temperature, (float)total_accepted / total_tries);
 #endif
         // update overuse penalty
         pfactor = pfactor * pfactor_factor;
 
         current_time = getcurrenttime();
 
-        cout << "current run time: " << (int)(current_time -start_time)<< endl;
+        LOG(SA) << "current run time: " << (int)(current_time - start_time);
     }
 
     cout << "MapperTimeout: 1" << endl;
@@ -1182,38 +1312,38 @@
     return mapping_result;
 }
 
-bool AnnealMapper::inner_place_and_route_loop(OpGraph* opgraph, MRRG* mrrg, float temperature, float* accept_rate)
+bool AnnealMapper::inner_place_and_route_loop(OpGraph *opgraph, MRRG *mrrg, float temperature, float *accept_rate)
 {
-    int num_swaps = opgraph->op_nodes.size() * swap_factor;
+    int num_swaps =  swap_factor  ;
     int total_accepted = 0;
     int total_tries = 0;
 
-    for(int i = 0; i < num_swaps; i++)
+    for (int i = 0; i < num_swaps; i++)
     {
         // Get an op
-        OpGraphOp* op = opgraph->op_nodes[rand() % opgraph->op_nodes.size()];
+        OpGraphOp *op = opgraph->op_nodes[rand() % opgraph->op_nodes.size()];
 
         // Get an fu
-        MRRGNode* fu = getRandomFU(mrrg, op);
+        MRRGNode *fu = getRandomFU(mrrg, op);
         // make sure that it is a different FU
-        if(fu == getMappedMRRGNode(op))
+        if (fu == getMappedMRRGNode(op))
             continue;
 
         //find the cost of this selected op
         float old_cost = getCost(mrrg); //getTotalOpCost(op);
 
-        if(fu->canMapOp(op))
+        if (fu->canMapOp(op))
         {
             // This is an actual attempt to swap
             total_tries++;
 
             //check if occupied
-            if(occupancy[fu] == 0)
+            if (occupancy[fu] == 0)
             {
                 //move there
                 OpMapping oldmap = ripUpOp(op);
                 bool success = placeOp(op, fu);
-                if(!success)
+                if (!success)
                 {
                     cout << "Could not place OP" << endl;
                     assert(success);
@@ -1222,18 +1352,18 @@
                 if (success)
                 {
                     success = routeOp(op, mrrg);
-                    if(!success)
-                    {
-                        cout << "Could not route OP. It is likely that there is a disconnect in the architecture." << endl;
-                        assert(success);
-                    }
+                    if(!success){
+                        ripUpOp(op);
+                        restoreOp(oldmap);
+                        continue;
+                    } 
                 }
 
                 //get new cost
                 float new_cost_x = getCost(mrrg); // getTotalOpCost(op);
                 float delta_cost = new_cost_x - old_cost;
 
-                if(accept(delta_cost, temperature))
+                if (accept(delta_cost, temperature))
                 {
                     total_accepted++;
                 }
@@ -1247,15 +1377,15 @@
             else // there must only be one unit mapped here
             {
 #ifndef ALLOW_MULTIPLE_PLACEMENT
-                assert(fu -> occupancy == 1);
+                assert(fu->occupancy == 1);
 #endif
 
                 //swap, rip off two nodes?
                 //first find the op node corresponding to this mrrg node
-                OpGraphOp* second_op = getOpNodePtr(opgraph, fu);
+                OpGraphOp *second_op = getOpNodePtr(opgraph, fu);
 
                 //keep track of op's MRRG Node
-                MRRGNode* first_MRRGNode = getMappedMRRGNode(op);
+                MRRGNode *first_MRRGNode = getMappedMRRGNode(op);
 
                 //swap these two nodes
                 OpMapping oldmap_x = ripUpOp(op);
@@ -1279,7 +1409,7 @@
 
                 float new_cost = getCost(mrrg);
                 float delta_cost = new_cost - old_cost;
-                if(accept(delta_cost, temperature))
+                if (accept(delta_cost, temperature))
                 {
                     total_accepted++;
                 }
@@ -1295,9 +1425,9 @@
     }
 
     bool mrrg_overuse = checkOveruse(mrrg);
-    float opgraph_cost  = getCost(opgraph);
+    float opgraph_cost = getCost(opgraph);
 
-    if(!mrrg_overuse)
+    if (!mrrg_overuse)
     {
         cout << "MRRG OVERUSED!" << endl;
     }
@@ -1306,16 +1436,15 @@
         cout << "MRRG NOT OVERUSED!" << endl;
     }
 
-    if(mrrg_overuse && opgraph_cost < INFINITY)
+    if (mrrg_overuse && opgraph_cost < INFINITY)
     {
         cout << "mrrg cost: " << getCost(mrrg) << endl;
         cout << "mrrg size: " << mrrg->routing_nodes.size() << endl;
         cout << "temp: " << temperature << endl;
         cout << "pfactor: " << pfactor << endl;
-        *accept_rate = (float) total_accepted / (float) total_tries;
+        *accept_rate = (float)total_accepted / (float)total_tries;
         return true;
     }
-    *accept_rate = (float) total_accepted / (float) total_tries;
+    *accept_rate = (float)total_accepted / (float)total_tries;
     return false;
 }
-
diff -Nur cgra_me/src/core/CMakeLists.txt lisa/cgra_me/src/core/CMakeLists.txt
--- cgra_me/src/core/CMakeLists.txt	2018-05-09 09:34:57.000000000 +0800
+++ lisa/cgra_me/src/core/CMakeLists.txt	2022-02-28 16:37:25.912775566 +0800
@@ -2,6 +2,11 @@
   core
   OBJECT
   AnnealMapper.cpp
+  ./lisa/LISAMapper.cpp
+  ./lisa/LISAController.cpp
+  ./lisa/LISASchedule.cpp
+  ./lisa/LISADFG.cpp
+  ./lisa/gnn.cpp
   BitSetting.cpp
   BitStream.cpp
   CGRA.cpp
diff -Nur cgra_me/src/core/ILPMapper.cpp lisa/cgra_me/src/core/ILPMapper.cpp
--- cgra_me/src/core/ILPMapper.cpp	2018-05-09 09:34:57.000000000 +0800
+++ lisa/cgra_me/src/core/ILPMapper.cpp	2022-02-28 16:37:25.916775574 +0800
@@ -114,10 +114,18 @@
 
 // This is the main mapping function
 // true on success, false on failure
-Mapping ILPMapper::mapOpGraph(std::shared_ptr<OpGraph> opgraph, int II)
+Mapping ILPMapper::mapOpGraph(std::shared_ptr<OpGraph> opgraph, int II, std::string arch_model_name)
 {
     std::cout << "[INFO] Mapping DFG Onto CGRA Architecture..." << std::endl;
 
+     for(int i = 0; i< systolic_array_x; i++){
+        for(int j=0; j< systolic_array_y;j++){
+            systolic_pe_index.emplace(std::make_pair(i,j),sys_arr[i][j]);
+        }
+    }
+        arch_model_name_ = arch_model_name;
+
+
     // Create result obj
     Mapping mapping_result(cgra, II, opgraph);
     
@@ -607,6 +615,13 @@
 {
     // Create mrrg
     MRRG* mrrg = cgra->getMRRG(II).get();
+     if (arch_model_name_.find("systolic") != std::string::npos) {
+        mrrg->makeSystolicArray(systolic_pe_index, systolic_array_x);
+    }
+
+     if (arch_model_name_.find("leftmostmemory") != std::string::npos) {
+        mrrg->makeLeftMostMemoryAccess();
+    }
 
     ILPMapperStatus mapperstatus;
 
diff -Nur cgra_me/src/core/lisa/gnn.cpp lisa/cgra_me/src/core/lisa/gnn.cpp
--- cgra_me/src/core/lisa/gnn.cpp	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/src/core/lisa/gnn.cpp	2022-02-28 16:37:25.916775574 +0800
@@ -0,0 +1,48 @@
+#include <CGRA/lisa/gnn.h>
+
+GNN::GNN(){
+
+  //let us give the dfg a name;
+  dfg_name_ = gen_random(10);
+  LOG(DGNN)<<"set dfg name:"<<dfg_name_;
+
+}
+
+
+void GNN::inference(){
+  dump_dfg();
+  dump_feature();
+  // call_gnn();
+}
+
+
+
+void GNN::dump_dfg(){
+
+  std::ofstream outfile ("./gnn_data/"+dfg_name_+"_edge.txt");
+
+  // for(auto edge: edges){
+  //   int id = node_to_id_[node];
+  //   for(auto input_val: node->input){
+  //     auto s_node = input_val->input;
+  //     assert(node_to_id_.find(s_node) !=  node_to_id_.end());
+  //     outfile << id <<" "<<node_to_id_[s_node]<< std::endl;
+  //   }
+
+  // }
+  outfile.close();
+}
+
+void GNN::dump_feature(){
+
+  std::ofstream outfile ("./gnn_data/"+dfg_name_+"_feature.txt");
+
+  // auto & nodes = opgraph_->op_nodes;
+  // for(auto node: nodes){
+  
+    
+  //   outfile << node->opcode<< std::endl;
+
+  // }
+  outfile.close();
+}
\ No newline at end of file
diff -Nur cgra_me/src/core/lisa/LISAController.cpp lisa/cgra_me/src/core/lisa/LISAController.cpp
--- cgra_me/src/core/lisa/LISAController.cpp	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/src/core/lisa/LISAController.cpp	2022-02-28 16:37:25.916775574 +0800
@@ -0,0 +1,682 @@
+#include <CGRA/lisa/LISAController.h>
+
+LISAController::LISAController(int fabric_x, int fabric_y, std::string dfg_id, std::set<int> nodes, std::map<int, std::string> node_op, std::vector<std::pair<int,int>> edges){
+  fabric_x_ = fabric_x;
+  fabric_y_ = fabric_y;
+  dfg_ = new LISADFG(dfg_id, nodes, node_op, edges);
+  init_label_ = std::make_shared<DFG_label> (); 
+  // std::cout<<"fabric x"<<fabric_x_<<"fabric_y_"<<fabric_y_<<std::endl;
+  initLabels();
+  label_hist.push_back(init_label_);
+  
+}
+
+void LISAController::initLabels(){
+
+  for(auto f: dfg_->node_feature_ )  {
+    if(f.second.asap == 1){
+      start_nodes_.insert(f.first);
+      // std::cout<<"start node"<<f.first<<" ";
+    }
+  }
+
+  //constrcut transitive data dependency
+  std::map<int, std::set<int>> transitive_parents;
+  std::map<int, std::set<int>> transitive_children;
+
+  for (auto node : dfg_->nodes_)
+  {
+      transitive_children.emplace(node, std::set<int>());
+      transitive_parents.emplace(node, std::set<int>());
+  }
+
+  //
+  for(int i = 0 ; i < dfg_->max_length_; i++){
+    for(auto node: dfg_->nodes_){
+      for(auto e: dfg_->edges_){
+        if(e.des == node){
+          transitive_parents[e.des].insert(e.src);
+          for(auto parent: transitive_parents[e.src]){
+            transitive_parents[e.des].insert(parent);
+          }
+        }
+      }
+    }
+  }
+
+  for(auto it: transitive_parents){
+    int node = it.first;
+    for(auto parent: it.second){
+      transitive_children[parent].insert(node);
+    }
+  }
+
+  // std::cout<<"transitive_parents\n";
+  // for(auto i: transitive_parents){
+  //   std::cout<<i.first<<", "<<i.second.size()<<"\n";
+  // }
+  // std::cout<<"transitive_children\n";
+  // for(auto i: transitive_children){
+  //   std::cout<<i.first<<", "<<i.second.size()<<"\n";
+  // }
+  auto asap_sort = [&](int ca, int cb){
+      return dfg_->node_feature_[ca].asap < dfg_->node_feature_[cb].asap;
+    };
+  auto asap_reverse_sort = [&](int ca, int cb){
+      return dfg_->node_feature_[ca].asap > dfg_->node_feature_[cb].asap;
+    };  
+  auto cal_distance = [&, this](int a, int b){
+    auto& a_children = transitive_children[a];
+    auto& b_children = transitive_children[b];
+    std::vector<int> common_children;
+    for(auto ac : a_children){
+      if( b_children.find(ac)!= b_children.end()){
+        common_children.push_back(ac);
+      }
+    }
+    auto& a_parents = transitive_parents[a];
+    auto& b_parents = transitive_parents[b];
+    std::vector<int> common_parents;
+    for(auto ac : a_parents){
+      if( b_parents.find(ac)!= b_parents.end()){
+        common_parents.push_back(ac);
+      }
+    }
+    
+    if(common_children.size() == 0 && common_parents.size() == 0){ return std::make_pair(false, 0);  }
+    
+    
+
+    int dist = 0, child_dist = 0, parent_dist = 0;
+    if(common_children.size() != 0){
+      std::sort(common_children.begin(), common_children.end(), asap_sort );
+      int child = common_children.front();
+      child_dist = (dfg_->cal_dist(a, child) +dfg_->cal_dist(b, child))/2;
+    }
+
+
+    if(common_parents.size() != 0){
+      int parent = common_parents.front();
+      std::sort(common_parents.begin(), common_parents.end(), asap_reverse_sort );
+      parent_dist = (dfg_->cal_dist (parent, a) +dfg_->cal_dist(parent, b))/2;
+    }
+    if(child_dist != 0 && parent_dist!=0 ){
+      dist = (parent_dist + child_dist)/2;
+    }else{
+      dist = parent_dist + child_dist;
+    }
+     
+    return std::make_pair(true, dist);
+  };
+
+  int max_length = dfg_->max_length_;
+  for(auto f: dfg_->node_feature_){
+    auto fet = f.second;
+    int node_id = f.first;
+
+    std::map<int, int> sameLevel_node_distance;
+    std::map<int, std::pair<int, int>> association;
+
+    sameLevel_nodes_with_common_descendent_[node_id] = std::set<int> ();
+    for(auto other_id: dfg_->asap_to_node_[fet.asap]){
+      if (other_id  == node_id) continue;
+      // dist structure: pair(bool, int)  bool means whether they have child or not.
+      auto dist = cal_distance(node_id, other_id);
+      if(dist.first){
+        sameLevel_node_distance[other_id] = dist.second; 
+        sameLevel_nodes_with_common_descendent_[node_id].insert(other_id);
+      }
+    }
+   
+    for(auto parent: dfg_->node_parents_[node_id]){
+      association[parent] =  std::make_pair(0,std::abs(fet.asap - dfg_->node_feature_[parent].asap));
+    }
+     for(auto child: dfg_->node_parents_[node_id]){
+      association[child] =  std::make_pair(0,std::abs(fet.asap - dfg_->node_feature_[child].asap));  ;
+    }
+    init_label_->emplace(node_id, node_label{(fet.asap)*2, fet.input_degree + fet.output_degree, sameLevel_node_distance, association});
+  }
+
+  LOG(DLABEL)<<DFGLabelToStr(*init_label_);
+  best_label_ = init_label_;
+}
+
+
+std::string LISAController::DFGLabelToStr(DFG_label  & dfg_label) const {
+  std::stringstream output;
+  output<<"\n ******** dump labels\n";
+  for(auto nl: dfg_label){
+    output<<"node id:"<<nl.first;
+    output<<nl.second.toStr()<<"\n";
+  }
+  output<<" ******** dump labels finish\n";
+  return output.str();
+}
+
+void LISAController::passMapping(bool isBest, std::map<int, pos3d> & mapping, int max_lat, perf_metric perf){
+
+  if(isBest){
+    std::shared_ptr<DFG_label> extracted_label = std::make_shared<DFG_label> (); 
+    LISASchedule sched (dfg_, fabric_x_, fabric_y_, max_lat, mapping) ;
+    LOG(DLABEL)<<sched.simpleSchedToString();
+    //calculate label;
+    auto sched_order_label = genScheduleOrderLabel(mapping, max_lat);
+    auto comm_label = genCommunicationLabel(mapping, max_lat);
+
+    for(auto node : dfg_->nodes_){
+      auto ass_label = genlAssocationLabel(node, mapping, max_lat);
+      auto sameLevel_node_label = genSameLevelNodeLabel(node, mapping, max_lat);
+      extracted_label->emplace(node, node_label{sched_order_label[node],comm_label[node], sameLevel_node_label, ass_label }); 
+    }
+    LOG(DLABEL)<<DFGLabelToStr(*extracted_label);
+    best_mapping_ = std::make_pair(mapping, max_lat);
+    // std::shared_ptr<dfg_label> update_label = std::make_shared<dfg_label> ();
+    // updateLabel(label_hist.back(), extracted_label, update_label);
+    src_of_best_label_ = best_label_;
+    best_label_ = extracted_label;
+    label_perf.emplace(extracted_label, perf);
+    label_hist.push_back(best_label_);
+    
+  }else{
+    // std::shared_ptr<dfg_label> update_label = std::make_shared<dfg_label> ();
+    // updateLabel(label_hist.back(), src_of_best_label_, update_label);
+    // label_hist.push_back(update_label);
+
+    // doing nothing
+  }
+
+}
+
+//this function is to calculate the difference between two labels of one node. 
+//It is the sum of difference for each feature.
+int LISAController::calLabelDifference(node_label & a_label, node_label & b_label){
+  int difference = 0;
+
+  // check schedule order
+  difference += std::abs(a_label.schedule_order - b_label.schedule_order);
+
+  //sameLevel_node_distance
+  for(auto pair: a_label.sameLevel_node_distance){
+    int node_id = pair.first;
+    auto & b_dis = b_label.sameLevel_node_distance;
+    assert(b_dis.find(node_id)!= b_dis.end());
+    difference += std::abs(pair.second - b_dis[node_id]);
+  }
+
+  //association value
+  for(auto pair: a_label.association){
+    int node_id = pair.first;
+    auto & b_ass= b_label.association;
+    assert(b_ass.find(node_id)!= b_ass.end());
+    difference += std::abs(pair.second.first - b_ass[node_id].first);
+    difference += std::abs(pair.second.second - b_ass[node_id].second);
+  }
+
+  return difference;
+}
+
+std::vector<std::shared_ptr<DFG_label>> LISAController::filterBestLabels(std::vector<std::shared_ptr<DFG_label>> best_labels){
+  if(best_labels.size()==1) return best_labels;
+  int label_number = best_labels.size();
+  std::vector<int> labels_difference; //temporialy, did not use this
+  std::vector<std::set<int>> similarLabel_num;
+  for(int i = 0; i < label_number; i++ ){
+    labels_difference.push_back(0);
+    similarLabel_num.push_back(std::set<int>());
+  }
+
+  std::vector<int> labels_points;
+  for(int i = 0; i < label_number; i++ ){
+    int label_point = 0;
+    for(auto pair: *(best_labels[i]) ){
+      label_point += pair.second.calTotalPoint();
+    }
+    labels_points.push_back(label_point);
+  }
+  int point_sum = 0;
+  for(auto point: labels_points){
+    point_sum += point;
+  }
+  int average_label_point = point_sum/label_number;
+
+  std::string result_filename = "label_filter_log.txt";
+  std::ofstream result_file;
+  result_file.open (result_filename, std::ios_base::app);
+  result_file<<"arch:"<<arch_file_name_<<" average_label_point:"<<average_label_point<<" dfgfile:"<<dfg_file_name_<< "("<<fabric_x_<<","<<fabric_y_<<")\n";
+  result_file<<"before filter: number of labels-"<<label_number<<" "<<" points(";
+  for(auto p: labels_points){
+    result_file<<p<<", ";
+  }
+  result_file<<")\n";
+  result_file<<"difference:"; 
+
+
+  //calculate label difference 
+  for(int i = 0; i < label_number; i++ ){
+    for(int j = i+1; j < label_number; j ++ ){
+      int total_difference = 0;
+      for(auto pair: *(best_labels[i])){
+        int node_id = pair.first;
+        assert(best_labels[j]->find(node_id) != best_labels[j]->end());
+        total_difference += calLabelDifference(pair.second, best_labels[j]->at(node_id));
+      }
+      if(total_difference < label_difference_threashold * average_label_point ){
+        //similar
+        similarLabel_num[i].insert(j);
+        similarLabel_num[j].insert(i);
+      }
+      result_file<<i<<","<<j<<"->"<<total_difference<<" ";
+      labels_difference[i] +=  total_difference;
+      labels_difference[j] +=  total_difference;
+    }
+  }
+
+  std::vector<int> sorted_label;
+  for(int i = 0; i < label_number; i++){
+    sorted_label.push_back(i);
+  }
+  std::sort(sorted_label.begin(), sorted_label.end(), [&](int  a, int b){
+      return similarLabel_num[a].size() > similarLabel_num[b].size();
+  });
+
+
+  std::vector<std::shared_ptr<DFG_label>> updated_labels;
+  updated_labels.push_back( best_labels[sorted_label.front()]);
+  for(auto label_id: similarLabel_num[sorted_label.front()]){
+    updated_labels.push_back(best_labels[label_id]);
+  }
+
+  
+  
+   result_file<<"\nafter filter: number of labels-"<<updated_labels.size()<<" "<<" points("<<sorted_label.front()<<", ";
+  for(auto label_id: similarLabel_num[sorted_label.front()]){
+    result_file<<labels_points[label_id]<<", ";
+  }
+  result_file<<")\n\n"; 
+  
+
+  return updated_labels;
+}
+
+void LISAController::generateCombinedBestLabelHistorically(perf_metric best_perf){
+
+  LOG(COMBINELABEL)<<"best label: "<<best_perf.ii<<" "<<best_perf.cost;
+  if(label_perf.size() == 0){
+     best_label_ = init_label_;
+     return ;
+  }
+  std::shared_ptr<DFG_label> combined_best_label = std::make_shared<DFG_label> (); 
+
+  std::vector<std::shared_ptr<DFG_label>> best_labels;
+  for(auto lp: label_perf){
+    if(lp.second.ii == best_perf.ii){
+      float coef = (float(lp.second.cost)) / best_perf.cost;
+      if(coef <= 1.1){
+        LOG(COMBINELABEL)<<"select label: "<<lp.second.ii<<" "<<lp.second.cost;
+        best_labels.push_back(lp.first);
+      }
+    }
+  }
+  // best_labels = filterBestLabels(best_labels);
+
+
+  int best_label_num = best_labels.size();
+  //dump for gnn label filter
+  {
+     if(dfg_->dfg_id_ != "none"){
+        std::ofstream result_file;
+        result_file.open ("../lisa_gnn/data/labels/"+arch_name_+"/"+ "label_evaluate.txt", std::ios_base::app); 
+        result_file<<dfg_->dfg_id_<<" "<<MII_<<" "<<best_perf.ii<<" "<<best_label_num<<"\n";
+        result_file.close();
+      }
+  }
+
+  
+
+
+  auto temp_label = best_labels.front();
+  for(auto nl: *temp_label ){
+    int node_id = nl.first;
+    LOG(COMBINELABEL)<<"generate combined label for node "<<node_id;
+    auto & basic_label = nl.second;
+    int schedule_order = 0;
+    int communication = 0;
+    std::map<int, int> sameLevel_node_distance;
+    std::map<int, std::pair<int, int>> association;
+    for(auto ass: basic_label.association){
+      association[ass.first] = std::make_pair(0, 0);
+    }
+    for(auto sn: basic_label.sameLevel_node_distance){
+      sameLevel_node_distance[sn.first] = 0;
+    }
+
+    for(auto best_label: best_labels){
+      auto & n_label = best_label->at(node_id); 
+      LOG(COMBINELABEL)<<" select label: "<<n_label.toStr();
+      schedule_order += n_label.schedule_order;
+      communication += n_label.communication;
+      for(auto ass: n_label.association){
+        association[ass.first] = std::make_pair(ass.second.first + association[ass.first].first, ass.second.second +  association[ass.first].second);
+      }
+      for(auto sn: n_label.sameLevel_node_distance){
+        sameLevel_node_distance[sn.first] = sameLevel_node_distance[sn.first] + sn.second;
+      }
+    }
+    for(auto s : association){
+      association[s.first] = std::make_pair(s.second.first/best_label_num, s.second.second/best_label_num);
+    }
+    for(auto s: sameLevel_node_distance){
+      sameLevel_node_distance[s.first] = s.second/best_label_num;
+    }
+    node_label final_node_label{schedule_order/best_label_num, communication/best_label_num, sameLevel_node_distance, association};
+    LOG(COMBINELABEL)<<" final label: "<<final_node_label.toStr();
+    combined_best_label->emplace(node_id, final_node_label);
+  }
+
+  best_label_ = combined_best_label;
+
+}
+std::string LISAController::mappingToStr(std::map<int, pos3d> & mapping, int max_lat){
+
+  LISASchedule sched (dfg_, fabric_x_, fabric_y_, max_lat, mapping) ;
+  return sched.simpleSchedToString();
+}
+
+void LISAController::updateLabel(std::shared_ptr<DFG_label> label_a, std::shared_ptr<DFG_label> label_b, std::shared_ptr<DFG_label> update_label){
+  // this function is useless
+  for(auto it = label_a->begin(); it!= label_a->end(); it++){
+    int node_id = it->first;
+    auto & a_l  = it->second;
+    auto b_l =  label_b->at(node_id);
+    LOG(UPDATELABEL)<<node_id ;
+    LOG(UPDATELABEL)<< "node label update source: a " + a_l.toStr();
+    LOG(UPDATELABEL)<< "node label update source: b " + b_l.toStr();
+    node_label update_node_label;
+    updateNodeLabel(a_l, b_l, update_node_label );
+    LOG(UPDATELABEL)<< "update label" + update_node_label.toStr();
+    update_label->emplace(node_id, update_node_label);
+  }
+
+}
+
+void LISAController::updateNodeLabel(node_label & node_label_a, node_label & node_label_b, node_label & update_node_label){
+  update_node_label.schedule_order = (node_label_a.schedule_order + node_label_b.schedule_order) / 2;
+  update_node_label.communication = (node_label_a.communication + node_label_b.communication) / 2;
+  auto & a_ass = node_label_a.association;
+  auto & b_ass = node_label_b.association;
+
+  for(auto a: a_ass){
+    int neighbor = a.first;
+    auto info = a.second;
+    auto last_info =  b_ass[neighbor];
+    update_node_label.association[neighbor] = std::make_pair( (info.first + last_info.first)/2 , (info.second + last_info.second)/2  );
+  }
+
+  auto & a_start = node_label_a.sameLevel_node_distance;
+  auto & b_start = node_label_b.sameLevel_node_distance;
+   for(auto a: a_start){
+    int neighbor = a.first;
+    auto info = a.second;
+    auto last_info =  b_start[neighbor];
+    update_node_label.sameLevel_node_distance[neighbor] = (info + last_info)/2;
+  }
+}
+
+
+std::map<int, int> LISAController::genSameLevelNodeLabel(int node_id, std::map<int, pos3d> & mapping,  int max_lat){
+  std::map<int, int> sameLevel_node_dist;
+
+  int node_x =  mapping[node_id].x;
+  int node_y =  mapping[node_id].y;
+
+
+  for(auto other_node: sameLevel_nodes_with_common_descendent_[node_id]){
+    auto & m = mapping[other_node];
+    int dist = std::abs(m.x- node_x)+std::abs(m.y- node_y);
+    sameLevel_node_dist [other_node] = dist;
+  }
+
+  return sameLevel_node_dist;
+
+}
+std::map<int, int> LISAController::genScheduleOrderLabel(std::map<int, pos3d> & mapping,  int max_lat){
+  std::map<int, int> order;
+
+  int max_value = 2 * dfg_->max_length_;
+  float factor =  (float)max_value / max_lat;
+  for(auto m: mapping){
+    order[m.first] =m.second.t * factor;
+  }
+
+  return order;
+}
+
+std::map<int, int> LISAController::genCommunicationLabel(std::map<int, pos3d> & mapping,  int max_lat){
+  std::map<int, int> label_value;
+
+  auto distance_lambda = [](pos3d a, pos3d b) { 
+    return std::abs(b.t- a.t) + std::abs(b.x- a.x)+std::abs(b.y- a.y); 
+  };
+
+  //calculate distance
+  for(auto m: mapping){
+    int node_id = m.first;
+    auto& pos = m.second;
+    int total_distance = 0;
+    for(auto e: dfg_->edges_){
+      pos3d src, des;
+      if(e.src == node_id ){
+        src = pos;
+        des = mapping[e.des];
+      }else if (e.des == node_id ){
+        src = mapping[e.src];
+        des = pos;
+      }else{
+        continue;
+      }
+      total_distance += distance_lambda(src, des);
+    }
+    label_value[node_id] = total_distance; 
+  }
+
+  return label_value;
+  
+}
+void LISAController::dumpBestLabelForGNNDataSet(){
+  if(dfg_->dfg_id_ == "none"){
+    return;
+  }
+  std::string output_str = labelToStrForGNNDataSet(*best_label_);
+  std::ofstream result_file;
+  result_file.open ("../lisa_gnn/data/labels/"+arch_name_+"/"+ dfg_->dfg_id_+".txt", std::ios_base::trunc); 
+  result_file<<output_str;
+  result_file.close();
+}
+std::string LISAController::labelToStrForGNNDataSet(DFG_label & dfg_label){
+  std::stringstream finaoutput ;
+  for(auto & node_label: dfg_label){
+    finaoutput<<node_label.first<<" "<<node_label.second.schedule_order<<"\n";
+  }
+  finaoutput<<"###\n";
+  for(auto & node_label: dfg_label){
+    finaoutput<<node_label.first<<" "<<node_label.second.communication<<"\n";
+  }
+  finaoutput<<"###\n";
+  std::map<std::pair<int, int>, int> sameLevel_node_distance;
+  std::map<std::pair<int, int>, std::pair<int, int>> association_value;
+  for(auto & node_label: dfg_label){
+    int curr_node_id = node_label.first;
+    for(auto & start_node_info: node_label.second.sameLevel_node_distance){
+      int another_node_id = start_node_info.first;
+      bool pair_exist = false;
+      if( another_node_id > curr_node_id){
+        continue;
+      }
+      sameLevel_node_distance.emplace(std::make_pair(curr_node_id, another_node_id), start_node_info.second);
+    }
+
+    for(auto & ass_info: node_label.second.association){
+      int another_node_id = ass_info.first;
+      if(dfg_->is_edge(curr_node_id, another_node_id)){
+        association_value.emplace(std::make_pair(curr_node_id,another_node_id), ass_info.second);
+      }
+    }
+  }
+  for(auto & dist: sameLevel_node_distance){
+    finaoutput<<dist.first.first<<" "<<dist.first.second<<" "<<dist.second<<"\n";
+  }
+  finaoutput<<"###\n";
+
+  for(auto & ass: association_value){
+    finaoutput<<ass.first.first<<" "<<ass.first.second<<" "<<ass.second.first<<" "<<ass.second.second<<"\n";
+  }
+  return finaoutput.str();
+
+}
+
+std::map<int, std::pair<int, int>> LISAController::genlAssocationLabel(int node_id,std::map<int, pos3d> & mapping,  int max_lat){
+  std::map<int, std::pair<int, int>> ass_label;
+  auto curr_pos = mapping[node_id];
+  int node_t = curr_pos.t;
+  int node_x = curr_pos.x;
+  int node_y = curr_pos.y;
+
+  for(auto& parent: dfg_->node_parents_[node_id]){
+    auto pos = mapping[parent];
+    int t_diff = node_t - pos.t;
+    int x_diff = node_x - pos.x;
+    int y_diff = node_y - pos.y;
+    // time difference can be negative or postive, but physical different must be positive.  
+    ass_label[parent] = std::make_pair(abs(x_diff)+ abs(y_diff), abs(t_diff));
+  }
+
+   for(auto& child: dfg_->node_children_[node_id]){
+    auto pos = mapping[child];
+    int t_diff = node_t - pos.t;
+    int x_diff = node_x - pos.x;
+    int y_diff = node_y - pos.y;
+    // time difference can be negative or postive, but physical different must be positive.  
+    ass_label[child] = std::make_pair(abs(x_diff)+ abs(y_diff), abs(t_diff));
+  }
+  return ass_label;
+}
+void LISAController::callGNNInference(){
+  std::string graph_name = gen_random(10);
+  dumpGraphForInference(graph_name);
+  char* pPath;
+  pPath = getenv ("LISA_DIR");
+  std::string lisa_dir_name ="" ;
+  lisa_dir_name.assign(pPath);
+  
+  std::string command  =  "bash  "+lisa_dir_name+"/cgra_me/call_gnn.sh " + graph_name + " " + arch_name_;
+  // std::cout<<"command line"<<command<<"\n";
+  system(command.c_str());
+  std::shared_ptr<DFG_label> gnn_dfg_label = std::make_shared<DFG_label> (); 
+  getLabelFromFile(*gnn_dfg_label, graph_name);
+  std::cout<<"gnn label"<<DFGLabelToStr(*gnn_dfg_label);
+  best_label_ = gnn_dfg_label;
+}
+
+void LISAController::dumpGraphForInference(std::string graph_name){
+  std::stringstream edge_output;
+  for (auto e: dfg_->edges_)
+  {
+    edge_output<<e.src<<" "<<e.des<<"\n";
+  }
+  std::ofstream result_file;
+  result_file.open ("../lisa_gnn/data/infer/"+ graph_name+".txt", std::ios_base::trunc); 
+  result_file<<edge_output.str();
+  result_file.close();
+
+
+  std::stringstream node_op_output;
+
+  int max_id = 0;
+  for (auto node_id: dfg_->nodes_ ){
+    max_id = std::max(max_id, node_id);
+  }
+
+  for (int i = 0; i <= max_id; i++ ){
+    assert(dfg_->node_op_.find(i) != dfg_->node_op_.end());
+    node_op_output<<dfg_->node_op_[i]<<"\n";
+  }
+  result_file.open ("../lisa_gnn/data/infer/"+ graph_name+"_op.txt", std::ios_base::trunc); 
+  result_file<<node_op_output.str();
+  result_file.close();
+}
+
+void LISAController::getLabelFromFile(DFG_label & dfg_label, std::string graph_name){
+  std::ifstream label_file("../lisa_gnn/data/infer/"+ graph_name+"_label.txt");
+  std::string line;
+  int label_id = 0;
+  std::string singleToken;
+
+  std::map<int, int > schedule_order;
+  std::map<int, int > communication_distance;
+  std::map<std::pair<int, int>, int> sameLevel_node_distance;
+  std::map< std::pair<int, int>, int> neighbor_assocation_spatial;
+  std::map< std::pair<int, int>, int> neighbor_assocation_temporal;
+  while (std::getline(label_file, line)) {
+      if (line.find("###") != std::string::npos) {
+        label_id ++;
+        std::getline(label_file, line);
+      }
+      std::stringstream ss(line);
+      std::vector<int> tokens;
+      while(std::getline(ss,singleToken,' ')){
+        tokens.push_back(atoi(singleToken.c_str()));
+      }
+      if(label_id == 0){
+        assert(tokens.size() == 2);
+        schedule_order.emplace(tokens[0], tokens[1]);
+      // }else if(label_id == 1){
+      //  communication_distance.emplace(tokens[0], tokens[1]);
+      // } assert(tokens.size() == 2);
+      } else if(label_id == 1){
+        assert(tokens.size() == 3);
+        sameLevel_node_distance.emplace(std::make_pair(tokens[0], tokens[1]), tokens[2]);
+      }else if(label_id == 2){
+        assert(tokens.size() == 3);
+        neighbor_assocation_spatial.emplace(std::make_pair(tokens[0], tokens[1]), tokens[2]);
+      }
+      else if(label_id == 3){
+        assert(tokens.size() == 3);
+        neighbor_assocation_temporal.emplace(std::make_pair(tokens[0], tokens[1]), tokens[2]);
+      }else{
+        assert(false);
+      }
+  }
+
+  
+  for(auto od: schedule_order){
+    int id = od.first;
+    int order = od.second;
+    // assert(communication_distance.find(id) != communication_distance.end());
+    int comm = 0;
+    std::map<int, int> this_node_start;
+    for (auto st_info: sameLevel_node_distance){
+      if(st_info.first.first == id){
+        this_node_start.emplace(st_info.first.second, st_info.second);
+      }else if (st_info.first.second == id){
+        this_node_start.emplace(st_info.first.first, st_info.second);
+      }
+    }
+    std::map<int, std::pair<int, int>> this_neigbor_association;
+    for (auto neighbor: neighbor_assocation_spatial){
+      int neihgbor_id = -1;
+      if(neighbor.first.first == id){
+        neihgbor_id = neighbor.first.second;
+      }else if (neighbor.first.second == id){
+        neihgbor_id = neighbor.first.first;
+      }else{
+        continue;
+      }
+      
+      assert(neighbor_assocation_temporal.find(neighbor.first)!= neighbor_assocation_temporal.end());
+      this_neigbor_association.emplace(neihgbor_id, std::make_pair(neighbor.second, neighbor_assocation_temporal[neighbor.first]));
+
+    }
+   
+    dfg_label.emplace(id,  node_label{order, comm, this_node_start, this_neigbor_association});
+  }
+}
\ No newline at end of file
diff -Nur cgra_me/src/core/lisa/LISADFG.cpp lisa/cgra_me/src/core/lisa/LISADFG.cpp
--- cgra_me/src/core/lisa/LISADFG.cpp	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/src/core/lisa/LISADFG.cpp	2022-02-28 16:37:25.916775574 +0800
@@ -0,0 +1,150 @@
+#include <CGRA/lisa/LISADFG.h>
+
+LISADFG::LISADFG(std::string dfg_id, std::set<int> nodes,  std::map<int, std::string> node_op,std::vector<std::pair<int, int>> edges)
+{
+  dfg_id_ = dfg_id;
+  nodes_ = nodes;
+  node_op_ = node_op;
+
+  for(auto node: nodes_){
+    node_parents_[node] = std::set<int>();
+    node_children_[node] = std::set<int>();
+  }
+  for (auto e : edges)
+  {
+    edges_.insert(edge{e.first, e.second});
+    node_children_[e.first].insert(e.second);
+    node_parents_[e.second].insert(e.first);;
+  }
+
+
+  // set node feature
+  for(auto node: nodes){
+    node_feature_[node] = feature{"none", 0 , 0 , 0};
+  }
+  // std::cout<<ToString();
+  calASAP();
+  calDegree();
+  LOG(LISAGNN)<<ToString();
+  for(auto nf: node_feature_){
+    int node_id = nf.first;
+    int asap_value = nf.second.asap;
+    if(asap_to_node_.find(asap_value) == asap_to_node_.end()){
+      asap_to_node_.emplace(asap_value, std::set<int>());
+    }
+
+    asap_to_node_[asap_value].insert(node_id);
+  }
+
+}
+
+
+void LISADFG::calASAP(){
+  std::map<int, int> asap_value;
+  std::set<int> non_scheduled ;
+  for(auto node: nodes_){
+    if(node_parents_[node].size() == 0){
+      asap_value[node] = 1;
+    }else{
+      non_scheduled.insert(node);
+    }
+  }
+
+  assert(non_scheduled.size() != nodes_.size());
+
+  while(non_scheduled.size() > 0){
+    bool erase_node = false;
+
+    for(auto it = non_scheduled.begin(); it != non_scheduled.end( ); ){
+      bool can_start =  true;
+      int max_asap = 1;
+      
+      for(auto parent: node_parents_[*it]){
+        if (non_scheduled.find(parent) != non_scheduled.end()){
+          can_start= false;
+          break;
+        }else{
+          int temp_asap = asap_value[parent];
+          max_asap = temp_asap > max_asap ? temp_asap: max_asap;
+        }
+      }
+
+      if(can_start){
+        asap_value[*it] = max_asap + 1;
+        it =  non_scheduled.erase(it);
+        erase_node = true;
+      }else{
+        it ++;
+      }
+    }
+
+    assert(erase_node);
+  }
+  int max_asap = 0;
+  for(auto value: asap_value){
+      int temp_value = value.second;
+      max_asap = temp_value > max_asap? temp_value:max_asap;
+  }
+  max_length_ = max_asap ; 
+  for(auto node: nodes_){
+    node_feature_ [node].asap = asap_value[node];
+  }
+}
+
+void LISADFG::calDegree(){
+  int max_degree = 0;
+  for(auto node: nodes_){
+    node_feature_ [node].input_degree = node_parents_[node].size();
+    node_feature_ [node].output_degree = node_children_[node].size();
+    int temp_d = node_parents_[node].size() + node_children_[node].size();
+    max_degree = std::max(max_degree,temp_d );
+  }
+  max_degree_ = max_degree;
+}
+
+int LISADFG::cal_dist(int src, int des){
+  std::set<int> to_visit_node;
+  to_visit_node.insert(src);
+
+  int level = 0;
+  while(true){
+    level ++ ;
+    std::set<int> new_nodes ;
+    for(auto node: to_visit_node){
+      for(auto child: node_children_[node]){
+        if( child  == des){
+          return level;
+        }
+        new_nodes.insert(child);
+      }
+    }
+    assert(new_nodes.size() != 0);
+    to_visit_node.clear();
+    for(auto node: new_nodes){
+      to_visit_node.insert(node);
+    }
+  }
+  assert(false);
+}
+std::string LISADFG::ToString(){
+  std::stringstream output;
+  output<<"\n##########node list:\n";
+  for(auto node: nodes_){
+    output<<" node:"<<node<<"\t"<<node_feature_[node].toStr();
+    output<<"\tparent nodes:";
+    for(auto parent:node_parents_[node]){
+      output<<parent<<",";
+    }
+    output<<"\tchildren nodes:";
+    for(auto child:node_children_[node]){
+      output<<child<<",";
+    }
+    output<<"\n";
+  }
+  output<<"##########edges:\n";
+  for(auto edge: edges_){
+    output<<"("<<edge.src<<","<<edge.des<<")  ";
+  }
+  output<<"\n\n";
+  return output.str();
+}
\ No newline at end of file
diff -Nur cgra_me/src/core/lisa/LISAMapper.cpp lisa/cgra_me/src/core/lisa/LISAMapper.cpp
--- cgra_me/src/core/lisa/LISAMapper.cpp	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/src/core/lisa/LISAMapper.cpp	2022-02-28 16:37:25.916775574 +0800
@@ -0,0 +1,2600 @@
+/*******************************************************************************
+ * CGRA-ME Software End-User License Agreement
+ *
+ * The software programs comprising "CGRA-ME" and the documentation provided
+ * with them are copyright by its authors S. Chin, K. Niu, N. Sakamoto, J. Zhao,
+ * A. Rui, S. Yin, A. Mertens, J. Anderson, and the University of Toronto. Users
+ * agree to not redistribute the software, in source or binary form, to other
+ * persons or other institutions. Users may modify or use the source code for
+ * other non-commercial, not-for-profit research endeavours, provided that all
+ * copyright attribution on the source code is retained, and the original or
+ * modified source code is not redistributed, in whole or in part, or included
+ * in or with any commercial product, except by written agreement with the
+ * authors, and full and complete attribution for use of the code is given in
+ * any resulting publications.
+ *
+ * Only non-commercial, not-for-profit use of this software is permitted. No
+ * part of this software may be incorporated into a commercial product without
+ * the written consent of the authors. The software may not be used for the
+ * design of a commercial electronic product without the written consent of the
+ * authors. The use of this software to assist in the development of new
+ * commercial CGRA architectures or commercial soft processor architectures is
+ * also prohibited without the written consent of the authors.
+ *
+ * This software is provided "as is" with no warranties or guarantees of
+ * support.
+ *
+ * This Agreement shall be governed by the laws of Province of Ontario, Canada.
+ *
+ * Please contact Prof. Anderson if you are interested in commercial use of the
+ * CGRA-ME framework.
+ ******************************************************************************/
+
+#include <list>
+#include <algorithm>
+#include <utility>
+#include <queue>
+#include <functional>
+
+#include <assert.h>
+#include <sys/time.h>
+
+#include <CGRA/Exception.h>
+#include <CGRA/CGRA.h>
+#include <CGRA/OpGraph.h>
+#include <CGRA/lisa/LISAMapper.h>
+
+using std::cout;
+using std::endl;
+
+#define ALLOW_MULTIPLE_PLACEMENT
+#define SIMPLE_ANNEAL_SCHEDULE
+#define CALCULATE_INITIAL_TEMPERATURE
+// Debugging output flags
+//#define ANNEAL_DEBUG
+//#define PLACEMENT_DEBUG
+// #define DEBUG_ROUTING
+
+LISAMapper::LISAMapper(std::shared_ptr<CGRA> cgra, int timelimit, const std::map<std::string, std::string> &args)
+    : Mapper(cgra, timelimit)
+{
+    try
+    {
+        rand_seed = std::stoi(args.at("AnnealMapper.random_seed"));
+        pfactor = std::stof(args.at("AnnealMapper.initial_pfactor"));
+        pfactor_factor = std::stof(args.at("AnnealMapper.pfactor_factor"));
+        const_temp_factor = std::stof(args.at("AnnealMapper.constant_temp_factor"));
+        swap_factor = std::stoi(args.at("AnnealMapper.swap_factor"));
+        cold_accept_rate = std::stof(args.at("AnnealMapper.cold_accept_rate"));
+    }
+    catch (const std::exception &e)
+    {
+        throw cgrame_error(std::string("AnnealMapper Parameter Parsing Exception Thrown by: [") + e.what() + "] at File: " + std::string(__FILE__) + " Line: " + std::to_string(__LINE__));
+    }
+}
+LISAMapper::LISAMapper(std::shared_ptr<CGRA> cgra, int timelimit, int rand_seed, float initial_pfactor, float pfactor_factor, float const_temp_factor, int swap_factor, float cold_accept_rate)
+    : Mapper(cgra, timelimit)
+{
+    this->rand_seed = rand_seed;
+    // Initial Penalty Factor
+    this->pfactor = initial_pfactor; //0.001;
+    this->pfactor_factor = pfactor_factor;
+    this->const_temp_factor = const_temp_factor;
+    this->swap_factor = swap_factor;
+    this->cold_accept_rate = cold_accept_rate;
+}
+
+LISAMapper::LISAMapper(std::shared_ptr<CGRA> cgra)
+    : LISAMapper(cgra, 0, 0, 0.001, 1.05, 0.99, 100, 0.01)
+{
+}
+
+float LISAMapper::getCost(MRRGNode *n)
+{
+    float base_cost;
+
+    if (n->type == MRRG_NODE_FUNCTION)
+        base_cost = 2.0;
+    else
+        base_cost = 1.0;
+
+    return base_cost * occupancy[n] + (occupancy[n] <= n->capacity ? 0.0 : (occupancy[n] - n->capacity) * pfactor);
+}
+
+float LISAMapper::getCost(MRRG *mrrg)
+{
+    float total = 0.0;
+    for (auto &node : mrrg->function_nodes)
+    {
+        total += getCost(node);
+    }
+
+    for (auto &node : mrrg->routing_nodes)
+    {
+        total += getCost(node);
+    }
+
+    return total;
+}
+
+float LISAMapper::getFinalCost()
+{
+    float total = 0.0;
+    for (auto &node : mrrg_->function_nodes)
+    {
+        total += getCost(node);
+    }
+
+    for (auto &node : mrrg_->routing_nodes)
+    {
+        total += getCost(node);
+    }
+
+    return total;
+}
+
+float LISAMapper::getCost(OpGraph *opgraph)
+{
+    float result = 0.0;
+    for (auto &op : opgraph->op_nodes)
+    {
+        result += getCost(op);
+    }
+    for (auto &val : opgraph->val_nodes)
+    {
+        result += getCost(val);
+    }
+    return result;
+}
+
+float LISAMapper::getCost(OpGraphNode *n)
+{
+    float result = 0.0;
+
+    if (mapping[n].size() == 0)
+    {
+        cout << "there's an unroute/unmap for OpGraphNode: " << n->name << "\n";
+        result = INFINITY;
+    }
+    else
+    {
+        for (auto &node : mapping[n])
+        {
+            result += getCost(node);
+        }
+    }
+    return result;
+}
+
+bool LISAMapper::checkOveruse(MRRG *mrrg)
+{
+    bool result = true;
+    overuse_fu.clear();
+    for (auto &node : mrrg->function_nodes)
+    {
+        if (occupancy[node] > node->capacity)
+        {
+            LOG(OVERUSE) << *node << " fu is overused. (" << occupancy[node] << "/" << node->capacity << ")\n";
+            result = false;
+            overuse_fu.insert(node);
+        }
+    }
+
+    for (auto &node : mrrg->routing_nodes)
+    {
+        if (occupancy[node] > node->capacity)
+        {
+            
+            LOG(OVERUSE) << *node << " is overused. (" << occupancy[node] << "/" << node->capacity << ")\n";
+            // for(auto mappinged_node: occupancy_detail[node]){
+            //     LOG(OVERUSE) <<"use "<<mappinged_node->name;
+            // }
+            //  LOG(OVERUSE) <<"\n";
+            result = false;
+        }
+        
+    }
+
+    return result;
+}
+
+OpGraphOp *LISAMapper::getOpNodePtr(OpGraph *opgraph, MRRGNode *n)
+{
+    int size_vector = opgraph->op_nodes.size();
+
+    OpGraphOp *return_ptr;
+
+    //loop through all op nodes to find same MRRG node as 'this'
+    //may be very slow
+    for (int i = 0; i < size_vector; i++)
+    {
+        MRRGNode *current_node = getMappedMRRGNode(opgraph->op_nodes[i]);
+        if (current_node == n)
+        {
+            return_ptr = opgraph->op_nodes[i];
+#ifdef DEBUG
+            // TODO: check only one occurance of op ptr
+#else
+            break;
+#endif
+        }
+    }
+
+    return return_ptr;
+}
+
+void LISAMapper::mapMRRGNode(OpGraphNode *opnode, MRRGNode *n)
+{
+    auto mapping_nodes=  mapping[opnode];
+    // if(std::find(mapping_nodes.begin(),mapping_nodes.end(), n) !=mapping_nodes.end()){
+    //     // std::cout<<"*************find node that has been used\n";
+    //     return;
+    // }
+    try
+    {
+        mapping[opnode].push_back(n);
+    }
+    catch (const std::exception &e)
+    {
+        throw cgrame_error(std::string("LISAMapper Exception Thrown by: [") + e.what() + "] at File: " + std::string(__FILE__) + " Line: " + std::to_string(__LINE__));
+    }
+    occupancy[n]++;
+    // occupancy_detail[n].push_back(opnode);
+}
+
+void LISAMapper::mapAllMRRGNodes(OpGraphNode *opnode, std::vector<MRRGNode *> nodes)
+{
+    // map all nodes
+    for (auto &n : nodes)
+    {
+        mapMRRGNode(opnode, n);
+    }
+}
+
+void LISAMapper::unmapMRRGNode(OpGraphNode *opnode, MRRGNode *n)
+{
+    /*
+    for(auto & node: mapping[opnode])
+    {
+        if(node == n)
+        {
+            //occupancy[n]--;
+            //assert(occupancy[n] >= 0);
+            mapping[opnode].erase(n);
+            break;
+        }
+    }
+    */
+
+    try
+    {
+        auto iter = find(mapping[opnode].begin(), mapping[opnode].end(), n);
+        if (iter != mapping[opnode].end())
+        {
+            // for(auto it = occupancy_detail[n].begin();it != occupancy_detail[n].end();it++){
+            //     if((*it) == opnode){
+            //         occupancy_detail[n].erase(it);
+            //         break;
+            //     }
+            // }
+            occupancy[n]--;
+            assert(occupancy[n] >= 0);
+            mapping[opnode].erase(iter);
+        }
+    }
+    catch (const std::exception &e)
+    {
+        throw cgrame_error(std::string("LISAMapper Exception Thrown by: [") + e.what() + "] at File: " + std::string(__FILE__) + " Line: " + std::to_string(__LINE__));
+    }
+}
+
+std::vector<MRRGNode *> LISAMapper::unmapAllMRRGNodes(OpGraphNode *opnode)
+{
+    std::vector<MRRGNode *> result;
+
+    // save mapping
+    result = mapping[opnode];
+
+    // unmap all nodes
+    for (auto &n : mapping[opnode])
+    {
+        occupancy[n]--;
+        //   for(auto it = occupancy_detail[n].begin();it != occupancy_detail[n].end();){
+        //         if((*it) == opnode){
+        //             it = occupancy_detail[n].erase(it);
+        //             break;
+        //         }else{
+        //             it ++;
+        //         }
+        //     }
+        assert(occupancy[n] >= 0);
+    }
+
+    mapping[opnode].clear();
+
+    return result;
+}
+
+/**
+  Returns the MRRGNode that the Op is mapped to, NULL if unmapped
+ **/
+MRRGNode *LISAMapper::getMappedMRRGNode(OpGraphOp *op)
+{
+    std::vector<MRRGNode *> &mapped_nodes = mapping[op];
+    if (mapped_nodes.size() != 0)
+    {
+        assert(mapped_nodes.size() == 1); // Op should only be mapped to a single node
+        assert(mapped_nodes[0]);          // make sure we don't have a NULL pointer
+
+        return mapped_nodes[0];
+    }
+
+    return NULL; // return null if unmapped
+}
+
+// Route a val node on to the MRRG, false if unable to route
+
+//zhaoying comment: CGRA-ME did not check latency. So the mapping might not be accurate.
+// For LISA, we need to map some critical edge first, which needs an accurate latency. It seems we cannot solve this.
+// It seems it is not fair to LISA!!!
+bool LISAMapper::routeVal(OpGraphVal *val, OpGraphOp *output_op )
+{
+    assert(val);
+
+    updateOveruse(mrrg_);
+    int old_overuse = overuse_num_;
+    // cout << "Routing val: " << *val << endl;
+
+
+#ifdef DEBUG_ROUTING
+    cout << "Routing val: " << *val << endl;
+    // cout << "Routing from: " << *(val->input->mapped_nodes[0]) << endl;
+#endif
+    // verify that fanin and fanouts are placed
+    if (mapping[val->input].size() == 0)
+    {
+#ifdef DEBUG_ROUTING
+        cout << "Routing input not mappped!" << endl;
+#endif
+        return false;
+    }
+    // verify fanouts placed; initialize fanout_mapped flags
+    std::map<MRRGNode *, bool> fanout_mapped;
+    std::map<MRRGNode *, unsigned int> output_number;
+
+    // TODO: is this the right place to resize this vector?
+    val->output_latency.resize(val->output.size());
+
+    for (unsigned int i = 0; i < val->output.size(); ++i)
+    {
+        OpGraphOp *fos = val->output[i];
+
+        if(output_op != NULL){
+            if (fos !=  output_op){
+                continue;
+            }
+        }
+
+        if (mapping[fos].size() == 0)
+        {
+#ifdef DEBUG_ROUTING
+            cout << *fos << "NOT MAPPED?!?!" << endl;
+#endif
+            assert(0);
+            return false;
+        }
+        // TODO: this next line of code is so ugly.....
+        MRRGNode *dst = mapping[fos][0]->operand[val->output_operand[i]];
+        #ifdef DEBUG_ROUTING
+            std::cout << "dest" << dst->getFullName() << "\n";
+        #endif
+        output_number[dst] = i;
+        fanout_mapped[dst] = false;
+        // #ifdef DEBUG_ROUTING
+        //         cout << "          to: " << *(fos->mapped_nodes[0]) << ", operand = " << val->output_operand[i] << endl;
+        // #endif
+    }
+
+    assert(fanout_mapped.size() != 0 );
+
+    std::list<MRRGNode *> src_nodes;
+    src_nodes.push_back(mapping[val->input][0]);
+
+    std::map<MRRGNode *, int> min_distance; // if node exites in the map, this node has been mapped.
+    min_distance[mapping[val->input][0]] = 0;
+
+//lamda function
+    auto find_least_occupy_node = [&](MRRGNode *output_node) {
+        int curr_dis = min_distance[output_node] - output_node->latency * 100 - 1;
+        int least_occupy_value = occupancy[output_node->prev];
+        auto least_occupy_node = output_node->prev;
+        // std::cout<<"fan in size "<<output_node->fanin.size()<<"\n";
+        for (auto dddd : output_node->fanin)
+        {
+            if (min_distance.find(dddd) != min_distance.end())
+            {
+                if (min_distance[dddd] == curr_dis)
+                {
+                    if (occupancy[dddd] < least_occupy_value)
+                    {
+                        least_occupy_value = occupancy[dddd];
+                        least_occupy_node = dddd;
+                    }
+                }
+            }
+        }
+        return least_occupy_node;
+    };
+//lamda function2    
+    auto recursive_update = [&](MRRGNode  * node){
+        std::queue<MRRGNode *> update_dist;
+        update_dist.push(node);
+        while(!update_dist.empty()){
+            MRRGNode *update_node = update_dist.front();
+            update_dist.pop();
+            int d_of_updatenode = min_distance[update_node];
+            for (auto output_node : update_node->fanout)
+            {
+                if (min_distance.find(output_node) != min_distance.end())
+                {
+                    bool need_update = false;
+                    if (output_node->prev == update_node)
+                    {
+                        need_update = true;
+                    }
+                    else if ((min_distance[output_node] - output_node->latency * 100 ) > d_of_updatenode - 1)
+                    {
+                        need_update = true;
+                    }
+                    if (!need_update)
+                    {
+                        auto least_node = find_least_occupy_node(output_node);
+                        output_node->prev = least_node;
+                        continue;
+                    }
+
+                    if (min_distance[output_node] <= d_of_updatenode + output_node->latency * 100 + 1)
+                        continue;
+                    output_node->prev = update_node;
+                    update_dist.push(output_node);
+                    min_distance[output_node] = d_of_updatenode + output_node->latency * 100  + 1;
+                }
+            }
+                    
+        }
+    };
+//lamda function3
+    auto update_fanout = [&](MRRGNode *node){
+        int min_d = min_distance[node] - node->latency * 100  - 1;
+        MRRGNode *min_node = node->prev;
+        for (auto node_input : node->fanin)
+        {
+            if (min_distance.find(node_input) != min_distance.end())
+            {
+                int d = min_distance[node_input];
+                if (d < min_d)
+                {
+                    min_d = d;
+                    min_node = node_input;
+                }
+            }
+        }
+        if (min_d == min_distance[node] - node->latency * 100  - 1)
+        {
+            auto least_node = find_least_occupy_node(node);
+            node->prev = least_node;
+            return true;
+        }
+        assert(min_d < min_distance[node] - node->latency * 100  - 1);
+// we need to update the value
+#ifdef DEBUG_ROUTING
+        cout << "-----------update: " << node->getFullName() << " from " << min_distance[node] << " to " << min_d + node->latency << endl;
+#endif
+        min_distance[node] = min_d + node->latency * 100  + 1;
+        assert(min_node != NULL);
+        assert(min_node);
+        node->prev = min_node;
+
+        recursive_update(node);
+
+        return true;
+    };
+
+
+    bool all_fanouts_mapped = false;
+    while (!all_fanouts_mapped)
+    {
+        // try mapping
+        std::priority_queue<std::pair<float, MRRGNode *>, std::vector<std::pair<float, MRRGNode *>>> queue;
+        std::vector<MRRGNode *> nodes_in_queue;
+
+        for (auto s = src_nodes.begin(); s != src_nodes.end(); ++s)
+        {
+#ifdef DEBUG_ROUTING
+            cout << "queueing fanouts of src_node: " << **s << endl;
+#endif
+            for (auto n = (*s)->fanout.begin(); n != (*s)->fanout.end(); ++n)
+            {
+                // check that fanouts arent already in the src_node list
+                // if(occupancy[*n]> 1) continue;
+
+                if (find(src_nodes.begin(), src_nodes.end(), *n) == src_nodes.end() && !(*n)->prev)
+                {
+                    if (occupancy[*n] >= 1 && ( !allow_overuse || overuse_num_ >=  MAX_OVERUSE ) ){
+
+                        continue;
+                    }
+                        
+                    (*n)->prev = (*s);
+                    // std::cout << " add1 fanout" << (*n)->getFullName() << "\n";
+                    min_distance[*n] = min_distance[(*s)] + (*n)->latency * 100  + 1;
+
+                    queue.push(std::make_pair(getCost(*n), (*n)));
+                    //nodes_in_queue.push_back(*n);
+                }
+                else
+                {
+                    // check whether need to update distance
+                    // the idea here: when find a  new node which can reach the old node, check the distance of old node and see if need update.
+                    // if need update, then we recursively update the fan-in. Meanwhile, for each updated node, let us try to find the best fan-in with the
+                    // same least latency but with least occupancy
+                    if (!(*n)->prev)
+                        continue;
+                    if (min_distance.find(*n) == min_distance.end())
+                        continue;
+                    update_fanout(*n);
+                }
+            }
+        }
+
+        // while we still have more routing options, try to route
+        bool mapped_a_node = false;
+        while (!queue.empty())
+        {
+            auto node = queue.top();
+            queue.pop();
+            //nodes_in_queue.erase(find(nodes_in_queue.begin(), nodes_in_queue.end(), node.second));
+
+            float node_cost = node.first;
+            MRRGNode *n = node.second;
+#ifdef DEBUG_ROUTING
+            cout << "queue popped: " << *n << ": " << node_cost << endl;
+#endif
+            // if n is a new sink
+            // test if n->first is in map, then test if is unmapped
+            if (fanout_mapped.find(n) != fanout_mapped.end() && !fanout_mapped[n])
+            {
+#ifdef DEBUG_ROUTING
+                cout << "Router found sink: " << *n << "." << endl;
+#endif
+                // backtrack and mark path
+                // FUTURE TODO: mark dst OpGraphOp node with path statistics: delay, cycle latency etc..
+
+                // add dst node (the node that is the FU input) to the src list.
+                src_nodes.push_back(n);
+
+                unsigned int latency = 0;
+                MRRGNode *k = n->prev;
+
+                while (find(src_nodes.begin(), src_nodes.end(), k) == src_nodes.end())
+                {
+#ifdef DEBUG_ROUTING
+                    cout << *k << endl;
+#endif
+                    //if((*k)->type == MRRG_NODE_REGISTER)
+                    //{
+                    latency += k->latency;
+                    //}
+
+                    // add node to src node list
+                    src_nodes.push_back(k);
+                    // backtrack
+                    k = k->prev;
+                }
+
+                // clear queue and unmark all backtrack paths to src_nodes
+                // inner while loop will end when queue is empty
+                while (!queue.empty())
+                {
+                    auto node_pair = queue.top();
+                    queue.pop();
+                    //nodes_in_queue.erase(find(nodes_in_queue.begin(), nodes_in_queue.end(), node_pair.second));
+
+                    MRRGNode *k = node_pair.second;
+                    // while we haven't backtracked to already removed path AND we havent reached any source nodes
+                    while (k != NULL && find(src_nodes.begin(), src_nodes.end(), k) == src_nodes.end())
+                    {
+                        MRRGNode *prev = k;
+                        k = k->prev;
+                        prev->prev = NULL;
+                        auto it = min_distance.find(prev);
+                        if (it != min_distance.end())
+                            min_distance.erase(it);
+                    }
+                }
+                for (auto it = min_distance.begin(); it != min_distance.end();)
+                {
+                    auto node = it->first;
+                    if (find(src_nodes.begin(), src_nodes.end(), node) == src_nodes.end())
+                    {
+                        it = min_distance.erase(it);
+                    }
+                    else
+                    {
+                        it++;
+                    }
+                }
+
+                // we have now mapped the fanout
+                // std::cout<<"mapped one fanout\n";
+                #ifdef DEBUG_ROUTING
+                        cout << "latency "<<n->getFullName()<<" "<<latency << endl;
+                #endif
+                fanout_mapped[n] = true;
+                val->output_latency[output_number[n]] = latency;
+                mapped_a_node = true;
+            }
+            else
+            {
+                // queue up all fanouts
+                if (n->type == MRRG_NODE_ROUTING)
+                {
+                    for (auto i = n->fanout.begin(); i != n->fanout.end(); ++i)
+                    {
+                        // check that fanouts arent already in the src_node
+                        //  if(occupancy[*i]> 1) continue;
+                        if (!(*i)->prev)
+                        {
+                            if (occupancy[*i] >= 1 && ( !allow_overuse || overuse_num_ >=  MAX_OVERUSE ) ){
+                                continue;
+                            }
+                            (*i)->prev = n;
+                            // std::cout << " add2 fanout" << (*i)->getFullName() << "\n";
+
+                            queue.push(std::make_pair(node_cost + getCost(*i), (*i)));
+                            min_distance[*i] = min_distance[n] + (*i)->latency  * 100 + 1;
+                        }
+                        else
+                        {
+                            // check whether need to update distance
+                            if (min_distance.find(*i) == min_distance.end())
+                                continue;
+                            update_fanout(*i);
+                        }
+                    }
+                }
+            }
+        }
+
+        // if we exited the loop and didn't map a node, we have an unreachable route
+        if (!mapped_a_node) // if we exited the loop and didn't map a node, we have an unreachable route
+        {
+#ifdef DEBUG_ROUTING
+            cout << "Routing Failed" << endl;
+#endif
+            return false;
+        }
+        all_fanouts_mapped = true;
+        for (auto i = fanout_mapped.begin(); i != fanout_mapped.end(); ++i)
+        {
+            all_fanouts_mapped &= i->second;
+        }
+       
+    }
+   
+
+    for (auto s = src_nodes.begin(); s != src_nodes.end(); ++s)
+    {
+        if ((*s)->type == MRRG_NODE_ROUTING)
+        {
+            #ifdef DEBUG_ROUTING
+            cout << "Mapping routing node: " << **s << "  "<<(*s)->latency<<"\n";
+            #endif
+            // map val to this node
+            mapMRRGNode(val, *s);
+        }
+        else
+        {
+#ifdef DEBUG_ROUTING
+            cout << "non routing node in source node list" << endl;
+#endif
+        }
+    }
+  
+#ifdef DEBUG_ROUTING
+    cout << "Routing Succeeded" << endl;
+#endif
+
+   
+    min_distance.clear();
+
+     updateOveruse(mrrg_);
+    int current_overuse = overuse_num_;
+    int overuse_diff = current_overuse - old_overuse;
+    overuse_counter[val->input] =overuse_counter[val->input]  + overuse_diff;
+    for(auto output_node: val->output){
+        overuse_counter[output_node] =overuse_counter[output_node]  + overuse_diff;
+    }
+    // assert(false);
+    return true;
+}
+
+float LISAMapper::getTotalOpCost(OpGraphOp *op)
+{
+    float result = 0.0;
+    result += getCost(op);
+
+    if (op->opcode != OPGRAPH_OP_INPUT && op->opcode != OPGRAPH_OP_CONST)
+    {
+        for (auto in = op->input.begin(); in != op->input.end(); ++in)
+        {
+            result += getCost((*in));
+        }
+    }
+
+    if (op->opcode != OPGRAPH_OP_OUTPUT && op->opcode != OPGRAPH_OP_STORE)
+    {
+        result += getCost(op->output);
+    }
+
+    
+
+    return result;
+}
+
+// Rips up Op as well as routes in and out (if they exist) and records the cost of whatever was ripped up
+// if a pointer to cost is given, the cost is also returned
+OpMapping LISAMapper::ripUpOp(OpGraphOp *op, float *cost)
+{
+    OpMapping result;
+
+    int id = node_to_id_[op];
+    if(mapping[op].size()>0){
+        auto old_fu = mapping[op].front();
+        mpos mmmm{old_fu->x_, old_fu->y_, old_fu->cycle};
+            
+        for(auto it =  mapped_pos.begin(); it!= mapped_pos.end(); ){
+            if(it->x == mmmm.x && mmmm.y == it->y  && mmmm.t == it->t){
+                it = mapped_pos.erase(it);
+            }else{
+                it ++;
+            }
+        }
+    }
+
+    if (cost)
+    {
+        *cost = 0.0;
+        *cost += getCost(op);
+    }
+
+    result.mapping[op] = unmapAllMRRGNodes(op);
+
+    if (op->opcode != OPGRAPH_OP_INPUT && op->opcode != OPGRAPH_OP_CONST)
+    {
+        for (auto &in : op->input)
+        {
+            if (cost)
+            {
+                *cost += getCost(in);
+            }
+            // record input val mapping, only if not already recorded. This happens when the same value feeds both operands.
+            if (result.mapping.find(in) == result.mapping.end())
+                result.mapping[in] = unmapAllMRRGNodes(in);
+        }
+    }
+
+    if (op->opcode != OPGRAPH_OP_OUTPUT && op->opcode != OPGRAPH_OP_STORE)
+    {
+        if (cost)
+        {
+            *cost += getCost(op->output);
+        }
+
+        // record output val mapping
+        result.mapping[op->output] = unmapAllMRRGNodes(op->output);
+    }
+
+    return result;
+}
+
+void LISAMapper::restoreOp(OpMapping oldmap)
+{
+    for (auto m = oldmap.mapping.begin(); m != oldmap.mapping.end(); ++m)
+    {
+        mapAllMRRGNodes(m->first, m->second);
+    }
+}
+
+// get a random unoccupied  FU
+MRRGNode *LISAMapper::getRandomUnoccupiedFU(MRRG *mrrg, OpGraphOp *op)
+{
+    std::vector<MRRGNode *> candidates;
+    for (auto &fu : mrrg->function_nodes)
+    {
+        if (fu->canMapOp(op) && occupancy[fu] == 0)
+        {
+            candidates.push_back(fu);
+        }
+    }
+
+    if (candidates.size() < 1)
+    {
+        cout << "Could not place: " << *op << endl;
+        assert(candidates.size() > 0);
+    }
+
+    return candidates[rand() % candidates.size()];
+}
+/*
+bool compare_mrrg_node_occupancy(MRRGNode* a, MRRGNode* b)
+{
+    return a->occupancy < b->occupancy;
+}
+
+MRRGNode* getRandLeastOccupied(std::vector<MRRGNode*> nodes)
+{
+    assert(nodes.size() > 0);
+    std::random_shuffle(nodes.begin(), nodes.end());
+    std::sort(nodes.begin(), nodes.end(), compare_mrrg_node_occupancy);
+
+    return nodes[0];
+}
+*/
+
+/*
+bool compare_pair_mrrg_node_occupancy(std::pair<MRRGNode*,int> a, std::pair<MRRGNode*,int> b)
+{
+    return a.first->occupancy < b.first->occupancy;
+}
+
+bool compare_pair_mrrg_node_dist(std::pair<MRRGNode*,int> a, std::pair<MRRGNode*,int> b)
+{
+    return a.second < b.second;
+}
+
+MRRGNode* getRandClosestLeastOccupied(std::vector<std::pair<MRRGNode*, int> > nodes)
+{
+    assert(nodes.size() > 0);
+    std::random_shuffle(nodes.begin(), nodes.end());
+    std::sort(nodes.begin(), nodes.end(), compare_pair_mrrg_node_occupancy);
+
+    std::vector<std::pair<MRRGNode*, int>>::iterator firstgroupend;
+
+    int initial_occupancy = nodes[0].first->occupancy;
+    std::vector<std::pair<MRRGNode*, int> > nodes2;
+
+    for(auto fu = nodes.begin(); fu != nodes.end(); fu++)
+    {
+        if((*fu).first->occupancy != initial_occupancy)
+        {
+            firstgroupend = fu;
+            break;
+        }
+        else
+        {
+            nodes2.push_back(*fu);
+        }
+
+    }
+
+    std::sort(nodes2.begin(), nodes2.end(), compare_pair_mrrg_node_dist);
+
+    return nodes2[rand() % nodes2.size()].first;
+}
+*/
+
+/*
+MRRGNode* getInputMRRGNode(OpGraphOp* op, int operand)
+{
+    if(op->opcode == OPGRAPH_OP_INPUT)
+    {
+        return NULL;
+    }
+
+    if(operand < op->input.size())
+    {
+        OpGraphVal* input_val = op->input[operand];
+
+        assert(input_val->input);
+        return getMappedMRRGNode(input_val->input);
+    }
+    else
+    {
+        return NULL;
+    }
+}
+MRRGNode* getNearbyFU(MRRG* mrrg, OpGraphOp* op)
+{
+    // Check input ops to see if they are placed
+    MRRGNode* f0 = getInputMRRGNode(op, 0);
+    MRRGNode* f1 = getInputMRRGNode(op, 1);
+
+    // intersect f0's nearby fu's and f1's nearby fu's
+    std::vector<std::pair<MRRGNode*, int> > candidates;
+    if(f0 && f1)
+    {
+        candidates = candidate_fu_intersect(f0->neighbourFUs, f1->neighbourFUs);
+    }
+    else if(f0)
+    {
+        candidates = f0->neighbourFUs;
+    }
+    else if(f1)
+    {
+        candidates = f1->neighbourFUs;
+    }
+    // else empty set...
+    // maybe try and match output?
+    else
+    {
+
+    }
+
+    // and filter FU's that cant map the OP, then choose the closest and least congested
+    std::vector<std::pair<MRRGNode*, int> > filtered_candidates;
+    for(auto & fu : candidates)
+    {
+        if(fu.first->canMapOp(op))
+        {
+            filtered_candidates.push_back(fu);
+        }
+    }
+
+    if(filtered_candidates.size() < 1)
+    {
+#ifdef PLACEMENT_DEBUG
+        cout << "Could not getNearbyFU for : " << *op << ". Revert to getRandomFU()" << endl;
+#endif
+        // assert(filtered_candidates.size() > 0);
+        return getRandomFU(mrrg, op);
+    }
+
+    return getRandClosestLeastOccupied(filtered_candidates);
+}
+*/
+bool LISAMapper::placeOp(OpGraphOp *op, MRRGNode *n)
+{
+    assert(n->type == MRRG_NODE_FUNCTION);
+
+    if (mapping[op].size() != 0) // Make sure this op is not placed anywhere else
+        return false;
+
+    mapMRRGNode(op, n);
+
+    mapped_pos.insert(mpos{n->x_, n->y_, n->cycle});
+
+    return true;
+}
+
+inline bool accept(float delta_cost, float temperature)
+{
+    if (delta_cost < 0)
+        return true;
+
+    float probability = exp(-(delta_cost) / temperature);
+
+    return probability > ((float)rand() / (float)RAND_MAX);
+}
+
+inline bool accept(float new_cost, float old_cost, float temperature)
+{
+    if (new_cost < old_cost)
+        return true;
+
+    float probability = exp(-(new_cost - old_cost) / temperature);
+
+    return probability > ((float)rand() / (float)RAND_MAX);
+}
+
+inline float LISAMapper::updateTempConst(float t)
+{
+    return t * const_temp_factor; //0.999;
+}
+
+bool LISAMapper::routeOp_withfailed_node(OpGraphOp *op, MRRG *mrrg, std::set<OpGraphOp *> & failed)
+{
+    bool result = true;
+    // route input vals
+    if (op->opcode != OPGRAPH_OP_INPUT && op->opcode != OPGRAPH_OP_CONST)
+    {
+        for (auto v = op->input.begin(); v != op->input.end(); ++v)
+        {
+            // check all nodes and make sure prev is NULL
+            for (auto node = mrrg->function_nodes.begin(); node != mrrg->function_nodes.end(); ++node)
+                (*node)->prev = NULL;
+
+            for (auto node = mrrg->routing_nodes.begin(); node != mrrg->routing_nodes.end(); ++node)
+                (*node)->prev = NULL;
+
+            bool r = routeVal(*v);
+            updateOveruse(mrrg);
+
+            if (!r)
+            {   
+                failed.insert((*v)->input);
+                // cout << "Could not route val: \"" << **v << "\". Turn on DEBUG_ROUTING for more info." << endl;
+            }
+            result &= r;
+        }
+    }
+
+    // route output val
+    if (op->opcode != OPGRAPH_OP_OUTPUT && op->opcode != OPGRAPH_OP_STORE)
+    {
+        // check all nodes and make sure prev is NULL
+        for (auto node = mrrg->function_nodes.begin(); node != mrrg->function_nodes.end(); ++node)
+            (*node)->prev = NULL;
+
+        for (auto node = mrrg->routing_nodes.begin(); node != mrrg->routing_nodes.end(); ++node)
+            (*node)->prev = NULL;
+
+        bool r = routeVal(op->output);
+        updateOveruse(mrrg);
+        if (!r)
+        {
+            for(auto o: op->output->output){
+                failed.insert(o);
+            }
+            
+            // cout << "Could not route val: \"" << *(op->output) << "\". Turn on DEBUG_ROUTING for more info." << endl;
+        }
+        result &= r;
+    }
+
+    return result;
+}
+bool LISAMapper::routeOp(OpGraphOp *op, MRRG *mrrg)
+{
+    bool result = true;
+    // route input vals
+    if (op->opcode != OPGRAPH_OP_INPUT && op->opcode != OPGRAPH_OP_CONST)
+    {
+        for (auto v = op->input.begin(); v != op->input.end(); ++v)
+        {
+
+            if(!(*v)) continue;
+            // check all nodes and make sure prev is NULL
+            for (auto node = mrrg->function_nodes.begin(); node != mrrg->function_nodes.end(); ++node)
+                (*node)->prev = NULL;
+
+            for (auto node = mrrg->routing_nodes.begin(); node != mrrg->routing_nodes.end(); ++node)
+                (*node)->prev = NULL;
+
+            bool r = routeVal(*v);
+            updateOveruse(mrrg);
+            if (!r)
+            {
+                // cout << "Could not route val: \"" << **v << "\". Turn on DEBUG_ROUTING for more info." << endl;
+            }
+            result &= r;
+        }
+    }
+
+    // route output val
+    if (op->opcode != OPGRAPH_OP_OUTPUT && op->opcode != OPGRAPH_OP_STORE)
+    {
+        // check all nodes and make sure prev is NULL
+        for (auto node = mrrg->function_nodes.begin(); node != mrrg->function_nodes.end(); ++node)
+            (*node)->prev = NULL;
+
+        for (auto node = mrrg->routing_nodes.begin(); node != mrrg->routing_nodes.end(); ++node)
+            (*node)->prev = NULL;
+
+        bool r = routeVal(op->output);
+        updateOveruse(mrrg);
+        if (!r)
+        {
+            // cout << "Could not route val: \"" << *(op->output) << "\". Turn on DEBUG_ROUTING for more info." << endl;
+        }
+        result &= r;
+    }
+
+    return result;
+}
+
+bool LISAMapper::routeOpInput(OpGraphOp *op, MRRG *mrrg)
+{
+    bool result = true;
+    // route input vals
+    if (op->opcode != OPGRAPH_OP_INPUT && op->opcode != OPGRAPH_OP_CONST)
+    {
+        for (auto v = op->input.begin(); v != op->input.end(); ++v)
+        {
+
+            if(!(*v)) continue;
+            // check all nodes and make sure prev is NULL
+            for (auto node = mrrg->function_nodes.begin(); node != mrrg->function_nodes.end(); ++node)
+                (*node)->prev = NULL;
+
+            for (auto node = mrrg->routing_nodes.begin(); node != mrrg->routing_nodes.end(); ++node)
+                (*node)->prev = NULL;
+
+            bool r = routeVal(*v, op);
+            updateOveruse(mrrg);
+            if (!r)
+            {
+                // cout << "Could not route val: \"" << **v << "\". Turn on DEBUG_ROUTING for more info." << endl;
+            }
+            result &= r;
+        }
+    }
+
+    // route output val
+
+
+    return result;
+}
+
+static inline double getcurrenttime()
+{
+    struct timeval t;
+
+    gettimeofday(&t, NULL);
+
+    return t.tv_sec + t.tv_usec * 0.000001;
+}
+
+// This is the main mapping function
+// true on success, false on failure
+Mapping LISAMapper::mapOpGraph(std::shared_ptr<OpGraph> opgraph, int II, std::string arch_model_name)
+
+{
+     for(int i = 0; i< systolic_array_x; i++){
+        for(int j=0; j< systolic_array_y;j++){
+            systolic_pe_index.emplace(std::make_pair(i,j),sys_arr[i][j]);
+        }
+    }
+    arch_model_name_ = arch_model_name;
+
+    for(auto op: opgraph->op_nodes){
+        overuse_counter.emplace(op, 0);
+    }
+
+    // init op_edges
+    {
+        for(auto node: opgraph->op_nodes){
+            if (node->opcode != OPGRAPH_OP_INPUT && node->opcode != OPGRAPH_OP_CONST)
+            {   
+                int node_id = node_to_id_[node];
+                assert(dfg_label_->find(node_id)!= dfg_label_->end());
+                auto & ass_value = dfg_label_->at(node_id).association;
+                for (auto input_value: node->input){
+                    if(input_value == 0) continue;
+                    auto input_node = input_value->input;
+                    int input_node_id = node_to_id_[input_node];
+                    if(node_id ==  input_node_id) continue;
+                    assert(ass_value.find(input_node_id) != ass_value.end());
+                    std::cout<<"add edge"<<input_node->name <<"->"<<node->name<<"\n";
+                    op_edges_.emplace(op_edge{input_node, node, ass_value[input_node_id].second});
+                }
+            }
+        }
+    }
+
+    
+    mapper_start_time  = std::chrono::steady_clock::now();
+    this->II_ = II;
+    opgraph_ = opgraph;
+    MAX_OVERUSE = opgraph->op_nodes.size() * 100;
+    std::cout<<"cgra size ("<<cgra->ROWS<<", "<<cgra->COLS<<")"<<std::endl;
+    // set_edges(opgraph);
+    // find_backedge();
+    std::set<int> node_list;
+    for(auto node: id_to_node_){
+        node_list.insert(node.first);
+    }
+
+    
+    
+    // assert(false);
+    // return NULL;
+    // get the mrrg object
+    MRRG *mrrg = cgra->getMRRG(II).get();
+    mrrg_ = mrrg;
+     if (arch_model_name_.find("systolic") != std::string::npos) {
+        mrrg_->makeSystolicArray(systolic_pe_index, systolic_array_x);
+    }
+
+    
+     if (arch_model_name_.find("leftmostmemory") != std::string::npos) {
+        mrrg_->makeLeftMostMemoryAccess();
+    }
+    
+    for(auto node: mrrg->routing_nodes){
+        occupancy[node] = 0;
+    }
+    for(auto node: mrrg->function_nodes){
+        occupancy[node] = 0;
+    }
+    // Create result obj
+    Mapping mapping_result(cgra, II, opgraph);
+
+    // Set the random seed
+    srand(this->rand_seed);
+
+#ifdef ANNEAL_DEBUG
+    ofstream anneal_debug;
+    anneal_debug.open("anneal_debug.csv");
+#endif
+
+    // Sort the opgraph nodes
+    // TODO: This does not work on graphs with back edges
+    // topological_sort(opgraph);
+
+    cout << "using LISA" << std::endl;
+
+    LOG(LISAGNN) << "Initial placement:" << "\n";
+    // randomized initial placement
+
+    std::vector<OpGraphOp*>  sorted_nodes;
+    for(auto node: opgraph->op_nodes){
+        if(find(sorted_nodes.begin(), sorted_nodes.end(),node) == sorted_nodes.end()){
+            sorted_nodes.push_back(node);
+        }
+    }
+    if(!lisa_eval_routing_priority){
+        std::sort (sorted_nodes.begin(), sorted_nodes.end(), 
+        [&, this](OpGraphOp* a, OpGraphOp* b) {
+            int a_order = dfg_label_->at(node_to_id_[a]).schedule_order;
+            int b_order = dfg_label_->at(node_to_id_[b]).schedule_order;
+            if(a_order!= b_order) return a_order < b_order;
+            int a_id = node_to_id_[a];
+            int b_id = node_to_id_[b];
+            // if(node_children_[a_id].find(b_id) != node_children_[a_id].end()) return true;
+            // if(node_children_[b_id].find(a_id) != node_children_[b_id].end()) return false;
+            return node_asap_[a_id] < node_asap_[b_id]; 
+        });
+    }
+
+    std::vector<OpGraphOp*> sorted_nodes_by_edge;
+    for(auto edge: op_edges_){
+        auto src= edge.src;
+        auto des = edge.des;
+        std::cout<<"edge: "<<src->name<<" -> "<<des->name<<"\n";
+
+        auto src_iter = std::find(sorted_nodes_by_edge.begin(), sorted_nodes_by_edge.end(), src);
+        
+        if (src_iter == sorted_nodes_by_edge.end()){
+            sorted_nodes_by_edge.push_back(src);
+        }
+        auto des_iter = std::find(sorted_nodes_by_edge.begin(), sorted_nodes_by_edge.end(), des);
+            if (des_iter == sorted_nodes_by_edge.end()){
+            sorted_nodes_by_edge.push_back(des);
+        }
+        // std::cout<<"iter:"<< i<<" src:"<<edge.src->name<<" des:"<<edge.des->name<<" route length "<<edge.length<<"\n";
+        // routed = routeVal(edge.src->output, edge.des);
+        //  if(!routed) break;
+    }
+    std::cout<<"sorted nodes: ";
+    for(auto op: sorted_nodes){
+        std::cout<< op->name<<"  ";
+    }
+    std::cout<<"\ntemp_sored_nodes : ";
+    for(auto op: sorted_nodes_by_edge){
+        std::cout<< op->name<<"  ";
+    }
+    assert(sorted_nodes.size() == sorted_nodes_by_edge.size());
+
+
+    std::random_device r;
+    std::default_random_engine e1(r());
+    std::uniform_int_distribution<int> uniform_dist(0, sorted_nodes.size()-1);
+       
+    bool  routed = true; 
+    std::cout<<"sorted nodes\n";
+     for (auto &op : sorted_nodes)
+        {
+            std::cout<< *op<<" id:"<<node_to_id_[op]<< std::endl;
+        }
+    std::map<OpGraphNode*, MRRGNode*>  bestPlacement;
+    int min_cost  = 10000000;
+    for(int i  = 0 ; i < 100 ; i++){
+        routed = true;
+        
+         std::map<OpGraphNode*, MRRGNode*>  currPlacement;
+         if(place_and_routing_parallel){
+            for (auto &op : sorted_nodes)
+            {
+                MRRGNode *fu;
+                if(!lisa_eval_routing_priority){ 
+                     fu = getLISAFU(opgraph, mrrg, op);
+                }else{
+                     fu = getRandomFU(mrrg, op);
+
+                }
+                LOG(LISAFU)<<"iter:"<< i <<" " << *op << " : " << *fu ;
+                bool placed = placeOp(op, fu);
+                currPlacement.emplace(op, fu);
+                
+                assert(placed);
+                routed = routeOpInput(op, mrrg);
+                if(!routed) break;
+            }
+         }else{
+            for (auto &op : sorted_nodes)
+                {
+                    MRRGNode *fu;
+
+                    if(!lisa_eval_routing_priority){ 
+                        fu = getLISAFU(opgraph, mrrg, op);
+                    }else{
+                        fu = getRandomFU(mrrg, op);
+
+                    }
+                    LOG(LISAFU)<<"iter:"<< i <<" " << *op << " : " << *fu <<"\n";
+                    bool placed = placeOp(op, fu);
+                    currPlacement.emplace(op, fu);
+                    
+                    assert(placed);
+                }
+
+                // for (auto &op :sorted_nodes)
+                // {
+                //     routed = routeOp(op, mrrg);
+                    
+                //     if(!routed) break;
+                // }
+               
+                 for (auto &op :sorted_nodes_by_edge)
+                {
+                    routed = routeOp(op, mrrg);
+                    
+                    if(!routed) break;
+                }
+
+         }
+        
+
+        
+
+        if(routed){
+            if(is_training){
+                break;
+            }else{
+                int curr_cost = getCost(mrrg);
+                if(curr_cost < min_cost){
+                    bestPlacement =  currPlacement;
+                    min_cost = curr_cost;
+                }
+            }
+        } 
+        for (auto &op : sorted_nodes)
+        {
+            ripUpOp(op);
+        }
+        
+
+        if( i == 50) {
+            allow_overuse =  true;
+            LOG(LISAGNN) <<"iter:"<< i <<" set overuse\n" ;
+        }
+        
+    }
+    if(!routed) return mapping_result;
+    if(!is_training){
+         for (auto &op : sorted_nodes)
+        {
+            ripUpOp(op);
+        }
+          for (auto &op : sorted_nodes)
+        {
+            placeOp(op, bestPlacement[op]);
+        }
+        for (auto &op :sorted_nodes_by_edge)
+        {
+            routed = routeOp(op, mrrg);
+            
+            assert(routed);
+        }
+    }
+    
+
+    allow_overuse =  false;
+    finish_init = true;
+
+    
+    // Verify initial place and route
+    for (auto &op : opgraph->op_nodes)
+    {
+        if (mapping[op].size() == 0)
+        {
+            cout << "No initial placement for: " << op->name << endl;
+            assert(0);
+        }
+    }
+
+    for (auto &val : opgraph->val_nodes)
+    {
+        if (mapping[val].size() == 0)
+        {
+            cout << "No initial routing for: " << val->name << endl;
+            assert(0);
+        }
+    }
+  
+
+    for (auto &node : mrrg->routing_nodes)
+    {
+        if (occupancy[node] > node->capacity)
+        {
+            
+            LOG(OVERUSE) << *node << " is overused. (" << occupancy[node] << "/" << node->capacity << ")\n";
+            // for(auto mappinged_node: occupancy_detail[node]){
+            //     LOG(OVERUSE) <<"use "<<mappinged_node->name;
+            // }
+            //  LOG(OVERUSE) <<"\n";
+        }
+        
+    }
+    // assert(false);
+    
+    LOG(DUMPMAPPING)<<printMapping()<<"\n";
+    // assert(false);
+    
+
+#ifdef CALCULATE_INITIAL_TEMPERATURE
+    /************************* TRY TO DO 100 iterations before annealing********/
+
+    cout << "Finding delta Costs:" << endl
+         << "INITIAL:" << endl
+         << "OpGraph Cost: " << getCost(opgraph.get()) << endl;
+    cout << "MRRG Cost: " << getCost(mrrg) << endl;
+    cout << "Penalty Factor: " << pfactor << endl;
+
+    float max_delta_cost = 0;
+    float old_cost = getCost(mrrg);
+
+    //  assert(false);
+
+    //do 100x of perturbation
+    int max_try = 100;
+    for (int i = 0; i < 100; i++) 
+    // for (int i = 0; i < 100; i++)
+    {
+        //first get a random index
+        int vector_size = opgraph->op_nodes.size();
+        int index = rand() % vector_size;
+
+        //perturb at this index
+        OpGraphOp *op = opgraph->op_nodes[index];
+
+        //substitute a new fu
+        MRRGNode * old_fu = mapping[op].front();
+        MRRGNode *fu;
+        fu = getRandomFU(mrrg, op);
+    
+        
+
+        if (fu->canMapOp(op))
+        {
+            //check if occupied
+            if (occupancy[fu] == 0)
+            {
+                //move there
+                OpMapping oldmap = ripUpOp(op);
+                bool success = placeOp(op, fu);
+                if (success)
+                    success = routeOp(op, mrrg);
+                if(!success ){
+                    ripUpOp(op);
+                    restoreOp(oldmap);
+                    continue;
+                } 
+
+                //get new cost
+                float new_cost = getCost(mrrg);
+                float change_cost = abs(new_cost - old_cost);
+                if (change_cost > max_delta_cost)
+                    max_delta_cost = change_cost;
+
+                //restore changes
+                ripUpOp(op);
+                restoreOp(oldmap);
+            }
+            else
+            {
+                assert(false);
+            }
+        }
+        else
+        {
+            //cant map, skip
+            i--;
+        }
+    }
+
+    //calculate initial temperature
+    float accept_percentage = 0.99;
+    float natural_log = log(accept_percentage);
+
+    // initial temperature
+    float temperature = (-1) * max_delta_cost / (natural_log);
+    cout << " max delta cost is " << max_delta_cost << endl;
+#else
+    float temperature = 1000000.0;
+#endif
+    cout << "Initial Temperature is " << temperature << endl;
+
+    /************************** Done 100 iterations **************************************/
+
+    cout << "Begin annealing" << endl;
+    bool no_timelimit = (timelimit == 0.0);
+    double start_time = getcurrenttime();
+    double current_time = getcurrenttime();
+
+    float current_cost = getCost(mrrg);
+    while (no_timelimit || (current_time - start_time) < timelimit)
+    {   
+        
+        // dfg_label = lisa_ctl->getCurrLabel();
+        float accept_rate = 0.0;
+        float previous_cost = current_cost;
+        LOG(LISAGNN) << "########################################\n Annealing at:"
+                << "\ttemp: " << temperature
+                << "\tpfactor: " << pfactor
+                << "\tcost:"<<current_cost ;
+        if (inner_place_and_route_loop(opgraph.get(), mrrg, temperature, &accept_rate))
+        {
+            mapping_result.setMapping(mapping);
+            LOG(LISAGNN) << "MappingTime: " << (int)(getcurrenttime() - start_time);
+            LOG(LISAGNN) << "MapperTimeout: 0";
+            LOG(LISAGNN) << "Mapped: 1";
+            mapping_result.setMapped(true);
+              if(is_training){
+                    current_cost = getCost(mrrg);
+                    optimizeMapping(opgraph.get(), mrrg);
+                    std::cout<<"lisa training optimize mapping cost from "<<current_cost << " to "<<getCost(mrrg)<<"\n";
+                }
+            return mapping_result;
+        }
+        current_cost = getCost(mrrg);
+
+        LOG(LISAGNN) << "aftter SA -> temp:"<<temperature << ","
+        << "cost:"<<current_cost << ","
+        << pfactor << ","
+        << "\n";
+        // TODO: Changed from 0.01
+        //if(temperature  < 0.001 * mrrg->getCost(pfactor) / mrrg->routing_nodes.size())
+        if (accept_rate < cold_accept_rate && current_cost >= previous_cost)
+        {
+#ifdef ANNEAL_DEBUG
+            anneal_debug.close();
+#endif
+            LOG(LISAGNN) << "Mapper is Cold and no valid mapping was found."<<
+            "Current Temperature acceptance rate was: " << accept_rate
+            << "Cold acceptance rate is: " << cold_accept_rate
+            << "Current Cost is: " << current_cost
+            << "Previous  Cost was: " << previous_cost
+            << "Mapped: 0";
+            return mapping_result;
+        }
+        LOG(LISAGNN) << "mrrg cost: " << getCost(mrrg)
+        << " mrrg size: " << mrrg->routing_nodes.size()
+        << " update temp. & pfactor";
+        // update temperature
+#ifdef SIMPLE_ANNEAL_SCHEDULE
+        temperature = updateTempConst(temperature);
+#else
+        temperature = updateTemperature(temperature, (float)total_accepted / total_tries);
+#endif
+        // update overuse penalty
+        pfactor = pfactor * pfactor_factor;
+
+        current_time = getcurrenttime();
+
+        LOG(LISAGNN) << "current run time: " << (int)(current_time - start_time);
+
+    }
+  
+    cout << "MapperTimeout: 1" << endl;
+    cout << "Mapped: 0" << endl;
+
+    return mapping_result;
+}
+bool LISAMapper::optimizeMapping(OpGraph *opgraph, MRRG *mrrg){
+    int num_swaps = 1000;
+    int total_accepted = 0;
+    for (int i = 0; i < num_swaps; i++)
+    {
+        // Get an op
+        OpGraphOp *op = opgraph->op_nodes[rand() % opgraph->op_nodes.size()];
+
+        // Get an fu
+        MRRGNode *old_fu = mapping[op].front();
+        // MRRGNode *fu = getRandomFU(mrrg, op);
+        //shared_ptr<OpGraph > my_ptr(opgraph);
+        MRRGNode *fu;
+        fu = getCloseRandomFU( mrrg, op, old_fu, 2, 2);
+           
+         
+        // std::cout<<" old fu "<<old_fu->getFullName()<<" new fu: "<<fu->getFullName()<<"\n";
+        // make sure that it is a different FU
+        if (fu == getMappedMRRGNode(op))
+            continue;
+
+        //find the cost of this selected op
+        float old_cost = getCost(mrrg); //getTotalOpCost(op);
+        
+        if (fu->canMapOp(op))
+        {
+            //check if occupied
+            if (occupancy[fu] == 0)
+            {
+                //move there
+                OpMapping oldmap = ripUpOp(op);
+                bool success = placeOp(op, fu);
+                if (!success)
+                {
+                    cout << "Could not place OP" << endl;
+                }
+
+                if (success)
+                {
+                    success = routeOp(op, mrrg);
+                    if (!success)
+                    {
+                        // cout << "Could not route OP. It is likely that there is a disconnect in the architecture." << endl;
+                        // assert(success);
+                        ripUpOp(op);
+                        restoreOp(oldmap);
+                        continue;
+                    }
+                }
+
+                //get new cost
+                float new_cost_x = getCost(mrrg); // getTotalOpCost(op);
+                float delta_cost = new_cost_x - old_cost;
+
+                if (accept(delta_cost, 0))
+                {
+                    total_accepted++;
+                }
+                else
+                {
+                    //restore changes
+                    ripUpOp(op);
+                    restoreOp(oldmap);
+                }
+            }
+            else // there must only be one unit mapped here
+            {
+                assert(false);
+            }
+        }
+    }
+     bool mrrg_overuse = checkOveruse(mrrg);
+     assert(mrrg_overuse);
+    return true;
+
+    
+
+}
+
+bool LISAMapper::inner_place_and_route_loop(OpGraph *opgraph, MRRG *mrrg, float temperature, float *accept_rate)
+{
+    std::cout<<"swap_factor:"<<swap_factor<<"\n";
+    int num_swaps = swap_factor ;
+    if(is_training) num_swaps = swap_factor  ;
+    int total_accepted = 0;
+    int total_tries = 0;
+
+    for (int i = 0; i < num_swaps; i++)
+    {
+        if(is_training){
+             auto end = std::chrono::steady_clock::now();
+            std::chrono::duration<double> elapsed_seconds = end-mapper_start_time;
+            int used_second =   elapsed_seconds.count() ;
+            if(used_second > 3600* 3) return false;
+        }
+       
+        // Get an op
+        int node_max_overuse = 0, node_min_overuse = 99999999;
+        // std::cout<<"overuse counter:";
+        for(auto overuse_pair: overuse_counter){
+            node_max_overuse = std::max(node_max_overuse, overuse_pair.second);
+            node_min_overuse = std::min(node_min_overuse, overuse_pair.second);
+            // std::cout<<overuse_pair.first->name<<", "<<overuse_pair.second<<"  ";
+        }
+        int overuse_diff = node_max_overuse - node_min_overuse;
+        // std::cout<<"\n";
+
+        std::random_device rd{};
+        std::mt19937 gen{rd()};
+        std::normal_distribution<> d{0,3};
+        int selected_id = std::abs(std::round(d(gen)));
+        auto op_sort_by_overuse = opgraph->op_nodes;
+        std::sort(op_sort_by_overuse.begin(), op_sort_by_overuse.end(),[&](OpGraphOp * a, OpGraphOp * b){
+                return overuse_counter[a] > overuse_counter[ b];});
+        // if(selected_cost > max_diff)  selected_cost = max_diff;
+        // selected_cost  = min_cost + selected_cost;
+        // Generator g(0, 1000, -overuse_diff, overuse_diff);
+        // std::cout<<"selected overuse number "<<selected_id<<"\n";
+        if(selected_id >=  op_sort_by_overuse.size()) selected_id =   op_sort_by_overuse.size() - 1;
+        // std::cout<<"selected op"<<op_sort_by_overuse[selected_id]->name<<"\n";
+
+
+        // OpGraphOp *op = opgraph->op_nodes[rand() % opgraph->op_nodes.size()];
+        OpGraphOp *op ;
+        // if(is_training){
+            op = opgraph->op_nodes[rand() % opgraph->op_nodes.size()];
+        // }else{
+            // op = op_sort_by_overuse[selected_id];
+        // }
+        // Get an fu
+        MRRGNode *old_fu = mapping[op].front();
+        // MRRGNode *fu = getRandomFU(mrrg, op);
+        //shared_ptr<OpGraph > my_ptr(opgraph);
+        MRRGNode *fu;
+        if (is_training){
+            fu = getCloseRandomFU( mrrg, op, old_fu);
+           
+        }else  if(lisa_eval_routing_priority){ 
+            fu = getRandomFU(mrrg, op);
+        }else{
+            // fu = getCloseRandomFU( mrrg, op, old_fu,1 ,1);
+           fu = getLISAFU(opgraph_, mrrg, op, total_accepted, total_tries, num_swaps);
+        }
+         
+        // std::cout<<" old fu "<<old_fu->getFullName()<<" new fu: "<<fu->getFullName()<<"\n";
+        // make sure that it is a different FU
+        if (fu == getMappedMRRGNode(op))
+            continue;
+
+        //find the cost of this selected op
+        float old_cost = getCost(mrrg); //getTotalOpCost(op);
+        
+        if (fu->canMapOp(op))
+        {
+            // This is an actual attempt to swap
+            total_tries++;
+
+            //check if occupied
+            if (occupancy[fu] == 0)
+            {
+                //move there
+                OpMapping oldmap = ripUpOp(op);
+                bool success = placeOp(op, fu);
+                if (!success)
+                {
+                    cout << "Could not place OP" << endl;
+                }
+
+                if (success)
+                {
+                    success = routeOp(op, mrrg);
+                    if (!success)
+                    {
+                        // cout << "Could not route OP. It is likely that there is a disconnect in the architecture." << endl;
+                        // assert(success);
+                        ripUpOp(op);
+                        restoreOp(oldmap);
+                        continue;
+                    }
+                }
+
+                //get new cost
+                float new_cost_x = getCost(mrrg); // getTotalOpCost(op);
+                float delta_cost = new_cost_x - old_cost;
+
+                if (accept(delta_cost, temperature))
+                {
+                    total_accepted++;
+                }
+                else
+                {
+                    //restore changes
+                    ripUpOp(op);
+                    restoreOp(oldmap);
+                }
+            }
+            else // there must only be one unit mapped here
+            {
+#ifndef ALLOW_MULTIPLE_PLACEMENT
+                assert(fu->occupancy == 1);
+#endif
+
+                //swap, rip off two nodes?
+                //first find the op node corresponding to this mrrg node
+                OpGraphOp *second_op = getOpNodePtr(opgraph, fu);
+
+                //keep track of op's MRRG Node
+                MRRGNode *first_MRRGNode = getMappedMRRGNode(op);
+
+                //swap these two nodes
+                OpMapping oldmap_x = ripUpOp(op);
+                OpMapping oldmap_y = ripUpOp(second_op);
+
+                bool success_x = placeOp(op, fu);
+                bool success_y = placeOp(second_op, first_MRRGNode);
+
+                //route
+                if (success_x)
+                {
+                    bool routed = routeOp(op, mrrg);
+                    assert(routed);
+                }
+
+                if (success_y)
+                {
+                    bool routed = routeOp(second_op, mrrg);
+                    assert(routed);
+                }
+
+                float new_cost = getCost(mrrg);
+                float delta_cost = new_cost - old_cost;
+                if (accept(delta_cost, temperature))
+                {
+                    total_accepted++;
+                }
+                else //restore the opgraph
+                {
+                    ripUpOp(op);
+                    ripUpOp(second_op);
+                    restoreOp(oldmap_x);
+                    restoreOp(oldmap_y);
+                }
+            }
+        }
+    }
+
+    
+
+    bool mrrg_overuse = checkOveruse(mrrg);
+    float opgraph_cost = getCost(opgraph);
+
+     LOG(DUMPMAPPING)<<printMapping()<<"\n";
+
+    if (!mrrg_overuse)
+    {
+        cout << "MRRG OVERUSED!" << endl;
+    }
+    else
+    {
+        cout << "MRRG NOT OVERUSED!" << endl;
+    }
+
+    if (mrrg_overuse && opgraph_cost < INFINITY)
+    {
+        cout << "mrrg cost: " << getCost(mrrg) << endl;
+        cout << "mrrg size: " << mrrg->routing_nodes.size() << endl;
+        cout << "temp: " << temperature << endl;
+        cout << "pfactor: " << pfactor << endl;
+        *accept_rate = (float)total_accepted / (float)total_tries;
+        return true;
+    }
+    *accept_rate = (float)total_accepted / (float)total_tries;
+    return false;
+}
+
+
+ std::vector<std::pair<MRRGNode *, int>> LISAMapper::candidate_fu_intersect(std::vector<std::pair<MRRGNode *, int>> v1, std::vector<std::pair<MRRGNode *, int>> v2)
+    {
+        std::vector<std::pair<MRRGNode *, int>> result;
+
+        for (auto &p : v1)
+        {
+            for (auto &n : v2)
+            {
+                if (p.first == n.first)
+                    result.push_back({p.first, p.second + n.second});
+            }
+        }
+
+        return result;
+    }
+
+    // This topological sort algorithm uses a depth first search
+    // NB: The graph MUST be acyclic, else explosions may happen...
+    void LISAMapper::topological_sort(OpGraph *g)
+    {
+        std::vector<OpGraphOp *> L;
+
+        // Unmark all nodes
+        std::map<OpGraphOp *, bool> mark;
+        for (auto &n : g->op_nodes)
+        {
+            mark[n] = false;
+        }
+
+        OpGraphOp *n;
+        while ((n = topological_sort_check_marked(g->op_nodes, &mark)))
+        {
+            topological_sort_visit(&L, &mark, n);
+        }
+
+        g->op_nodes = L;
+    }
+    /*
+bool test_compare(float penalty_factor, MRRGNode* a, MRRGNode* b)
+{
+    return getCost(a) < getCost(b);
+}
+
+bool compare_op_cost(float penalty_factor, OpGraphOp* a, OpGraphOp* b)
+{
+    return a->getCost(penalty_factor) > b->getCost(penalty_factor);
+}
+*/
+    float LISAMapper::updateTemperature(float t, float acceptance_rate)
+    {
+        if (acceptance_rate > 0.96)
+        {
+            return t * 0.5;
+        }
+        else if (acceptance_rate > 0.8)
+        {
+            return t * 0.9;
+        }
+        else if (acceptance_rate > 0.15)
+        {
+            return t * 0.98;
+        }
+        else
+        {
+            return t * 0.95;
+        }
+    }
+
+    // generate a random FU
+    MRRGNode *  LISAMapper::getRandomFU(MRRG *mrrg, OpGraphOp *op)
+    {
+        std::vector<MRRGNode *> candidates;
+        for (auto &fu : mrrg->function_nodes)
+        {
+            if (fu->canMapOp(op) && occupancy[fu] == 0)
+            {
+                candidates.push_back(fu);
+            }
+        }
+
+        if (candidates.size() < 1)
+        {
+            cout << "Could not place: " << *op << endl;
+            assert(candidates.size() > 0);
+        }
+
+        std::random_device r;
+        std::default_random_engine e1(r());
+        std::uniform_int_distribution<int> uniform_dist(0, candidates.size()-1);
+        int mean = uniform_dist(e1);
+
+        return candidates[mean];
+    }
+
+    MRRGNode *  LISAMapper::getCloseRandomFU(MRRG *mrrg, OpGraphOp *op, MRRGNode * old_fu, int max_physical_dis ,  int max_temp_dis )
+    {
+        std::vector<MRRGNode *> opt_candidates;
+        std::vector<MRRGNode *> all_candidates;
+
+        int old_cycle = old_fu->cycle;
+        std::set<int> allowed_cycle ;
+        for(int start_cycle = old_cycle - max_temp_dis ; start_cycle <= old_cycle + max_temp_dis;start_cycle ++ ){
+            allowed_cycle.insert( (start_cycle + II_)%II_);
+        }
+
+        LOG(RANDOMFU)<<"select CloseRandomFU for op"<<op->name<<" old fu"<<old_fu->getFullName();
+        // assert(false);
+        for (auto &fu : mrrg->function_nodes)
+        {
+            mpos mmmm{fu->x_, fu->y_, fu->cycle};
+            bool exist = false;
+            for(auto m :  mapped_pos){
+                if(m.x == mmmm.x && mmmm.y == m.y  && mmmm.t == m.t){
+                    exist = true;
+                    break;
+                }
+            }
+            if (fu->canMapOp(op) && occupancy[fu] == 0 )
+            {
+                all_candidates.push_back(fu);
+                if(  std::abs(old_fu->x_ - fu->x_) + std::abs(old_fu->y_ - fu->y_) <= max_physical_dis  
+                 && allowed_cycle.find(fu->cycle)!= allowed_cycle.end()){
+                     opt_candidates.push_back(fu);
+                 }
+            }
+        }
+        if (all_candidates.size() < 1)
+        {
+            cout << "Could not place: " << *op << endl;
+            assert(all_candidates.size() > 0);
+        }
+        std::random_device r;
+        std::default_random_engine e1(r());
+       
+        if(opt_candidates.size() == 0){
+            auto cal_dist = [](MRRGNode * old_fu, MRRGNode * new_fu){
+                return std::abs(old_fu->x_ - new_fu->x_) + std::abs(old_fu->y_ - new_fu->y_) + std::abs(int(old_fu->cycle) - int(new_fu->cycle) );
+            };
+            std::sort(all_candidates.begin(), all_candidates.end(), [&](MRRGNode * a, MRRGNode * b){
+                return cal_dist(old_fu, a) < cal_dist(old_fu, b);
+            });
+            std::uniform_int_distribution<int> uniform_dist(0, all_candidates.size()-1);
+            int mean = uniform_dist(e1);
+            auto sel_fu = all_candidates[mean];
+            LOG(RANDOMFU)<<"  select fu:"<<sel_fu->getFullName();
+            return sel_fu;
+        }
+        
+        std::uniform_int_distribution<int> uniform_dist(0, opt_candidates.size()-1);
+        int mean = uniform_dist(e1);
+        auto sel_fu = opt_candidates[mean];
+        LOG(RANDOMFU)<<"  select fu:"<<sel_fu->getFullName();
+        return sel_fu;
+        
+    }
+   
+
+    template <typename type>
+    std::vector<type> LISAMapper::vector_intersect(std::vector<type> v1, std::vector<type> v2)
+    {
+        std::sort(v1.begin(), v1.end());
+        std::sort(v2.begin(), v2.end());
+
+        std::vector<type> v_intersection;
+
+        std::set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), std::back_inserter(v_intersection));
+
+        return v_intersection;
+    }
+
+    std::vector<MRRGNode *> LISAMapper::filterCanMapOp(std::vector<MRRGNode *> fus, OpGraphOp const *op)
+    {
+        std::vector<MRRGNode *> result;
+        for (auto &f : fus)
+        {
+            if (f->canMapOp(op))
+            {
+                result.push_back(f);
+            }
+        }
+
+        return result;
+    }
+
+
+
+    // from herr, that is the new thingd that lisa added.
+
+    std::map<int, pos3d> LISAMapper::dumpMapping(std::shared_ptr<OpGraph> opgraph,  int &max_latency){
+
+        std::map<int, pos3d> dumpmapping;
+        max_latency = 0;
+        
+       
+        
+        auto sorted_nodes = opgraph->op_nodes;
+        std::sort (sorted_nodes.begin(), sorted_nodes.end(), 
+        [&, this](OpGraphOp* a, OpGraphOp* b) {return node_asap_ [node_to_id_[a]] < node_asap_ [node_to_id_[b]]; 
+        });
+        LOG(CMAP)<<"*******dump mapping\n";
+        for(auto node: sorted_nodes){
+            if(mapping.find(node) == mapping.end() || mapping[node].size() == 0){
+                continue;
+            }
+            auto m = mapping[node];
+             LOG(CMAP)<<"node name:"<<node->name;
+            if(dynamic_cast<OpGraphVal*>(node)) continue;
+            auto node_op = dynamic_cast<OpGraphOp*>(node);
+            assert(node_op);
+            auto mrrg_node = m.front();
+            LOG(CMAP)<<" mrrg_node:"<<mrrg_node->x_<<" "<<mrrg_node->y_<<" "<<mrrg_node->cycle;
+            int input_max_lat = 0;
+            for(auto val:  node_op->input){
+                if(!val) continue; // remove backtrack edge, as the cgra-me does not support keeping data into register.
+                int index = 0;
+                bool find_input = false;
+                for(auto output: val->output){
+                   if(output == node ){
+                    //    std::vector<OpGraphOp*> trans_input_op ;
+                    //    for(auto trans_input_value : output->input){
+                    //        if(!trans_input_value) continue;
+                    //        trans_input_op.push_back(trans_input_value->input);
+                    //    }
+                    //    if(std::find(trans_input_op.begin(), trans_input_op.end(), node_op)==trans_input_op.end()) {
+                            find_input = true;
+                            break;
+                    //    }
+                       
+                   }
+                   index ++;
+                }
+
+                // for(int i = 0; i <  val->output.size(); i++){
+                //     LOG(CMAP)<<"output node "<<i<<" "<<(val->output)[i]->name<< " latency: "<<(val->output_latency)[i];
+                // }
+                LOG(CMAP)<<"( input val "<<val->name<<" output size"<<val->output.size()<<" output latency size"<<val->output_latency.size();
+                auto input_op = val->input;
+                LOG(CMAP)<<" input_op name:"<<input_op->name<<" ";
+                LOG(CMAP)<<dumpmapping[node_to_id_[input_op]].toStr();
+                int lat = dumpmapping[node_to_id_[input_op]].t;
+                LOG(CMAP)<<" lat:"<<lat<<")\n";
+                input_max_lat = std::max(lat, input_max_lat);
+                if(find_input  ){
+                    
+                    if(val->output_latency.size() == 0) continue;
+                    if(dumpmapping.find(node_to_id_[input_op]) == dumpmapping.end()) continue;
+                    LOG(CMAP)<<" output_latency:"<<(val->output_latency)[index]<<"\n";
+
+                    int route_lat = (val->output_latency)[index];
+                     //cgra-me did not add latency for function unit. Below code is for this bug.
+                     auto op_code = val->input->opcode;
+                    //  if(lat_opcode.find(op_code) != lat_opcode.end()){
+                    //      route_lat += 1;
+                    //  }
+                     lat += route_lat;
+                }
+                LOG(CMAP)<<" lat:"<<lat<<")\n";
+                input_max_lat = std::max(lat, input_max_lat);
+            }
+            // FIXME: is this right?
+            int cycle = int((input_max_lat+1)/II_);
+            int final_lat = cycle * II_ + mrrg_node->cycle;
+            while(final_lat < input_max_lat){
+                final_lat += II_; // due to cgra_me design bugs (cannot get output latency), it has a very low chance to get wrong latecny.
+            }
+            LOG(CMAP)<<" max lat"<<input_max_lat<<" final_lat:"<<final_lat<<"\n";
+            dumpmapping[node_to_id_[node_op]]=pos3d{mrrg_node->x_, mrrg_node->y_, final_lat};
+            LOG(CMAP)<<"final pos"<<dumpmapping[node_to_id_[node_op]].toStr()<<"\n";
+        }
+        // std::cout<<"finish";
+
+        // max latency
+        for(auto m: dumpmapping){
+            int lat = m.second.t;
+            max_latency = lat >  max_latency? lat: max_latency;
+                // std::cout<<" value:"<<val->name<<" latency"<<lat<<std::endl;
+        }
+        max_latency = max_latency + 1;
+        // std::cout<<"max latency"<<max_latency<<std::endl;
+
+
+     
+        // std::cout<<"dumpmapping2 "<<dumpmapping.size()<<"\n";
+        return dumpmapping;
+    }   
+
+    MRRGNode *  LISAMapper::getLISAFU(std::shared_ptr<OpGraph> opgraph,MRRG *mrrg, OpGraphOp *op, int accpepted, int total_tried, int num_swap){
+        auto & op_label = dfg_label_->at(node_to_id_[op]);
+
+        std::set<OpGraphOp*> mapped_node;
+        int temp_max_lat;// not usefule, just for call dumpMapping;
+        auto dumped_mapping = dumpMapping(opgraph, temp_max_lat);
+        // we should calculate based on mapped node
+        for(auto node: node_to_id_){
+            if(mapping[node.first].size()!= 0){
+                mapped_node.insert(node.first);
+            }
+        }
+
+        if(mapped_node.size() == 0){
+            //should select fu that II is 1
+            auto candidates = getDesiredFu(mrrg, 0 , 0, op);
+            std::random_device r;
+            std::default_random_engine e1(r());
+            std::uniform_int_distribution<int> uniform_dist(0, candidates.size()-1);
+            int mean = uniform_dist(e1);
+
+            return candidates[mean];
+        }       
+
+        std::vector<MRRGNode *> candidates;
+        for (auto &fu : mrrg->function_nodes)
+        {
+            mpos mmmm{fu->x_, fu->y_, fu->cycle};
+            bool exist = false;
+            for(auto m :  mapped_pos){
+                if(m.x == mmmm.x && mmmm.y == m.y  && mmmm.t == m.t){
+                    exist = true;
+                    break;
+                }
+            }
+            if (fu->canMapOp(op) && occupancy[fu] == 0 )
+            {
+                candidates.push_back(fu);
+            }
+        }
+
+        // How to select FUs according to labels is a critical question. 
+        //Give up this one: Let us use schedule order to filter some FUs, then we can use communication and association to select FU.
+        // Trying make sure the node is scheduled as soon as possible, as long it satisifes schedule order constraints.
+        // TODO: make every node as soon as  possible might be not accurate, check how to improve this. Maybe we can check data routing somehow.
+        // 
+        
+        int schedule_order =   op_label.schedule_order;
+        auto interval = getIntervalByScheduleOrder(opgraph, dumped_mapping, op, schedule_order);
+         // if we only use label in initial mapping, then the second value is not useful
+        int early_II =  interval.first;
+        int start_II = 0;
+        if(early_II +1 == II_) {
+            start_II = 0;
+        }else{
+            start_II = early_II +1;
+        }
+        //  this sort is not used
+        // std::sort(candidates.begin(), candidates.end(),[&](MRRGNode * a, MRRGNode * b){
+        //     int a_t= a->cycle, b_t = b->cycle;
+        //     if(a_t >= start_II && b_t >= start_II){
+        //         return a_t < b_t;
+        //     }else if(a_t <= start_II && b_t <= start_II){
+        //         return a_t < b_t;
+        //     }else{
+        //         return a_t > b_t;
+        //     }
+        // });
+        // std::cout<<"candidats size "<<candidates.size()<<"\n";
+       
+        assert(candidates.size() > 0);
+        std::map<MRRGNode *, int> comm_cost;
+        // if(!finish_init){
+        //     getCostByComm(mrrg,opgraph, dumped_mapping, candidates, op );
+        // }else{
+        for(auto candi: candidates){
+            comm_cost.emplace(candi,0);
+        }
+        // }
+        
+        auto samelevel_node_cost=  getCostForSameLevelNode(opgraph, dumped_mapping, candidates, op );
+        auto ass_cost = getCostByAssociation(opgraph, dumped_mapping, candidates, op, start_II);
+        
+        std::stringstream output;
+
+         //timing cost: this is to evaluate that whether we can route data in next iteration(for cgra_me only, 
+         //for other frameworks, we need to add  simlar function but specfic to framework).
+         // if not, we need to add cost for this.
+        std::map<MRRGNode*, int> timing_cost ;
+        auto & ass = dfg_label_->at(node_to_id_[op]).association;
+        for(auto node: candidates){
+            int ii_value = node->cycle;
+            int t_cost = 0;
+            for(auto node_ass: ass){
+                int node_id = node_ass.first;
+                if(dumped_mapping.find(node_id) == dumped_mapping.end()) continue;
+                auto & m = dumped_mapping[node_id];
+                int spatial_diff =  (std::abs(node->x_ - m.x) + std::abs(node->y_ - m.y));
+                int tempoal_diff = MOD(m.t - ii_value);
+                if(spatial_diff > tempoal_diff){
+                    t_cost += spatial_diff - tempoal_diff ;
+                }
+                
+            }
+            timing_cost.emplace(node, t_cost);
+        }
+        output<<"early II: "<<early_II<<"\n";
+        output<<"start II: "<<start_II<<"\n";
+        output<<"\n\ttiming cost:";
+        for(auto node: timing_cost){
+            output<<"("<<node.first->getFullName()<<","<<node.second<<") ";
+        }
+
+        output<<"\n\tassociation cost:";
+        for(auto node: ass_cost){
+            output<<"("<<node.first->getFullName()<<","<<node.second<<") ";
+        }
+        output<<"\n\tcommunication cost:";
+        for(auto node: comm_cost){
+            output<<"("<<node.first->getFullName()<<","<<node.second<<") ";
+        }
+
+         output<<"\n\tstart_node_cost cost:";
+        for(auto node: samelevel_node_cost){
+            output<<"("<<node.first->getFullName()<<","<<node.second<<") ";
+        }
+        
+       
+
+
+        std::map<MRRGNode *, int> node_cost ;
+        for(auto node : candidates){
+            int cost = timing_cost[node]  + ass_cost[node] + samelevel_node_cost[node] ;
+            node_cost.emplace(node, cost);
+        }
+
+        output<<"\n\t total cost:";
+        for(auto node: node_cost){
+            output<<"("<<node.first->getFullName()<<","<<node.second<<") ";
+        }
+        
+        std::sort(candidates.begin(), candidates.end(), [&](MRRGNode * a, MRRGNode * b){
+            return node_cost[a] < node_cost[b];
+        });
+
+        
+        int min_cost = node_cost[candidates.front()];
+        int max_cost = node_cost[candidates.back()];
+        int max_diff = max_cost -  min_cost;
+
+        std::random_device rd{};
+        std::mt19937 gen{rd()};
+        double deviation = 1;
+        // std::cout<<"1,2,3:"<<accpepted<<","<<total_tried<<","<<num_swap<<"\n";
+        if(total_tried > 0){
+            deviation = 0.1 * total_tried - accpepted;
+            deviation = std::max(deviation, 1.0);
+                
+        }
+       
+        std::normal_distribution<> d{0,deviation};
+        int selected_cost = std::abs(std::round(d(gen)));
+        if(selected_cost > max_diff)  selected_cost = max_diff;
+        selected_cost  = min_cost + selected_cost;
+
+        if(!finish_init) selected_cost = min_cost;
+
+        // 
+        std::vector<MRRGNode *> suitable_candidates;
+        while(suitable_candidates.size() == 0){
+            for(auto c : node_cost){
+                if(c.second == selected_cost){
+                    suitable_candidates.push_back(c.first);
+                }
+            }
+            selected_cost --;
+        }
+        
+        // std::cout<<"min_candidates size:"<<min_candidates.size()<<"\n";
+        std::random_device r;
+        std::default_random_engine e1(r());
+        std::uniform_int_distribution<int> uniform_dist(0, suitable_candidates.size()-1);
+        int mean = uniform_dist(e1);
+        auto selected_fu = suitable_candidates[mean];
+
+
+        if(!is_training){
+            LOG(LISAFU)<<"curr mapping: "<<printMapping();
+            LOG(LISAFU)<<"label of "<<*op<<"  " <<op_label.toStr();
+            LOG(DLABEL)<<output.str();
+            LOG(LISAFU)<<"best mapping: "<<lisa_ctrl->bestMappingToStr();
+            LOG(LISAFU)<<" min cost:"<< min_cost<<"   selected cost: "<<selected_cost +1 <<"\n";
+            LOG(LISAFU)<<"lisa op:"<<op->name<<" selectFU: "<<selected_fu->getFullName()<<"\n";
+        }
+
+       
+        
+        return selected_fu;
+
+    } 
+    std::map<MRRGNode *, int> LISAMapper::getCostByComm(MRRG *mrrg, std::shared_ptr<OpGraph> opgraph, std::map<int, pos3d> & dumped_mapping, std::vector<MRRGNode *> candidates, OpGraphOp *op ){
+        /*
+        0,0     0,1     1,0     1,1
+        #       #       #       #
+        *       *       used    #
+        #       candi   #       #
+        *       used    *       #
+        # and * means emprt one, while * means routing resource.
+        the number of routing resource should be 4
+        */
+         
+         auto find_routing_resource_ = [&](MRRGNode * a , bool up_directoin){
+            int curr_cycle = a->cycle;
+            std::set<MRRGNode * > overall_routing_resource;
+            std::set<MRRGNode * > curr_routing_resource;
+            curr_routing_resource.insert(a);
+            while(true){
+                std::set<MRRGNode * > new_node;
+                if(curr_routing_resource.size() ==  0){
+                    break;
+                }
+
+                //check whether blocked
+                bool path_blocked = false;
+                for(auto node: curr_routing_resource){
+                    int x = node->x_, y = node->y_;
+                    int blocked_side = 0;
+                    if(x-1 < 0)  blocked_side ++;
+                    if(x+1 >= cgra_x_)  blocked_side ++;
+                    if(y-1 < 0)  blocked_side ++;
+                    if(y+1 >= cgra_y_)  blocked_side ++;
+                    if( blocked_side >= 2) {
+                        break;
+                        path_blocked = true;
+                    }    
+
+                }
+                if(path_blocked){
+                    break;
+                }
+
+                curr_cycle = MOD(curr_cycle);
+                int next_cycle ;
+                if(up_directoin) {next_cycle = curr_cycle - 1;}  else {next_cycle = curr_cycle + 1 ;}
+                next_cycle = MOD(next_cycle);
+
+                for(auto node: curr_routing_resource){
+                    if( node->cycle == curr_cycle){
+                        //find the nieghbors
+                        int x = node->x_, y = node->y_;
+                        auto temp_node = getRoutingNode(mrrg, x-1, y, next_cycle); if(temp_node && occupancy[temp_node] == 0) new_node.insert(temp_node);
+                        temp_node = getRoutingNode(mrrg, x+1, y, next_cycle); if(temp_node && occupancy[temp_node] == 0) new_node.insert(temp_node);
+                        temp_node = getRoutingNode(mrrg, x, y-1, next_cycle); if(temp_node && occupancy[temp_node] == 0) new_node.insert(temp_node);
+                        temp_node = getRoutingNode(mrrg, x, y+1, next_cycle); if(temp_node && occupancy[temp_node] == 0) new_node.insert(temp_node);
+                    }
+                }
+                curr_routing_resource.clear();
+                for(auto node: new_node){
+                    if(overall_routing_resource.find(node) == overall_routing_resource.end()){
+                        curr_routing_resource.insert(node);
+                        overall_routing_resource.insert(node);
+                    }
+                   
+                }
+                if(up_directoin) {curr_cycle --;}  else {curr_cycle ++ ;}
+                
+            }
+            return overall_routing_resource;
+        };
+
+        std::map<MRRGNode *, int> candi_routing_resource_num;
+        for(auto candi : candidates){
+            auto up_routing_resource = find_routing_resource_(candi, true);
+            auto down_routing_resource = find_routing_resource_(candi, false);
+            std::set<MRRGNode *> overall_routing_resource;
+            for(auto r :  up_routing_resource){
+                overall_routing_resource.insert(r);
+            }
+            for(auto r :  down_routing_resource){
+                overall_routing_resource.insert(r);
+            }
+            candi_routing_resource_num[candi] =  overall_routing_resource.size();
+        }
+        return candi_routing_resource_num;
+    }
+
+
+
+    MRRGNode* LISAMapper::getRoutingNode(MRRG *mrrg, int x, int y, int t){
+        for(auto node: mrrg->routing_nodes){
+            if(node->x_ == x && node->y_ == y  && node->cycle == t && node->latency == 1){
+                return node;
+            }
+        }
+        return NULL;
+    }
+
+    std::map<MRRGNode *, int>   LISAMapper::getCostByAssociation
+    (std::shared_ptr<OpGraph> opgraph, std::map<int, pos3d> & dumped_mapping, std::vector<MRRGNode *> candidates, OpGraphOp *op ,  int start_II){
+        auto & ass = dfg_label_->at(node_to_id_[op]).association;
+        int earliest_execution_time = 0;
+        int op_id = node_to_id_[op];
+        for(auto e: lisa_edges_){
+            if(e.second == op_id){
+                int temp_time = dumped_mapping[e.first].t;
+                earliest_execution_time = std::max(earliest_execution_time, temp_time);
+            }
+        }
+        int earliest_execution_time_II = MOD(earliest_execution_time);
+
+    
+        auto get_cost = [&, this ](MRRGNode * a) {
+            int mrrgnode_II =  a->cycle;
+            int total_spatial_cost = 0, total_temp_cost = 0;
+            int guess_time = 0;
+
+            if(mrrgnode_II < earliest_execution_time_II){ 
+                guess_time = earliest_execution_time + ( mrrgnode_II + II_) - earliest_execution_time_II;
+            }else{
+                guess_time = earliest_execution_time + mrrgnode_II + - earliest_execution_time_II;
+            }
+            int mapped_ass_node = 0;
+            for(auto node_ass: ass){
+                int node_id = node_ass.first;
+                if(dumped_mapping.find(node_id) == dumped_mapping.end()) continue;
+                mapped_ass_node++;
+                auto & m = dumped_mapping[node_id];
+                total_spatial_cost += std::abs(std::abs(node_ass.second.first) - (std::abs(a->x_ - m.x) + std::abs(a->y_ - m.y)));
+                total_temp_cost += std::abs(m.t - guess_time);
+                
+            }
+            if(mapped_ass_node == 0) return std::make_pair(0,0);
+            return std::make_pair(int(total_spatial_cost/mapped_ass_node), int(total_temp_cost/mapped_ass_node));
+        };
+
+        std::map<MRRGNode *, int> candi_ass_cost;
+        for(auto candi: candidates){
+            auto cost = get_cost(candi);
+            candi_ass_cost.emplace(candi, cost.first + cost.second);
+        }
+
+        return candi_ass_cost;
+    }
+
+
+    std::map<MRRGNode *, int> LISAMapper::getCostForSameLevelNode
+    (std::shared_ptr<OpGraph> opgraph, std::map<int, pos3d> & dumped_mapping, std::vector<MRRGNode *> candidates, OpGraphOp *op ){
+        int node_id = node_to_id_[op];
+        std::map<MRRGNode *, int> node_cost;
+         for(auto node: candidates){
+            node_cost[node] = 0;
+        }
+
+        // if(! lisa_ctrl->isStartNode(node_id)) return node_cost;
+
+        auto relevant_samv_level_nodes = lisa_ctrl->getSameLevelNodes(node_id);
+        std::set<int> mapped_sameLevel_nodes;
+        for(auto rele_node: relevant_samv_level_nodes){
+            if(dumped_mapping.find(rele_node)!= dumped_mapping.end()){
+                mapped_sameLevel_nodes.insert(rele_node);
+            }
+        }
+        // if(mapped_sameLevel_nodes.size()== 0) assert(false);
+        auto & dist_label = dfg_label_->at(node_id).sameLevel_node_distance; 
+        auto cal_cost = [&](MRRGNode * a){
+            if(mapped_sameLevel_nodes.size()==0) return 0;
+            int total_cost = 0;
+            for(auto node: mapped_sameLevel_nodes){
+                auto & m = dumped_mapping[node];
+                int dist = std::abs(a->x_ - m.x) + std::abs(a->y_ - m.y);
+                total_cost += std::abs(dist_label[node] - dist);
+            }
+            return (int)(total_cost/(mapped_sameLevel_nodes.size()));
+        };
+
+        for(auto node: candidates){
+            node_cost[node] = cal_cost(node);
+        }
+
+        return node_cost;
+    }
+
+    std::pair<int,int> LISAMapper::getIntervalByScheduleOrder
+    (std::shared_ptr<OpGraph> opgraph, std::map<int, pos3d> & dumped_mapping, OpGraphOp *op,int scheduler_order ){
+        // return value is on II.
+        int start_time = -1, end_time = -1;
+
+        auto  early_ops_comp =   [ &](OpGraphOp * a, OpGraphOp * b) {
+            return dumped_mapping[node_to_id_ [a]].t  > dumped_mapping [node_to_id_ [b]].t;
+        };
+
+        auto  late_ops_comp =    [ &](OpGraphOp * a, OpGraphOp * b) {
+            return dumped_mapping[node_to_id_ [a]].t < dumped_mapping [node_to_id_ [b]].t;
+        };
+
+        std::set<OpGraphOp *, decltype(early_ops_comp)> early_ops(early_ops_comp);
+        std::set<OpGraphOp *, decltype(late_ops_comp)> late_ops(late_ops_comp);
+        // std::cout<<"this node"<<scheduler_order<<"\n";
+        for(auto node: opgraph->op_nodes){
+            // std::cout<< node<<" order: "<<dfg_label_->at(node_to_id_[node]).schedule_order<<"\n"; 
+            if(dfg_label_->at(node_to_id_[node]).schedule_order < scheduler_order  && mapping[node].size()!=0 ) early_ops.insert(node);
+            if(dfg_label_->at(node_to_id_[node]).schedule_order > scheduler_order  && mapping[node].size()!=0) late_ops.insert(node);
+        }
+       
+        if(early_ops.size() != 0){
+           start_time = mapping[*(early_ops.begin())].front()->cycle;
+        }
+        if(late_ops.size() != 0){
+           end_time = mapping[*(late_ops.begin())].front()->cycle;;
+        }
+
+        return std::make_pair(start_time, end_time);
+
+    }
+
+    std::vector<MRRGNode*> LISAMapper::getDesiredFu(MRRG *mrrg, int start_II, int end_II, OpGraphOp *op){
+        std::vector<MRRGNode *> candidates;
+        for (auto &fu : mrrg->function_nodes)
+        {
+            mpos mmmm{fu->x_, fu->y_, fu->cycle};
+            bool exist = false;
+            for(auto m :  mapped_pos){
+                if(m.x == mmmm.x && mmmm.y == m.y  && mmmm.t == m.t){
+                    exist = true;
+                    break;
+                }
+            }
+            if (fu->canMapOp(op) && occupancy[fu] == 0 && !exist)
+            {
+                if(fu->cycle >= start_II && fu->cycle <= end_II){
+                    candidates.push_back(fu);
+                }
+            }
+        }
+
+        std::sort(candidates.begin(), candidates.end(),
+        [](MRRGNode * a, MRRGNode * b) {
+            return a->cycle< b->cycle || ( a->cycle == b->cycle && a->x_+ a->y_ < b->x_+ b->y_) 
+            || ( a->cycle == b->cycle && a->x_+ a->y_ == b->x_+ b->y_ && a->x_ < b->x_); 
+        });
+        assert(candidates.size() > 0);
+        return candidates;
+    }
+   
\ No newline at end of file
diff -Nur cgra_me/src/core/lisa/LISASchedule.cpp lisa/cgra_me/src/core/lisa/LISASchedule.cpp
--- cgra_me/src/core/lisa/LISASchedule.cpp	1970-01-01 07:30:00.000000000 +0730
+++ lisa/cgra_me/src/core/lisa/LISASchedule.cpp	2022-02-28 16:37:25.916775574 +0800
@@ -0,0 +1,97 @@
+#include <CGRA/lisa/LISASchedule.h>
+
+LISASchedule::LISASchedule(LISADFG* dfg, int x, int y, int t, std::map<int, pos3d> & mapping){
+  // std::cout<<"fabric x2"<<x<<"fabric_y_"<<y<<std::endl;
+
+  dfg_ = dfg;
+  x_ = x;
+  y_ = y;
+  t_ = t;
+  // ts_mapping_ =  (int*) std::malloc( x_ * y_ * t_ * sizeof(int));
+  // for(int i =0; i<t_; i++){
+  //   for(int j =0; j<x_; j++){
+  //       for(int k = 0; k<y_;k++){
+  //           ts_mapping_[getOffset(j,k,i)] = -1;
+  //       }
+  //   }
+  // }
+  // // std::cout<<"max x y  t"<<x<<" "<<y<<" "<<t<<std::endl;
+  // for(auto m: mapping){
+  //   auto pos = m.second;
+  // //  std::cout<<pos.toStr()<<",";
+  //   ts_mapping_[getOffset(pos.x,pos.y,pos.t)] = m.first;
+  // }
+
+  mapping_ = mapping;
+
+  // LOG(LISAGNN)<<simpleSchedToString();
+
+}
+
+std::string LISASchedule::simpleSchedToString(){
+  // std::cout<<"mapping "<<mapping_.size();
+  std::stringstream output;
+  output<<"\n";
+  // for(int t = 0; t< t_; t++){
+  //   bool print_t = false;
+  //   bool has_node = false;
+  //   for(int i =0; i<x_; i++){
+  //     for(int j =0; j<y_; j++){
+  //       int node_id = ts_mapping_[getOffset(i,j,t)];
+  //       if(node_id != -1) {
+  //         if( !print_t) output<<"t :"<<t<<"\n";
+  //         output<<" <"<<i<<","<<j<<"> ->"<<node_id<<"\t";
+  //         has_node = true;
+  //         print_t = true;
+  //       }
+  //     }
+  //   }
+  //   if (has_node) output<<"\n";
+  // }
+   for(int t = 0; t< t_; t++){
+     std::vector<std::pair<int, pos3d>> mapped_node;
+     for(auto m: mapping_){
+       if(m.second.t == t){
+         mapped_node.push_back(std::make_pair(m.first, m.second));
+       }
+     }
+     if(mapped_node.size()!=0){
+        std::sort (mapped_node.begin(), mapped_node.end(), 
+        [this](std::pair<int, pos3d> a, std::pair<int, pos3d> b) {
+          return  a.second.x  + a.second.y <  b.second.x  + b.second.y ;
+        });
+        output<<"t :"<<t<<"\n";
+        for(auto node: mapped_node){
+           output<<" <"<<node.second.x<<","<<node.second.y<<"> ->"<<node.first<<"\t";
+        }
+        output<<"\n";
+     }
+    
+    
+   }
+  return output.str();
+}
+
+std::string LISASchedule::complexSchedToString(){
+  std::stringstream output;
+  
+  // for(int t = 0; t< t_; t++){
+  //   output<<"t :"<<t<<"\n";
+  //   for(int i =0; i<x_; i++){
+  //     output<<"\t";
+  //     for(int j =0; j<y_; j++){
+  //       int node_id = ts_mapping_[getOffset(i,j,t)];
+  //       if(node_id == -1){
+  //         output<<"_\t";
+  //       }else{
+  //         output<<node_id<<"\t";
+  //       }
+        
+  //     }
+  //     output<<"\n";
+  //   }
+  //   output<<"\n\n";
+  // }
+  return output.str();
+}
+
diff -Nur cgra_me/src/core/Mapper.cpp lisa/cgra_me/src/core/Mapper.cpp
--- cgra_me/src/core/Mapper.cpp	2018-05-09 09:34:57.000000000 +0800
+++ lisa/cgra_me/src/core/Mapper.cpp	2022-02-28 16:37:25.916775574 +0800
@@ -36,17 +36,22 @@
 #include <CGRA/Mapping.h>
 #include <CGRA/ILPMapper.h>
 #include <CGRA/AnnealMapper.h>
+#include <CGRA/lisa/LISAMapper.h>
 
 #include <CGRA/Exception.h>
 
 std::unique_ptr<Mapper> Mapper::createMapper(MapperType mt, std::shared_ptr<CGRA> cgra, int timelimit, const std::map<std::string, std::string> & args)
 {
+   
+    
     switch(mt)
     {
         case MapperType::ILPMapper:
             return std::make_unique<ILPMapper>(cgra, timelimit, args);
         case MapperType::AnnealMapper:
             return std::make_unique<AnnealMapper>(cgra, timelimit, args);
+        case MapperType::LISAMapper:
+            return std::make_unique<LISAMapper>(cgra, timelimit, args);
     }
     throw cgrame_error("Invalid Mapper Type Specified");
 }
@@ -63,12 +68,13 @@
 
 Mapping Mapper::mapOpGraph(std::shared_ptr<OpGraph> opgraph)
 {
+    assert(false && "should not call this function");
     int ii = 1;
     bool mapped = false;
     Mapping result(cgra, ii, opgraph);
     while(ii <= cgra->maxII)
     {
-        result  =  mapOpGraph(opgraph, ii);
+        result  =  mapOpGraph(opgraph, ii, "");
         if(result.isMapped())
             return result;        
     }
@@ -76,3 +82,7 @@
     return result;
 }
 
+bool operator<(const std::pair<float,MRRGNode*> & a, const std::pair<float,MRRGNode*> & b)
+{
+    return a.first > b.first;
+}
diff -Nur cgra_me/src/core/Mapping.cpp lisa/cgra_me/src/core/Mapping.cpp
--- cgra_me/src/core/Mapping.cpp	2018-05-09 09:34:57.000000000 +0800
+++ lisa/cgra_me/src/core/Mapping.cpp	2022-02-28 16:37:25.916775574 +0800
@@ -204,14 +204,14 @@
     for(auto & op : opgraph->op_nodes)
         o << *op << ": " << *mapping.at(op).front() << std::endl;
     o << std::endl;
-    o << "Connection Mapping Result:" << std::endl;
-    for(auto & val : opgraph->val_nodes)
-    {
-        o << *val << ":" << std::endl;
-        for(auto & node : mapping.at(val))
-            o << "  " << *node << std::endl;
-        o << std::endl;
-    }
+    // o << "Connection Mapping Result:" << std::endl;
+    // for(auto & val : opgraph->val_nodes)
+    // {
+    //     o << *val << ":" << std::endl;
+    //     for(auto & node : mapping.at(val))
+    //         o << "  " << *node << std::endl;
+    //     o << std::endl;
+    // }
 }
 
 void Mapping::outputDetailedMapping(std::ostream & o) const
diff -Nur cgra_me/src/core/Module.cpp lisa/cgra_me/src/core/Module.cpp
--- cgra_me/src/core/Module.cpp	2018-05-09 09:34:57.000000000 +0800
+++ lisa/cgra_me/src/core/Module.cpp	2022-02-28 16:37:25.916775574 +0800
@@ -974,7 +974,7 @@
             {
                 result->nodes[i][submrrg->first + "." + thenode->first] = thenode->second;
                 // update node name
-                thenode->second->name = submrrg->first + "." + thenode->first;
+                thenode->second->setName ( submrrg->first + "." + thenode->first);
             }
 
             i++;
diff -Nur cgra_me/src/core/ModuleFuncUnit.cpp lisa/cgra_me/src/core/ModuleFuncUnit.cpp
--- cgra_me/src/core/ModuleFuncUnit.cpp	2018-05-09 09:34:57.000000000 +0800
+++ lisa/cgra_me/src/core/ModuleFuncUnit.cpp	2022-02-28 16:37:25.916775574 +0800
@@ -74,7 +74,7 @@
     : Module(name, size)
 {
     // Latency and II will be set here when the mapper supports different latency for funcunits
-
+    // std::cout<<"add FU:"<<name<<"\n";
     // Module type
     mt = MOD_PRIM_FUNC;
     // Create the ports
@@ -196,6 +196,7 @@
         MRRGNode* m_in_b = new MRRGNode(this, i, "m_in_b");
         MRRGNode* m_out  = new MRRGNode(this, i, "m_out");
         MRRGNode* out  = new MRRGNode(this, i, "out");
+        // out->latency = 1; // zhaoying added this to fix latency bug
 
         // add nodes to MRRG
         result->nodes[i]["in_a"] = in_a;
diff -Nur cgra_me/src/core/ModuleRoutingStructures.cpp lisa/cgra_me/src/core/ModuleRoutingStructures.cpp
--- cgra_me/src/core/ModuleRoutingStructures.cpp	2018-05-09 09:34:57.000000000 +0800
+++ lisa/cgra_me/src/core/ModuleRoutingStructures.cpp	2022-02-28 16:37:25.916775574 +0800
@@ -77,9 +77,10 @@
         // create nodes
         MRRGNode* in = new MRRGNode(this, i,"in");
         MRRGNode* reg = new MRRGNode(this, i,"reg");
-        reg->latency = 1;
+        reg->latency = 0;
         reg->essential = true;
         MRRGNode* out = new MRRGNode(this, MOD_II(i+1), "out");
+        out->latency = 1;
 
         if (II != 1)
         {
diff -Nur cgra_me/src/core/MRRG.cpp lisa/cgra_me/src/core/MRRG.cpp
--- cgra_me/src/core/MRRG.cpp	2018-05-09 09:34:57.000000000 +0800
+++ lisa/cgra_me/src/core/MRRG.cpp	2022-02-28 16:37:25.916775574 +0800
@@ -253,6 +253,14 @@
 
     if(type == MRRG_NODE_FUNCTION)
         this->essential = true;
+
+    //find pos
+    // name example: block_12_0.const.const
+
+
+
+
+
 };
 
 std::string MRRGNode::getFullName()
@@ -260,6 +268,27 @@
     return std::to_string(cycle) + ":" + name;
 }
 
+void MRRGNode::setName(std::string name_){
+    this->name = name_;
+    // std::cout<<"set name"<<name_<<"\n";
+    if(name_.find("block")!=std::string::npos && name_.find("meshblock")==std::string::npos){
+        std::size_t block_index = name.find_first_of("block");
+        std::size_t first_found = name.find_first_of("_",block_index+3);
+        std::size_t second_found = name.find_first_of("_", first_found+1);
+        std::size_t first_dot = name.find_first_of(".");
+        // std::cout<<"first_found"<<first_found<<" second_found"<<second_found<<" first_dot"<<first_dot<<"\n";
+        auto x_string  = name.substr(first_found+1, second_found - first_found);
+        auto y_string  = name.substr(second_found+1, first_dot - second_found);
+        // std::cout<<"name:"<<name_<<" x_string:"<<x_string<<" y_string:"<<y_string<<"\n";
+        this->x_ = std::stoi(x_string);
+        this->y_ = std::stoi(y_string);
+
+    }
+
+
+}
+
+
 /*
 float MRRGNode::getCost(float penalty_factor)
 {
@@ -381,6 +410,19 @@
     return true;
 }
 
+int MRRG::distance (MRRGNode* a, MRRGNode* b){
+    // a-> b
+    int cycle_difference =  b->cycle - a->cycle -1;
+    if (cycle_difference < 0) cycle_difference = this->II + cycle_difference;
+
+    //TODO: should use any advanced calculation. For example, how should cycle_difference be calculated.
+    return abs(b->x_-a->x_) + abs(b->y_-a->y_) + cycle_difference;
+
+
+}
+
+
+
 bool MRRG::verify()
 {
 
diff -Nur cgra_me/src/run/cgrame.cpp lisa/cgra_me/src/run/cgrame.cpp
--- cgra_me/src/run/cgrame.cpp	2018-05-09 09:34:57.000000000 +0800
+++ lisa/cgra_me/src/run/cgrame.cpp	2022-02-28 16:37:25.916775574 +0800
@@ -38,6 +38,7 @@
 #include <iostream>
 #include <iomanip>
 #include <iterator>
+#include <chrono>
 
 #include <linux/limits.h>
 #include <unistd.h>
@@ -52,15 +53,116 @@
 #include <CGRA/dotparse.h>
 #include <CGRA/adlparse.h>
 
+#include <CGRA/dotparse.h>
+
 #include <CGRA/Visual.h>
 
 #include <cxxopts.hpp>
 
 #include <mini.hpp>
 
+#include <CGRA/lisa/gnn.h>
+#include <CGRA/lisa/LISAController.h>
+#include <CGRA/lisa/LISAMapper.h>
+
 #include <sys/types.h>
 #include <sys/stat.h>
 
+//FIXME: actually, we do not know which edge is backedge in CGRA_ME, though we can find the cycle.
+    // But cgra-me seems order the node that somehow follow the data dependency. Let us try to use this now.
+
+
+void find_backedge(std::vector<std::pair<int, int>> lisa_edges, std::set<std::pair<int, int>> lisa_backedges, std::map<int, OpGraphOp*> & id_to_node)
+{
+    std::map<int, std::set<int>> node_transitive_children; //
+    std::map<int, std::set<int>> node_transitive_parents;  //
+    std::set<int> global_visited_node;
+
+    for (auto info : id_to_node)
+    {
+        node_transitive_children.emplace(info.first, std::set<int>());
+        node_transitive_parents.emplace(info.first, std::set<int>());
+    }
+
+
+    //FIXME: this cannot detect all the backedges. Please compare with the one in LISAController:init labels.
+    for (auto e : lisa_edges)
+    {
+        if (node_transitive_children[e.second].find(e.first) != node_transitive_children[e.second].end())
+        {
+            //backedge
+            lisa_backedges.insert(std::make_pair(e.first, e.second));
+        }
+        else
+        {
+            // std::cout<<"visit"<<e.src<<","<<e.des<<std::endl;
+            for (auto parent : node_transitive_parents[e.first])
+            {
+                node_transitive_parents[e.second].insert(parent);
+            }
+            node_transitive_children[e.first].insert(e.second);
+            node_transitive_parents[e.second].insert(e.first);
+            for (auto child : node_transitive_children[e.second])
+            {
+                node_transitive_children[e.first].insert(child);
+            }
+        }
+    }
+    std::vector<std::pair<int, int>> temp_edges;
+    for(auto e: lisa_edges){
+        if(lisa_backedges.find(e) == lisa_backedges.end()){
+            temp_edges.push_back(e);
+        }
+    }
+    assert(temp_edges.size() + lisa_backedges.size() == lisa_edges.size());
+    lisa_edges = temp_edges;
+}
+
+void set_edges(std::shared_ptr<OpGraph> opgraph_, std::vector<std::pair<int, int>> &lisa_edges, std::set<std::pair<int, int>> & lisa_backedges,  std::map<OpGraphOp*, int>  node_to_id_,  std::map<int, OpGraphOp*> & id_to_node)
+{
+
+    LOG(LISAGNN) << "dump edges in original operator graph";
+
+    // this is from cgra_me
+    // std::map<OpGraphOp *, int> opnode_map;
+    // int counter = 0;
+    // for (auto it = opgraph_->op_nodes.begin(); it != opgraph_->op_nodes.end(); it++)
+    // {
+    //     assert(*it);
+    //     opnode_map[(*it)] = counter++;
+    //     // std::cout << opnode_map[(*it)] << "[opcode=" << (*it)->opcode << "];\n";
+    // }
+
+    for (auto it = opgraph_->val_nodes.begin(); it != opgraph_->val_nodes.end(); it++)
+    {
+        int inputnode = node_to_id_[(*it)->input];
+
+        assert((*it)->output.size() == (*it)->output_operand.size());
+        for (unsigned int o = 0; o < (*it)->output.size(); o++)
+        {
+            OpGraphOp *op = (*it)->output[o];
+            unsigned int operand = (*it)->output_operand[o];
+            if(inputnode != node_to_id_[op] )lisa_edges.push_back(std::make_pair(inputnode, node_to_id_[op]));
+            // std::cout << inputnode << "->" << opnode_map[op] << "[operand=" << operand << "]; ";
+            // std::cout << "//" << (*it)->input->name << "->" << op->name << "\n";
+        }
+    }
+
+    LOG(LISAGNN) << " edges";
+    for (auto it : lisa_edges)
+    {
+        LOG(LISAGNN) << "  (" << it.first << "," << it.second << ")";
+    }
+
+    ;
+    find_backedge(lisa_edges, lisa_backedges, id_to_node);
+    LOG(LISAGNN) << "back edges";
+    for (auto it : lisa_backedges)
+    {
+        LOG(LISAGNN) << "  (" << it.first << "," << it.second << ")";
+    }
+}
+
 int main(int argc, char* argv[])
 {
     std::cout << std::endl;
@@ -71,6 +173,10 @@
     std::cout << "Compiled: " << __DATE__ << " " << __TIME__ << std::endl;
     std::cout << std::endl;
 
+     for(int i=0; i < argc; i++){
+        std::cout << "Argument " << i << ": " << argv[i] << std::endl;
+    }
+
     UserArchs userarchs;
 
     std::string arch_filename, dfg_filename, hdl_dirpath;
@@ -78,13 +184,25 @@
     std::string arch_opts;
     MapperType mapper_type;
     std::string mapper_opts;
-    int II;
+    int max_II;
+    int start_II;
     double timelimit;
     bool printarch;
     bool printop;
     bool genverilog;
     bool make_testbench;
     int adl;
+    int cgra_x;
+    int cgra_y;
+    bool lisa_training;
+    bool lisa_inef;
+    bool lisa_eval_routing_priority;
+    bool lisa_eval_unmapped;
+    std::string training_output_file;
+    std::string lisa_dfg_id = "none"; // this is for LISA and dump final labels
+    std::string arch_model_name = "cgra_me"; //used as folder name of dumped label
+    bool parallel_rouing_and_place = false;
+    bool SA_more_running_time = false;
 
     try
     {
@@ -98,14 +216,26 @@
             ("arch-list", "Show the List of Avaliable C++ Architectures with IDs", cxxopts::value<bool>())
             ("arch-opts", "C++ Architecture Options that Overwrites the Default Ones (<Key>=<Value> Pairs, Separate by Space, and Close by Quotation Marks)", cxxopts::value<std::string>(), "<\"opts\">")
             ("arch-opts-list", "Show the List of Avaliable Options for a C++ Architecture, ID # Generated from --arch-list", cxxopts::value<int>(), "<#>")
-            ("i,II", "Architecture Contexts", cxxopts::value<int>()->default_value("1"), "<#>")
+            ("i,II", "Architecture Contexts, Zhaoying: this should be max II value", cxxopts::value<int>()->default_value("32"), "<#>")
+            ("sII", "start II", cxxopts::value<int>()->default_value("1"), "<#>")
             ("g,dfg", "The DFG file to map in dot format", cxxopts::value<std::string>())
-            ("m,mapper", "Which Mapper to Use (0 = ILP, 1 = Simulated Annealing)", cxxopts::value<int>()->default_value("0"), "<#>")
+            ("dfg_id", "The is for LISA training, and dump ", cxxopts::value<std::string>()->default_value("none"))
+            ("m,mapper", "Which Mapper to Use (0 = ILP, 1 = Simulated Annealing, 2 = LISA mapper)", cxxopts::value<int>()->default_value("0"), "<#>")
             ("mapper-opts", "Mapper Options that Overwrites the Default Ones (<Key>=<Value> Pairs, Separate by Space, and Close by Quotation Marks)", cxxopts::value<std::string>(), "<\"opts\">")
             ("v,visual", "Output visualization directory after mapping", cxxopts::value<bool>())
             ("t,timelimit", "Mapper Timelimit", cxxopts::value<double>()->default_value("7200.0"), "<#>")
+            ("training", "training for LISA", cxxopts::value<bool>())
+            ("inef", "inference with LISA", cxxopts::value<bool>())
+            ("eval_routing_priority", "evaluate routing priority", cxxopts::value<bool>())
+            ("eval_unmapped", "evaluate unmapped", cxxopts::value<bool>())
+            ("ppr", "parallel routing and placement", cxxopts::value<bool>())
+            ("arch_name", "arch name",  cxxopts::value<std::string>()->default_value("cgra_me"), "<#>")
+            ("training_output", "training output log for LISA",  cxxopts::value<std::string>()->default_value("lisa_training"), "<#>")
             ("a,print-arch", "Print Architecture to stdout", cxxopts::value<bool>())
             ("o,print-op", "Print Operation Graph to stdout", cxxopts::value<bool>())
+            ("sa_more_running_time", "add more SA running time", cxxopts::value<bool>())
+            ("cgra_x", "cgra_x", cxxopts::value<int>()->default_value("12"), "<#>")
+            ("cgra_y", "cgra_y", cxxopts::value<int>()->default_value("4"), "<#>")
             ("gen-verilog", "Generate Verilog Implementation of Architecture and Dump to Specified Directory", cxxopts::value<std::string>(), "<Directorypath>")
             ("gen-testbench", "Generate testbench for use in a simulation of the DFG with configuration bitstream", cxxopts::value<bool>())
             ;
@@ -181,12 +311,24 @@
         arch_opts = options["arch-opts"].as<std::string>();
         mapper_type = static_cast<MapperType>(options["mapper"].as<int>());
         mapper_opts = options["mapper-opts"].as<std::string>();
-        II = options["II"].as<int>();
+        max_II = options["II"].as<int>();
+        start_II = options["sII"].as<int>();
         timelimit = options["timelimit"].as<double>();
         printarch = options["print-arch"].as<bool>();
         printop = options["print-op"].as<bool>();
         adl = options["parser"].as<int>();
         make_testbench = options["gen-testbench"].as<bool>();
+        cgra_x = options["cgra_x"].as<int>();
+        cgra_y = options["cgra_y"].as<int>();
+        lisa_training = options["training"].as<bool>();
+        lisa_inef = options["inef"].as<bool>();
+        lisa_eval_unmapped = options["eval_unmapped"].as<bool>();
+        lisa_eval_routing_priority = options["eval_routing_priority"].as<bool>();
+        training_output_file = options["training_output"].as<std::string>();
+        arch_model_name = options["arch_name"].as<std::string>();
+        lisa_dfg_id = options["dfg_id"].as<std::string>();
+        parallel_rouing_and_place = options["ppr"].as<bool>();
+        SA_more_running_time = options["sa_more_running_time"].as<bool>();  
     }
     catch(const cxxopts::OptionException & e)
     {
@@ -349,28 +491,359 @@
             else
                 std::cout << "[WARNING] Mapper Parameter: " << key << " doesn't exist, Skipping: " << key << " = " << value << std::endl;
         }
+        if(SA_more_running_time){
+            // assert(mapper_args.find("AnnealMapper.swap_factor")!=mapper_args.end());
+            // std::cout << "[INFO] allow SA to search more steps...  old:"<<mapper_args["AnnealMapper.swap_factor"];
+            // mapper_args["AnnealMapper.swap_factor"] = std::to_string(std::stoi( mapper_args["AnnealMapper.swap_factor"]) * 10 );
+            // std::cout<<" new:"<<mapper_args["AnnealMapper.swap_factor"]<<std::endl;
 
-        std::cout << "[INFO] Creating Mapper..." << std::endl;
-        auto mapper = Mapper::createMapper(mapper_type, arch, timelimit, mapper_args);
 
-        Mapping mapping_result = mapper->mapOpGraph(opgraph, II);
+            // assert(mapper_args.find("AnnealMapper.cold_accept_rate")!=mapper_args.end());
+            // std::cout << "[INFO] allow explore all temperature...  old:"<<mapper_args["AnnealMapper.cold_accept_rate"];
+            // mapper_args["AnnealMapper.cold_accept_rate"] = std::to_string(0);
+            // std::cout<<" new:"<<mapper_args["AnnealMapper.cold_accept_rate"]<<std::endl;
+            timelimit = 3600 * 4;
 
-        if(mapping_result.isMapped())
-        {
-            std::cout << std::endl;
-            genMappingVisual(exe_path, mapping_result);
-            mapping_result.outputMapping();
+        }
+        std::cout << "[INFO] Creating Mapper..." << std::endl;
+        arch->ROWS = cgra_x;
+        arch->COLS = cgra_y;
+        
+        
+
+        
+
+        
+        // simply calculated by DFG/fu node
+        MRRG* mrrg = arch->getMRRG(1).get();
+        for (auto &fu : mrrg->function_nodes)
+        {
+            std::cout<<fu->getFullName()<<"\n";
+        }
+        // assert(false);
+        int fu_num = (cgra_x -2)* (cgra_y -2);// cgra-me did not provide an elegant way to get the fu/pe number;
+        
+        std::set<OpGraphOp*> unique_set;
+        for(auto node:opgraph->op_nodes ){
+            if(node->opcode !=OpGraphOpCode::OPGRAPH_OP_INPUT && node->opcode !=OpGraphOpCode::OPGRAPH_OP_OUTPUT){
+                unique_set.insert(node);
+            }
+        }
+        int dfg_num  = unique_set.size();
+        int min_II = ceil( (float)dfg_num / fu_num);
+        std::cout<<"fu num:"<<fu_num<< " dfg num:"<<dfg_num<< " minII:"<<min_II<<"\n";
+        std::string result_filename = "result/";
+        if(lisa_eval_routing_priority){
+            result_filename = result_filename + "eval_routing_priority_"+ arch_model_name+ "_result.txt";
+        }else if(lisa_eval_unmapped){
+            result_filename = result_filename + "eval_unmapped_"+ arch_model_name+ "_result.txt";
+        }else if(SA_more_running_time){
+            result_filename = result_filename + "sa_more_running_time_"+ arch_model_name+ "_result.txt";
+        }else{
+            result_filename = result_filename + arch_model_name+ "_result.txt";
+        }
+        
+        std::ofstream result_file;
+        
+
+        std::string method;
+        if(mapper_type == MapperType::ILPMapper){
+            method = "ILP";
+        }else if(mapper_type ==  MapperType::AnnealMapper){
+             method = "SA";
+        }else if(mapper_type == MapperType::LISAMapper){
+            method = "i-LISA";
+            if(parallel_rouing_and_place){
+                method = "para_i-LISA"; // no need to use this one
+            }
+        }
 
-            if (make_testbench)
-            {
-                std::ofstream tb_file("testbench.v");
-                arch->genBitStream(mapping_result).print_testbench(tb_file);
+        std::shared_ptr<LISAController>  lisa_ctl;
+        
+           // init lisa_ctl
+            std::map<OpGraphOp*, int>  node_to_id_;
+            std::map<int, OpGraphOp*>  id_to_node_;
+            auto & nodes = opgraph->op_nodes;
+            std::set<int> gotten_node_id;
+            auto get_node_id = [](std::string str){
+                int i =0;
+                std::string final_str = "";
+                for ( ; i < str.length(); i++ ){ if ( isdigit(str[i]) ) final_str+= str[i]; }
+                return  atoi(final_str .c_str());
+            };
+            for(auto node: nodes){
+                int extracted_node_id = get_node_id(node->name);
+                assert(gotten_node_id.find(extracted_node_id) == gotten_node_id.end());
+                gotten_node_id.insert(extracted_node_id);
+                node_to_id_.emplace(node, extracted_node_id);
+                id_to_node_.emplace(extracted_node_id, node);
             }
+            std::set<int> node_list;
+            for(auto node: id_to_node_){
+                node_list.insert(node.first);
+            }
+            std::map<int, std::string> node_op;
+            for(auto node: id_to_node_){
+                std::string temp_string  = node.second->name;
+                temp_string.erase(std::remove_if(std::begin(temp_string), std::end(temp_string), 
+                           [](auto ch) { return std::isdigit(ch); }), 
+                            temp_string.end()); 
+                node_op[node.first] = temp_string;
+                
+            }
+
+            std::vector<std::pair<int, int>> lisa_edges;
+            std::set<std::pair<int, int>> lisa_backedges;
+            set_edges(opgraph, lisa_edges, lisa_backedges, node_to_id_, id_to_node_);
+            lisa_ctl = std::make_shared<LISAController>( LISAController(cgra_x, cgra_y , lisa_dfg_id, node_list, node_op, lisa_edges));
+            lisa_ctl->setArchandDFGFileName(arch_filename, dfg_filename, arch_model_name);
+            lisa_ctl->setMII(min_II);
+            
+        if( mapper_type ==  MapperType::LISAMapper && lisa_inef){
+            lisa_ctl->callGNNInference();
+            method = "LISA";
+        }
+        else if( mapper_type ==  MapperType::LISAMapper && lisa_training)
+        {
+            
+            std::ofstream training_log;
+            training_log.open (training_output_file + ".txt"); 
+            training_log << arch_filename<<" "<<dfg_filename<<"\n";
+
+            perf_metric  best_perf = {100 , 0 , 0};
+
+            int max_training_iteration = 5;
+            int num_best_perf = 5;
+            std::vector<perf_metric> perf_hist;
+            auto training_start_time = std::chrono::steady_clock::now();
+            auto start = std::chrono::steady_clock::now();
+            for(int traning_iteration  = 0; traning_iteration < max_training_iteration;  traning_iteration++){
+                 
+
+                bool update_label = true; 
+
+                std::shared_ptr<std::map<int, node_label>> curr_label = lisa_ctl->getCurrLabel();
+                int currII = start_II;
+                currII = currII < min_II? min_II: currII;
+                while(currII <= max_II){
+                    std::cout<<"*************** try II:"<<currII<<" max II:"<<max_II<<std::endl;
+
+                    if(currII > best_perf.ii){
+                        std::cout<<"training iteration:"<<traning_iteration<<"  try II:"<<currII<<" is bigger than best II, give up"<<std::endl;
+                        training_log << "training iteration:"<<traning_iteration<<" try II:"<<currII<<" is bigger than best II, give up"<<std::endl;
+                        break;
+                    }   
+                    
+                    auto  mapper = std::make_unique<LISAMapper>(arch, timelimit, mapper_args);
+                    mapper->initLisa(lisa_edges, lisa_backedges, node_to_id_, id_to_node_, curr_label);
+                    mapper->setLISAController(lisa_ctl, (cgra_x -2), (cgra_y -2));
+                    mapper->enableTraining();
+                    if(lisa_eval_routing_priority) mapper->enable_eval_routing_priority();
+                    Mapping mapping_result = mapper->mapOpGraph(opgraph, currII, arch_model_name);
+                    if(mapping_result.isMapped())
+                    {
+                        std::cout << "*************** mapped successful on II "<<currII<<" *********************"<<std::endl;
+                        genMappingVisual(exe_path, mapping_result);
+                        mapping_result.outputMapping();
+                        if (make_testbench)
+                        {
+                            std::ofstream tb_file("testbench.v");
+                            arch->genBitStream(mapping_result).print_testbench(tb_file);
+                        }
+                        auto end = std::chrono::steady_clock::now();
+                        std::chrono::duration<double> elapsed_seconds = end-start;
+                        int used_second =   elapsed_seconds.count() ;
+                        perf_metric this_iter_perf { currII, mapper->getFinalCost() , used_second };
+                       
+                        perf_hist.push_back(this_iter_perf);
+
+                        int max_latency ;
+                        std::map<int, pos3d> dumpedmapping = mapper->dumpMapping(opgraph, max_latency);
+
+                        bool is_best = false;
+                        
+                        if(traning_iteration == 0 || this_iter_perf < best_perf) {
+                             best_perf = this_iter_perf;
+                             is_best = true;
+                        }
+                        result_file.open (result_filename, std::ios_base::app); 
+                        if((lisa_dfg_id == "none" || lisa_eval_unmapped) && traning_iteration == 0) result_file << arch_filename<<" "<<dfg_filename<<" "<<method<<" "<<min_II<<" "<<this_iter_perf.ii<<" "<<this_iter_perf.running_time<<"\n";
+                        result_file.close();
+                        lisa_ctl->passMapping(is_best, dumpedmapping,max_latency, this_iter_perf);
+                        std::string update_label_string = update_label ? "yes": "no";
+                        std::cout<<"*************** *************** *************** *************** *************** \n";
+                        std::cout<<"training iteration:"<<traning_iteration <<" mapped II:"<<this_iter_perf.ii<<" cost:"<<this_iter_perf.cost<<" running time:"<<this_iter_perf.running_time<<"\n";
+                        std::cout<<"*************** *************** *************** *************** *************** \n";
+                        training_log << "training iteration:"<<traning_iteration<<" mapped II:"<<this_iter_perf.ii<<" running time:"<<this_iter_perf.running_time<<std::endl;
+
+                        break;
+                    }
+                    std::cout << "*************** mapped failed on II "<<currII<<std::endl;
+                    currII ++;
+
+                    auto curr_time = std::chrono::steady_clock::now();
+                    std::chrono::duration<double> elapsed_seconds = curr_time-start;
+                    int used_second =   elapsed_seconds.count() ;
+                    // this is for GNN path, avoid waste time for GNN
+                    if( lisa_dfg_id != "none" && traning_iteration == 0 && used_second  >  3600 * 4){
+                        max_training_iteration = -1;
+                        break;
+                    }
+                }
 
+
+                //
+                if(traning_iteration +1 == max_training_iteration){
+                    int best_num = 0;
+                    for(auto perf: perf_hist){
+                        if( perf.ii == best_perf.ii && perf.cost <  best_perf.cost * 1.1){
+                            best_num ++;
+                        }
+                    }
+                    if(best_num < num_best_perf){
+                        max_training_iteration ++;
+                    }
+                }
+
+                auto curr_time = std::chrono::steady_clock::now();
+                std::chrono::duration<double> elapsed_seconds = curr_time-start;
+                int used_second =   elapsed_seconds.count() ;
+                if(used_second >  3600 * 10){
+                    break;
+                }
+            }
+            method = "tb-LISA";
+            std::cout<<"*************** *************** *************** *************** *************** \n";
+            std::cout<<"final best one: MII:"<< min_II <<" mapped II:"<<best_perf.ii<<" cost:"<< best_perf.cost<<" running time:"<<best_perf.running_time<<"\n";
+            std::cout<<"*************** *************** *************** *************** *************** \n";
+            training_log << "final best one: MII"<< min_II<<" mapped II:"<<best_perf.ii<<" cost:"<< best_perf.cost<<" running time:"<<best_perf.running_time<<std::endl;
+            result_file.open (result_filename, std::ios_base::app); 
+            if(lisa_dfg_id == "none" || lisa_eval_unmapped) result_file << arch_filename<<" "<<dfg_filename<<" "<<method<<" "<<min_II<<" "<<best_perf.ii<<" "<<best_perf.running_time<<"\n";
+            result_file.close();
+            lisa_ctl->generateCombinedBestLabelHistorically(best_perf);
+            lisa_ctl->dumpBestLabelForGNNDataSet();
+            method = "t-LISA";
+
+            for(int i = 0; i< 0; i++){
+                int currII = start_II;
+                currII = currII < min_II? min_II: currII;
+                 while(currII <= max_II){
+                    std::cout<<"*************** try II:"<<currII<<" max II:"<<max_II<<std::endl;
+                    auto mapper = Mapper::createMapper(mapper_type, arch, timelimit, mapper_args);
+                    
+                    if( (mapper_type == MapperType::LISAMapper))
+                    {
+                        LISAMapper* lmapper = dynamic_cast<LISAMapper*>(mapper.get());
+                        
+                        lmapper->initLisa(lisa_edges, lisa_backedges, node_to_id_, id_to_node_, lisa_ctl->getBestLabel());
+                        lmapper->setLISAController(lisa_ctl, (cgra_x -2), (cgra_y -2));
+                        if(lisa_eval_routing_priority) lmapper->enable_eval_routing_priority();
+                    }
+        
+                    Mapping mapping_result = mapper->mapOpGraph(opgraph, currII, arch_model_name);
+
+                    if(mapping_result.isMapped())
+                    {
+                        std::cout << "*************** mapped successful on II "<<currII<<" *********************"<<std::endl;
+                        genMappingVisual(exe_path, mapping_result);
+                        mapping_result.outputMapping();
+
+                        if (make_testbench)
+                        {
+                            std::ofstream tb_file("testbench.v");
+                            arch->genBitStream(mapping_result).print_testbench(tb_file);
+                        }
+
+                        break;
+                    }
+                    std::cout << "*************** mapped failed on II "<<currII<<std::endl;
+                    currII ++;
+                }
+                training_log << "test iteration:"<<i<<" mapped II:"<<currII<<std::endl;
+            }
+            
+            training_log.close();
+            if(lisa_dfg_id != "none"){return 0;}
+        }
+        if(lisa_eval_unmapped && lisa_training){
             return 0;
         }
-        else
-            return 1;
+         
+
+        int running_time = 1;
+        if(mapper_type == MapperType::AnnealMapper || lisa_eval_routing_priority ){
+            running_time = 3;
+        }
+        std::vector<perf_metric> perf_hist;
+        for(int i = 0; i < running_time; i++ ){
+
+            int currII = start_II;
+            currII = currII < min_II? min_II: currII;
+            
+            auto start = std::chrono::steady_clock::now();
+
+    
+            while(currII <= max_II){
+                std::cout<<"*************** try II:"<<currII<<" max II:"<<max_II<<std::endl;
+                auto mapper = Mapper::createMapper(mapper_type, arch, timelimit, mapper_args);
+                
+                if( (mapper_type == MapperType::LISAMapper))
+                {
+                    LISAMapper* lmapper = dynamic_cast<LISAMapper*>(mapper.get());
+                    if(parallel_rouing_and_place){
+                        lmapper->place_and_routing_parallel = true;
+                    }
+                    lmapper->initLisa(lisa_edges, lisa_backedges, node_to_id_, id_to_node_, lisa_ctl->getBestLabel());
+                    lmapper->setLISAController(lisa_ctl, (cgra_x -2), (cgra_y -2));
+                    if(lisa_eval_routing_priority) lmapper->enable_eval_routing_priority();
+                }
+    
+                Mapping mapping_result = mapper->mapOpGraph(opgraph, currII, arch_model_name);
+
+                if(mapping_result.isMapped())
+                {
+                    std::cout << "*************** mapped successful on II "<<currII<<" *********************"<<std::endl;
+                    genMappingVisual(exe_path, mapping_result);
+                    mapping_result.outputMapping();
+
+                    if (make_testbench)
+                    {
+                        std::ofstream tb_file("testbench.v");
+                        arch->genBitStream(mapping_result).print_testbench(tb_file);
+                    }
+
+                    break;
+                }
+                std::cout << "*************** mapped failed on II "<<currII<<std::endl;
+                currII ++;
+            }
+            auto end = std::chrono::steady_clock::now();
+            std::chrono::duration<double> elapsed_seconds = end-start;
+            int used_second =   elapsed_seconds.count() ;
+            std::cout << "elapsed time: " << elapsed_seconds.count() << "s\n";
+            perf_metric this_iter_perf { currII, 0 , used_second };
+            perf_hist.push_back(this_iter_perf);
+        }
+        std::sort(perf_hist.begin(), perf_hist.end());
+
+        int median_index = 0;
+        for(int j = 0; j < running_time; j++){
+            std::cout<<"perf"<<j <<" "<<perf_hist[j].ii<<""<<perf_hist[j].running_time<<"\n";
+        }
+        if(running_time == 3) {
+            median_index = 1;
+            assert(perf_hist.size() == 3);
+        }
+        if(SA_more_running_time){
+            assert(mapper_type ==  MapperType::AnnealMapper );
+            method = "SA_T";
+        }
+        perf_metric final_perf = perf_hist[median_index];
+        result_file.open (result_filename, std::ios_base::app); 
+        result_file << arch_filename<<" "<<dfg_filename<<" "<<method<<" "<<min_II<<" "<<final_perf.ii<<" "<<final_perf.running_time<<"\n";
+        result_file.close();
+        
+        return 0; // cannot map
     }
     catch(const cgrame_error & e)
     {
diff -Nur cgra_me/src/run/mapper_config.ini lisa/cgra_me/src/run/mapper_config.ini
--- cgra_me/src/run/mapper_config.ini	2018-05-09 09:34:57.000000000 +0800
+++ lisa/cgra_me/src/run/mapper_config.ini	2022-02-28 16:37:25.916775574 +0800
@@ -15,6 +15,6 @@
 initial_pfactor = 0.001
 pfactor_factor = 1.05
 constant_temp_factor = 0.999
-swap_factor = 100
+swap_factor = 50
 cold_accept_rate = 0.01
 
